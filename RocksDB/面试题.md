# RocksDB 面试题

## 题目
## 2. RocksDB核心概念？
## 3. RocksDB写入流程？
## 4. RocksDB-compaction？
## 5. RocksDB性能优化？
## 6. RocksDB与Redis对比？
## 7. RocksDB使用场景？

更多题目请查看答案文件

## 答案

**题目：**
RocksDB是什么？有什么特点？

**答案：**
**RocksDB定义：**
Facebook开源的嵌入式Key-Value存储引擎，基于LSM树实现。

**特点：**
- 高性能
- 持久化
- 嵌入式（Java/C++/Go）
- 可配置性强
- 支持事务

**使用场景：**
- MyRocks（MySQL存储引擎）
- TiKV底层存储
- 消息队列持久化
- 日志存储

**基本操作：**
```java
// 创建DB
Options options = new Options();
options.setCreateIfMissing(true);
RocksDB db = RocksDB.open(options, "/path/to/db");

// 写入
db.put(key.getBytes(), value.getBytes());

// 读取
byte[] value = db.get(key.getBytes());

// 删除
db.delete(key.getBytes());
```

---

## 2. RocksDB核心概念？

**题目：**
RocksDB有哪些核心概念？

**答案：**
**核心概念：**

| 概念 | 说明 |
|------|------|
| **MemTable** | 内存表（活跃写入） |
| **WAL** | 预写日志（Write-Ahead Log） |
| **SSTable** | 有序字符串表（磁盘文件） |
| **Manifest** | 元数据文件 |
| **Compaction** | 合并压缩 |

**数据存储：**
```
WAL（磁盘） → MemTable（内存） → SSTable（磁盘）
```

**SSTable结构：**
```
┌─────────────────────────────────────────────────┐
│                   SSTable                        │
│  ┌─────────┐  ┌─────────┐  ┌─────────┐         │
│  │ Level 0 │  │ Level 1 │  │ Level N │         │
│  │ (新)    │  │         │  │ (旧)    │         │
│  └─────────┘  └─────────┘  └─────────┘         │
│                                                 │
│  每个SSTable包含：                               │
│  - Data Block（数据块）                          │
│  - Index Block（索引块）                         │
│  - Filter Block（布隆过滤器）                    │
└─────────────────────────────────────────────────┘
```

---

## 3. RocksDB写入流程？

**题目：**
RocksDB的写入流程是什么？

**答案：**
**写入流程：**
```
1. 写入WAL（预写日志）
2. 写入MemTable（内存表）
3. MemTable满 → 转换为Immutable MemTable
4. 后台线程将Immutable MemTable刷盘为SSTable
```

**详细流程：**
```
┌─────────────────────────────────────────────────────────┐
│                    RocksDB写入流程                       │
│                                                         │
│  write(key, value)                                      │
│       ↓                                                 │
│  ┌─────────────────────────┐                            │
│  │  1. 写入WAL（磁盘）      │  持久化保证                │
│  └─────────────────────────┘                            │
│       ↓                                                 │
│  ┌─────────────────────────┐                            │
│  │  2. 写入MemTable（内存） │  内存中                  │
│  └─────────────────────────┘                            │
│       ↓                                                 │
│  ┌─────────────────────────┐                            │
│  │  3. 返回客户端成功       │  快速响应                 │
│  └─────────────────────────┘                            │
│       ↓                                                 │
│  ┌─────────────────────────┐                            │
│  │  4. 后台刷盘 → SSTable  │  异步执行                 │
│  └─────────────────────────┘                            │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

**Write Batch：**
```java
// 原子写入多条
WriteBatch batch = new WriteBatch();
batch.put(key1, value1);
batch.put(key2, value2);
db.write(writeOptions, batch);
```

---

## 4. RocksDB Compaction？

**题目：**
什么是RocksDB Compaction？

**答案：**
**Compaction定义：**
将多个SSTable合并为少数SSTable，删除旧版本和删除的数据。

**Compaction类型：**

**1. Minor Compaction**
```
MemTable → SSTable
Level 0 → Level 0的多个SSTable合并
```

**2. Major Compaction**
```
Level N → Level N+1
合并多个SSTable
```

**Compaction策略：**
```java
// Universal Compaction（大小相近）
UniversalCompactionBuilder builder = 
    new UniversalCompactionBuilder(db, level0);

/* Tiered Compaction（分层）
   Level大小递增 */
TieredCompactionBuilder builder = 
    new TieredCompactionBuilder(db);
```

**为什么需要Compaction：**
```
1. 删除旧数据（过期数据）
2. 合并碎片
3. 减少文件数量
4. 优化读取
```

**Compaction影响：**
```
优点：优化存储、提升读性能
缺点：占用CPU和IO、可能影响写入
```

**优化策略：**
```java
// 限制后台IO
options.setMaxBackgroundJobs(4);

// Compaction限速
options.setRateLimiter(
    new RateLimiter(100 * 1024 * 1024));  // 100MB/s
```

---

## 5. RocksDB性能优化？

**题目：**
如何优化RocksDB性能？

**答案：**
**1. 写入优化**
```java
// 批量写入
WriteOptions writeOptions = new WriteOptions();
writeOptions.setSync(false);  // 异步刷盘
writeOptions.setDisableWAL(true);  // 禁用WAL（可容忍丢失）

// 批量写入
List<Pair<byte[], byte>> records = ...;
db.write(writeOptions, records);
```

**2. 读取优化**
```java
// 使用Bloom Filter
options.setFilterPolicy(
    new BloomFilter(10, false));

// 开启缓存
BlockCache cache = new LRUCache(100 * 1024 * 1024);
options.setBlockCache(cache);

// 使用前缀查找
options.setPrefixExtractor(
    new FixedPrefixTransform(10));
```

**3. 内存配置**
```java
// MemTable大小
options.setMaxWriteBufferNumber(4);
options.setWriteBufferSize(64 * 1024 * 1024);  // 64MB

// Block Cache
BlockCache blockCache = new LRUCache(256 * 1024 * 1024);
options.setBlockCache(blockCache);

options.setMaxOpenFiles(-1);  // 打开所有文件
```

**4. Compaction优化**
```java
// 控制并发
options.setMaxBackgroundJobs(8);

// Compaction限速
RateLimiter rateLimiter = new RateLimiter(100 * 1024 * 1024);
options.setRateLimiter(rateLimiter);
```

**5. 监控指标**
```java
// 获取统计
Statistics stats = db.getStatistics();
System.out.println(stats.toString());
```

---

## 6. RocksDB与Redis对比？

**题目：**
RocksDB和Redis有什么区别？

**答案：**
**对比表格：**

| 特性 | RocksDB | Redis |
|------|---------|-------|
| **类型** | 持久化存储 | 内存存储 |
| **数据结构** | Key-Value | 多种数据结构 |
| **性能** | 高（磁盘） | 极高（内存） |
| **持久化** | 强（LSM树） | 需配置（RDB+AOF） |
| **容量** | 大（TB级） | 受限（内存） |
| **嵌入式** | 是 | 否（需独立部署） |
| **事务** | 支持 | 支持 |
| **使用场景** | 底层存储 | 缓存、消息队列 |

**选择建议：**
```
RocksDB：
- 大容量持久化
- 嵌入式部署
- 写入密集

Redis：
- 高速缓存
- 复杂数据结构
- 内存计算
```

---

## 7. RocksDB使用场景？

**题目：**
RocksDB适合什么场景？

**答案：**
**典型场景：**

**1. MyRocks**
```
MySQL存储引擎
压缩率高（比InnoDB高50%）
```

**2. TiKV底层存储**
```
分布式数据库TiKV
KV存储引擎
```

**3. 消息队列持久化**
```
Kafka offset存储
RocketMQ消息存储
```

**4. 日志存储**
```
时序数据
事件日志
```

**5. 缓存系统**
```
容量大、持久化
适合读多写少
```

**代码示例：**
```java
// 封装RocksDB为简单KV
public class RocksDBClient {
    private RocksDB db;
    
    public void put(String key, String value) {
        db.put(key.getBytes(), value.getBytes());
    }
    
    public String get(String key) {
        byte[] value = db.get(key.getBytes());
        return value != null ? new String(value) : null;
    }
    
    public void delete(String key) {
        db.delete(key.getBytes());
    }
    
    public Map<String, String> rangeScan(String start, String end) {
        Map<String, String> result = new HashMap<>();
        RocksIterator iterator = db.newIterator();
        for (iterator.seek(start.getBytes()); 
             iterator.isValid() && 
             new String(iterator.key()).compareTo(end) <= 0; 
             iterator.next()) {
            result.put(
                new String(iterator.key()),
                new String(iterator.value())
            );
        }
        return result;
    }
}
```

---

*更多RocksDB面试题答案*
