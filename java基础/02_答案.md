# Java基础面试题答案

## 1. Java和C++的区别？

**题目：**
Java和C++有什么区别？

**答案：**
| 特性 | Java | C++ |
|------|------|-----|
| **内存管理** | 自动GC，手动不需要 | 手动管理（new/delete） |
| **指针** | 没有指针，只有引用 | 有指针，支持指针运算 |
| **多重继承** | 不支持（用接口实现） | 支持多重继承 |
| **运算符重载** | 不支持 | 支持 |
| **预处理** | 没有 | 有（#include, #define） |
| **类加载** | 类加载器 | 直接链接 |
| **平台性** | 一次编译，到处运行 | 依赖平台，需重新编译 |
| **默认传参** | 值传递（对象传递引用） | 值传递或引用传递 |

---

## 2. JDK和JRE的区别？

**题目：**
JDK和JRE分别是什么？有什么区别？

**答案：**
- **JRE（Java Runtime Environment）**：Java运行时环境
  - 包含JVM和Java核心类库
  - 只能运行Java程序，不能编译

- **JDK（Java Development Kit）**：Java开发工具包
  - 包含JRE + 开发工具（javac、jar、jdb等）
  - 既能开发也能运行Java程序

**关系图：**
```
JDK = JRE + 开发工具
JRE = JVM + 核心类库
```

---

## 3. ==和equals()的区别？

**题目：**
==和equals()有什么区别？

**答案：**
| 特性 | == | equals() |
|------|-----|----------|
| **作用** | 比较值是否相等 | 比较对象内容是否相等 |
| **基本类型** | 比较值 | 不适用 |
| **引用类型** | 比较引用地址 | 默认比较地址，可重写 |
| **可重写** | 不可重写 | 可以重写（如String、Integer） |

**示例：**
```java
String s1 = new String("hello");
String s2 = "hello";
String s3 = new String("hello");

// == 比较
System.out.println(s1 == s2);      // false（地址不同）
System.out.println(s1 == s3);      // false（地址不同）

// equals() 比较
System.out.println(s1.equals(s2)); // true（String重写了equals）
System.out.println(s1.equals(s3)); // true
```

**重要结论：**
- String的==比较地址，equals比较内容
- 包装类（Integer、Long等）的equals比较值

---

## 4. hashCode()和equals()的关系？

**题目：**
hashCode()和equals()有什么关系？

**答案：**
**核心规则：**
1. 如果两个对象**equals()返回true**，则它们的**hashCode()必须相同**
2. 如果两个对象**hashCode()相同**，equals()**不一定返回true**（哈希冲突）

**为什么需要这个规则？**
- HashMap、HashSet等基于哈希的集合，先比较hashCode再比较equals
- 保证哈希集合的正确性

**示例：**
```java
// 违反规则的反例
public class BadHash {
    private int id;
    
    @Override
    public boolean equals(Object o) {
        return this.id == ((BadHash)o).id;
    }
    
    // 错误：没有重写hashCode()
    // 导致相同id的对象hashCode不同
}
```

**正确做法：**
```java
@Override
public boolean equals(Object o) {
    if (this == o) return true;
    if (o == null || getClass() != o.getClass()) return false;
    Person person = (Person) o;
    return Objects.equals(id, person.id);
}

@Override
public int hashCode() {
    return Objects.hash(id);
}
```

---

## 5. String、StringBuilder、StringBuffer的区别？

**题目：**
String、StringBuilder、StringBuffer有什么区别？

**答案：**
| 特性 | String | StringBuilder | StringBuffer |
|------|--------|---------------|--------------|
| **可变性** | 不可变（final） | 可变 | 可变 |
| **线程安全** | 线程安全（不可变） | 线程不安全 | 线程安全（synchronized） |
| **性能** | 每次修改创建新对象 | 高（直接修改） | 中（synchronized） |
| **使用场景** | 常量字符串 | 单线程字符串操作 | 多线程字符串操作 |

**示例：**
```java
// String - 每次拼接创建新对象
String s = "hello";
s += " world";  // 创建新对象，效率低

// StringBuilder - 推荐单线程使用
StringBuilder sb = new StringBuilder();
sb.append("hello");
sb.append(" world");

// StringBuffer - 多线程使用
StringBuffer sbf = new StringBuffer();
sbf.append("hello");
```

**性能对比：**
```
String:    O(n²)  每次拼接复制整个字符串
StringBuilder: O(n)  直接追加
StringBuffer:  O(n)  但有同步开销
```

---

## 6. 重载和重写的区别？

**题目：**
重载（Overload）和重写（Override）有什么区别？

**答案：**
| 特性 | 重载（Overload） | 重写（Override） |
|------|------------------|------------------|
| **定义** | 同名方法，参数不同 | 子类重写父类方法 |
| **发生位置** | 同一类中 | 父子类之间 |
| **参数列表** | 必须不同（个数、类型、顺序） | 必须相同 |
| **返回值** | 可以不同 | 必须相同（或协变类型） |
| **访问修饰符** | 可以不同 | 不能更严格 |
| **异常** | 可以不同 | 不能抛出更宽泛的异常 |
| **静态方法** | 可以重载 | 不能重写（隐藏） |

**示例：**
```java
// 重载 - 同一类中
public class Calculator {
    public int add(int a, int b) { return a + b; }
    public double add(double a, double b) { return a + b; }
    public int add(int a, int b, int c) { return a + b + c; }
}

// 重写 - 父子类
class Animal {
    public void eat() { System.out.println("Animal eating"); }
}

class Dog extends Animal {
    @Override
    public void eat() { System.out.println("Dog eating"); }
}
```

---

## 7. 接口和抽象类的区别？

**题目：**
接口和抽象类有什么区别？

**答案：**
| 特性 | 接口 | 抽象类 |
|------|------|--------|
| **关键词** | interface | abstract class |
| **方法** | JDK8前全是抽象方法（现在有默认、静态） | 可以有抽象方法和具体方法 |
| **字段** | 默认public static final | 可以有各种修饰符 |
| **继承** | 一个类可以实现多个接口 | 只能继承一个抽象类 |
| **构造函数** | 没有构造函数 | 可以有构造函数 |
| **访问修饰符** | 方法默认public | 可以有各种访问级别 |
| **设计目的** | 定义行为契约 | 复用代码 |

**JDK8+ 新特性：**
```java
// 接口可以有默认方法
interface MyInterface {
    void method1();
    
    default void method2() {
        System.out.println("默认实现");
    }
    
    // 静态方法
    static void staticMethod() {
        System.out.println("静态方法");
    }
}
```

**选择原则：**
- 需要多继承 → 接口
- 需要共享代码 → 抽象类
- 描述"是什么" → 抽象类
- 描述"能做什么" → 接口

---

## 8. 内部类的作用？

**题目：**
Java内部类有什么作用？

**答案：**
**内部类类型：**
1. **成员内部类** - 作为外部类的成员
2. **静态内部类** - 用static修饰
3. **局部内部类** - 定义在方法内部
4. **匿名内部类** - 没有名字的类

**作用：**
```java
// 1. 访问外部类成员
public class Outer {
    private int a = 10;
    
    class Inner {
        public void show() {
            System.out.println(a);  // 直接访问外部类私有成员
        }
    }
}

// 2. 实现多重继承效果
class A { void methodA() {} }
class B { void methodB() {} }

class C implements A, B {
    // 通过内部类实现多重继承
    class InnerA extends A {}
    class InnerB extends B {}
}

// 3. 隐藏实现细节
public class Service {
    private class Helper {
        void help() {}
    }
}

// 4. 匿名内部类 - 事件监听
button.addActionListener(new ActionListener() {
    @Override
    public void actionPerformed(ActionEvent e) {
        // 处理逻辑
    }
});

// 5. 回调实现
interface Callback { void call(); }

class Worker {
    void doWork(Callback callback) {
        callback.call();
    }
}
```

---

## 9. final、finally、finalize的区别？

**题目：**
final、finally、finalize分别是什么？有什么区别？

**答案：**
| 特性 | final | finally | finalize |
|------|-------|---------|----------|
| **性质** | 关键字 | 代码块 | 方法 |
| **作用** | 修饰类、方法、变量 | 异常处理 | 垃圾回收前调用 |
| **执行时机** | 编译时/运行时 | try-catch后 | GC回收对象前 |

**final用法：**
```java
// 1. 修饰类 - 不能被继承
final class FinalClass {}

// 2. 修饰方法 - 不能被重写
class Parent {
    final void method() {}
}

// 3. 修饰变量 - 不能被修改
final int CONST = 100;
final List<String> list = new ArrayList<>();
```

**finally用法：**
```java
try {
    // 可能异常的代码
} catch (Exception e) {
    // 处理异常
} finally {
    // 总是执行的代码（关闭资源）
}
```

**finalize用法（已废弃）：**
```java
// Object类的方法，GC前调用（不推荐使用）
@Override
protected void finalize() throws Throwable {
    // 释放资源
}
```

**注意事项：**
- finally不一定会执行（如System.exit()）
- final不保证线程安全
- finalize已被标记为@Deprecated（Java 9）

---

## 10. Java有几种基本数据类型？

**题目：**
Java有几种基本数据类型？分别是什么？

**答案：**
**8种基本数据类型：**

| 类型 | 大小 | 范围 | 默认值 | 包装类 |
|------|------|------|--------|--------|
| **byte** | 1字节 | -128 ~ 127 | 0 | Byte |
| **short** | 2字节 | -32768 ~ 32767 | 0 | Short |
| **int** | 4字节 | -21亿 ~ 21亿 | 0 | Integer |
| **long** | 8字节 | 很大 | 0L | Long |
| **float** | 4字节 | 浮点数 | 0.0f | Float |
| **double** | 8字节 | 双精度浮点数 | 0.0d | Double |
| **char** | 2字节 | 0 ~ 65535 | '\u0000' | Character |
| **boolean** | 1位 | true/false | false | Boolean |

**注意：**
- boolean的大小在JVM中实现决定，通常是1字节
- long赋值要加L（如：100L）
- float赋值要加f（如：3.14f）
- char用单引号，String用双引号

---

## 11. 自动装箱和拆箱？

**题目：**
什么是自动装箱和拆箱？

**答案：**
**装箱（Boxing）：** 基本类型 → 包装类型
**拆箱（Unboxing）：** 包装类型 → 基本类型

**示例：**
```java
// 装箱
Integer i = 10;  // 自动装箱，实际调用 Integer.valueOf(10)

// 拆箱
int n = i;       // 自动拆箱，实际调用 i.intValue()
```

**底层实现：**
```java
// 装箱
Integer i = Integer.valueOf(10);

// 拆箱
int n = i.intValue();
```

**注意事项：**
```java
// 陷阱1：Integer缓存
Integer a = 127;
Integer b = 127;
System.out.println(a == b);  // true（缓存范围-128~127）

Integer c = 128;
Integer d = 128;
System.out.println(c == d);  // false（超出缓存范围）

// 陷阱2：NullPointerException
Integer num = null;
int n = num;  // 自动拆箱，抛出NPE
```

---

## 12. static关键字的作用？

**题目：**
static关键字有什么作用？

**答案：**
**static可以修饰：** 变量、方法、代码块、内部类

**static变量（类变量）：**
```java
class Person {
    static int count = 0;  // 所有对象共享
    String name;
    
    public Person(String name) {
        this.name = name;
        count++;  // 每次创建对象计数
    }
}

// 访问方式
Person p1 = new Person("张三");
Person p2 = new Person("李四");
System.out.println(Person.count);  // 2（不需要创建对象）
```

**static方法（类方法）：**
```java
class MathUtils {
    public static int add(int a, int b) {
        return a + b;
    }
}

// 调用
int sum = MathUtils.add(1, 2);  // 不需要创建对象
```

**static代码块：**
```java
class StaticBlock {
    static {
        // 类加载时执行，只执行一次
        System.out.println("静态代码块");
    }
    
    {
        // 每次创建对象前执行
        System.out.println("构造代码块");
    }
    
    public StaticBlock() {
        System.out.println("构造函数");
    }
}

// 输出：静态代码块 → 构造代码块 → 构造函数
```

**static特点：**
- 属于类，不属于对象
- 类加载时初始化
- 优先于对象存在
- 所有对象共享同一份数据

---

## 13. this关键字的作用？

**题目：**
this关键字有什么作用？

**答案：**
**this的用途：**

1. **引用当前对象**
```java
class Person {
    String name;
    
    public Person(String name) {
        this.name = name;  // this指向当前对象
    }
    
    public void print() {
        System.out.println(this.name);  // this可省略
    }
}
```

2. **区分成员变量和局部变量**
```java
class Student {
    String name;  // 成员变量
    
    public void setName(String name) {  // 参数是局部变量
        this.name = name;  // 用this区分
    }
}
```

3. **调用其他构造方法**
```java
class Person {
    String name;
    int age;
    
    public Person() {
        this("Unknown");  // 调用另一个构造方法
    }
    
    public Person(String name) {
        this.name = name;
    }
    
    public Person(String name, int age) {
        this(name);  // 必须在第一行
        this.age = age;
    }
}
```

4. **返回当前对象（链式调用）**
```java
class Builder {
    private String name;
    private int age;
    
    public Builder setName(String name) {
        this.name = name;
        return this;  // 返回this
    }
    
    public Builder setAge(int age) {
        this.age = age;
        return this;
    }
}

// 链式调用
Builder builder = new Builder()
    .setName("张三")
    .setAge(20);
```

---

## 14. super关键字的作用？

**题目：**
super关键字有什么作用？

**答案：**
**super的用途：**

1. **访问父类成员**
```java
class Animal {
    String name = "Animal";
    
    public void eat() {
        System.out.println("Animal eating");
    }
}

class Dog extends Animal {
    String name = "Dog";
    
    public void show() {
        System.out.println(name);      // Dog
        System.out.println(this.name); // Dog
        System.out.println(super.name); // Animal（父类的name）
    }
    
    public void eat() {
        System.out.println("Dog eating");
    }
    
    public void callEat() {
        eat();      // Dog的eat()
        this.eat(); // Dog的eat()
        super.eat(); // Animal的eat()
    }
}
```

2. **调用父类构造方法**
```java
class Father {
    String name;
    
    public Father(String name) {
        this.name = name;
    }
}

class Son extends Father {
    int age;
    
    public Son(String name, int age) {
        super(name);  // 调用父类构造方法，必须在第一行
        this.age = age;
    }
}
```

**注意：**
- super()必须写在子类构造方法第一行
- 如果不写super()，默认调用父类的无参构造
- 父类没有无参构造时，必须显式调用super(参数)

---

## 15. 访问修饰符的区别？

**题目：**
Java中有哪些访问修饰符？有什么区别？

**答案：**
**4种访问修饰符：**

| 修饰符 | 同一类 | 同一包 | 不同包子类 | 不同包非子类 |
|--------|--------|--------|------------|--------------|
| **private** | ✅ | ❌ | ❌ | ❌ |
| **默认（无）** | ✅ | ✅ | ❌ | ❌ |
| **protected** | ✅ | ✅ | ✅ | ❌ |
| **public** | ✅ | ✅ | ✅ | ✅ |

**使用场景：**
```java
// private - 只在当前类可见
private int id;

// 默认（包访问） - 同一包可见
int age;

// protected - 同一包+子类可见
protected String name;

// public - 处处可见
public String address;
```

**使用建议：**
- 成员变量 → private，暴露getter/setter
- 方法 → public或protected
- 工具类 → private构造方法 + public static方法
- 常量 → public static final

---

## 16. 异常处理机制？

**题目：**
Java的异常处理机制是什么？

**答案：**
**异常继承结构：**
```
Throwable
├── Error（错误，程序无法处理）
│   ├── OutOfMemoryError
│   ├── StackOverflowError
│   └── ...
└── Exception（异常，可以处理）
    ├── RuntimeException（运行时异常）
    │   ├── NullPointerException
    │   ├── ArrayIndexOutOfBoundsException
    │   └── ...
    ├── IOException（受检异常）
    ├── SQLException
    └── ...
```

**异常处理：**
```java
try {
    // 可能异常的代码
} catch (FileNotFoundException e) {
    // 处理FileNotFoundException
} catch (IOException e) {
    // 处理IOException
} catch (Exception e) {
    // 处理其他异常
} finally {
    // 总是执行的代码（资源释放）
}

// 或者用多重捕获（Java 7+）
try {
    // 可能异常的代码
} catch (IOException | SQLException e) {
    // 同时捕获多个异常
}
```

**throw和throws：**
```java
// throw - 抛出异常对象
public void validate(int age) {
    if (age < 0) {
        throw new IllegalArgumentException("年龄不能为负数");
    }
}

// throws - 声明方法可能抛出的异常
public void readFile(String path) throws IOException {
    FileReader reader = new FileReader(path);
}
```

**自定义异常：**
```java
// 自定义受检异常
class BusinessException extends Exception {
    public BusinessException(String message) {
        super(message);
    }
}

// 自定义运行时异常
class InvalidParamException extends RuntimeException {
    public InvalidParamException(String message) {
        super(message);
    }
}
```

---

## 17. 泛型的作用？

**题目：**
Java泛型有什么用？

**答案：**
**泛型的好处：**
1. 编译时检查类型
2. 消除强制类型转换
3. 提高代码复用性

**使用示例：**
```java
// 泛型类
class Box<T> {
    private T content;
    
    public void set(T content) {
        this.content = content;
    }
    
    public T get() {
        return content;
    }
}

// 泛型方法
public <T> void printArray(T[] array) {
    for (T element : array) {
        System.out.println(element);
    }
}

// 泛型接口
interface Repository<T> {
    void save(T entity);
    T findById(Long id);
}
```

**通配符：**
```java
// ? extends T - 上界通配符（只读）
public void printList(List<? extends Number> list) {
    for (Number num : list) {
        System.out.println(num);
    }
}

// ? super T - 下界通配符（只写）
public void addNumbers(List<? super Integer> list) {
    list.add(100);
}

// ? - 无界通配符
public void printAnyList(List<?> list) {
    // 可以读取，但不知道具体类型
    Object obj = list.get(0);
}
```

**泛型限制：**
```java
// 类型限制
class Calculator<T extends Number> {
    public double add(T a, T b) {
        return a.doubleValue() + b.doubleValue();
    }
}

// 泛型不能用于静态变量
// 泛型不能实例化 T
public T create() {
    return new T();  // 错误
    return (T) new Object();  // 警告但可行
}
```

---

## 18. 反射机制？

**题目：**
什么是Java反射机制？

**答案：**
**反射定义：**
在运行状态中，动态获取类的信息、动态调用对象方法、动态访问属性的机制。

**主要用途：**
- 框架开发（Spring、MyBatis）
- 注解处理器
- 动态代理
- 对象创建和调用

**常用API：**
```java
// 1. 获取Class对象
Class<?> clazz = Class.forName("com.example.Person");
Class<?> clazz = Person.class;
Person person = new Person();
Class<?> clazz = person.getClass();

// 2. 获取构造方法
Constructor<?>[] constructors = clazz.getConstructors();
Constructor<?> constructor = clazz.getConstructor(String.class, int.class);

// 3. 创建对象
Person p = (Person) constructor.newInstance("张三", 20);

// 4. 获取方法
Method[] methods = clazz.getMethods();
Method method = clazz.getMethod("sayHello", String.class);

// 5. 调用方法
method.invoke(p, "World");

// 6. 获取属性
Field[] fields = clazz.getDeclaredFields();
Field nameField = clazz.getDeclaredField("name");
nameField.setAccessible(true);  // 访问私有属性
String name = (String) nameField.get(p);
```

**反射优缺点：**
- **优点：** 灵活、动态
- **缺点：** 性能较差、安全限制、可读性差

---

## 19. 注解的作用？

**题目：**
Java注解有什么用？

**答案：**
**注解定义：**
提供元数据的标签，不直接影响程序运行，但可以被编译器或工具处理。

**常见注解：**
```java
// 内置注解
@Override        // 标记重写方法
@Deprecated     // 标记已过时
@SuppressWarnings("unchecked")  // 抑制警告
@SafeVarargs    // 提示可变参数安全
@FunctionalInterface  // 函数式接口

// 元注解（注解的注解）
@Target(ElementType.METHOD)           // 作用目标
@Retention(RetentionPolicy.RUNTIME)   // 保留策略
@Documented                           // 文档生成
@Inherited                            // 子类继承
```

**自定义注解：**
```java
// 定义注解
@Target({ElementType.METHOD, ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
public @interface MyAnnotation {
    String value() default "";  // 属性
    int priority() default 1;
}

// 使用注解
@MyAnnotation(value = "测试", priority = 5)
public void testMethod() {}

// 解析注解
Method method = MyClass.class.getMethod("testMethod");
MyAnnotation annotation = method.getAnnotation(MyAnnotation.class);
System.out.println(annotation.value());
```

**实际应用：**
- Spring的@Component、@Service、@Autowired
- JUnit的@Test
- Lombok的@Data、@Builder

---

## 20. Java 8 新特性？

**题目：**
Java 8有哪些重要新特性？

**答案：**
**1. Lambda表达式**
```java
// 之前
Collections.sort(list, new Comparator<String>() {
    @Override
    public int compare(String a, String b) {
        return a.compareTo(b);
    }
});

// 之后
list.sort((a, b) -> a.compareTo(b));
list.sort(String::compareTo);
```

**2. Stream API**
```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);

// 过滤
numbers.stream()
    .filter(n -> n % 2 == 0)
    .collect(Collectors.toList());

// 映射
numbers.stream()
    .map(n -> n * 2)
    .collect(Collectors.toList());

// 归约
int sum = numbers.stream()
    .reduce(0, Integer::sum);
```

**3. Optional**
```java
Optional<String> optional = Optional.ofNullable(getName());

// 安全取值
String name = optional.orElse("默认值");
String name = optional.orElseGet(() -> "默认值");
String name = optional.orElseThrow(() -> new RuntimeException());

// 链式调用
optional.map(String::trim).filter(s -> s.length() > 0);
```

**4. 接口默认方法**
```java
interface MyInterface {
    void method1();
    
    default void method2() {
        System.out.println("默认实现");
    }
}
```

**5. 方法引用**
```java
// 构造方法引用
List<String> names = Arrays.asList("a", "b", "c");
names.stream()
    .map(String::toUpperCase)
    .collect(Collectors.toList());
```

**6. Date Time API**
```java
// LocalDate
LocalDate today = LocalDate.now();
LocalDate date = LocalDate.of(2025, 1, 1);

// LocalTime
LocalTime time = LocalTime.now();

// LocalDateTime
LocalDateTime dateTime = LocalDateTime.now();

// Duration / Period
Duration duration = Duration.between(start, end);
Period period = Period.between(startDate, endDate);
```

---

*更多Java基础面试题答案请查看其他分类*
