# 数字货币交易系统面试题

## 1. 订单类型有哪些？

**题目：**
数字货币交易系统中有哪些常见的订单类型？

**答案：**
**订单类型分类：**

| 类型 | 说明 | 示例 |
|------|------|------|
| **限价单** | 指定价格和数量 | 买入 1 BTC @ 50000 USDT |
| **市价单** | 按当前市场价格成交 | 市价买入（按卖一价） |
| **止损单** | 达到触发价后触发 | BTC 跌到 48000 自动卖出 |
| **冰山订单** | 隐藏大单的部分数量 | 显示 1 BTC，实际 100 BTC |
| **GTC** | 取消前一直有效 | 限价单默认 |
| **IOC** | 立即成交否则取消 | 没成交就取消 |
| **FOK** | 全部成交否则取消 | 部分成交也不行 |
| **Post-Only** | 只能做 Maker | 不吃单 |

**限价单示例：**
```java
// 买入 1 BTC，价格 50000 USDT
LimitOrder order = new LimitOrder(
    "BTC/USDT",
    OrderSide.BUY,
    new BigDecimal("50000"),
    new BigDecimal("1"),
    TimeInForce.GTC
);
```

**冰山订单：**
```java
// 总 100 BTC，但每次只显示 1 BTC
IcebergOrder iceberg = new IcebergOrder(
    new BigDecimal("1"),    // 显示 1 BTC
    new BigDecimal("99"),   // 隐藏 99 BTC
    new BigDecimal("50000")
);
```

---

## 2. 订单状态生命周期？

**题目：**
订单在交易系统中有哪些状态？

**答案：**
**订单状态流转：**
```
提交 → 挂单 → 部分成交/完全成交/取消
              ↓
          被拒绝（资金不足等）
              ↓
          过期（IOC/FOK 未成交）
```

**状态列表：**
| 状态 | 说明 |
|------|------|
| **PENDING** | 待处理（刚提交） |
| **OPEN** | 挂单中（已进入订单簿） |
| **PARTIAL_FILLED** | 部分成交 |
| **FILLED** | 完全成交 |
| **CANCELLED** | 用户主动取消 |
| **REJECTED** | 被拒绝 |
| **EXPIRED** | 过期 |

**状态变更事件：**
```java
// WebSocket 推送格式
{
    "e": "orderStatusChange",
    "o": {
        "s": "BTC/USDT",
        "c": "123456",           // 订单ID
        "S": "BUY",
        "X": "PARTIAL_FILLED",   // 订单状态
        "f": "0.5",            // 已成交数量
        "ap": "50000"           // 平均成交价
    }
}
```

---

## 3. 撮合引擎如何工作？

**题目：**
交易系统的撮合引擎是如何工作的？

**答案：**
**撮合核心原则：**
```
1. 价格优先（Price Priority）
   - 买单：价格高的优先
   - 卖单：价格低的优先
   
2. 时间优先（Time Priority）
   - 同价格下，先提交的先成交
   
3. 撮合条件
   - 买单价格 ≥ 卖单价格
```

**撮合流程：**
```
订单簿状态：
┌────────────────────┬────────────────────┐
│ 卖单（Ask）        │ 买单（Bid）        │
├────────────────────┼────────────────────┤
│ 50100 @ 0.5       │ 50000 @ 2.0       │
│ 50200 @ 1.0       │ 49900 @ 1.5       │
└────────────────────┴────────────────────┘

提交买单：价格 50100，数量 1.5

撮合过程：
1. 与 50100@0.5 成交 0.5
2. 与 50200@1.0 成交 1.0
3. 买单完成（1.5 = 0.5 + 1.0）
```

**代码实现：**
```java
public class MatchingEngine {
    
    public List<Trade> match(Order order) {
        List<Trade> trades = new ArrayList<>();
        
        if (order.getSide() == OrderSide.BUY) {
            trades.addAll(matchBuyOrder(order));
        } else {
            trades.addAll(matchSellOrder(order));
        }
        
        return trades;
    }
    
    private List<Trade> matchBuyOrder(Order buyOrder) {
        List<Trade> trades = new ArrayList<>();
        
        while (!buyOrder.isFilled() && hasAvailableSellers(buyOrder)) {
            Order sellOrder = sellBook.peekBestPrice();
            
            // 价格检查
            if (buyOrder.getPrice().compareTo(sellOrder.getPrice()) < 0) {
                break;
            }
            
            // 计算成交数量
            BigDecimal tradeQty = buyOrder.getRemainingQty()
                .min(sellOrder.getRemainingQty());
            
            // 创建成交
            Trade trade = createTrade(buyOrder, sellOrder, tradeQty);
            trades.add(trade);
            
            // 更新订单
            buyOrder.fill(tradeQty);
            sellOrder.fill(tradeQty);
            
            // 移除完全成交的订单
            if (sellOrder.isFilled()) {
                sellBook.remove(sellOrder);
            }
        }
        
        // 未完全成交的挂入订单簿
        if (!buyOrder.isFilled()) {
            buyBook.add(buyOrder);
        }
        
        return trades;
    }
}
```

---

## 4. 仓位管理和强平机制？

**题目：**
数字货币交易系统中的仓位管理和强平机制是如何实现的？

**答案：**
**仓位类型：**
| 类型 | 说明 | 风险 |
|------|------|------|
| **全仓（Cross）** | 所有仓位共享保证金 | 一仓爆仓影响全部 |
| **逐仓（Isolated）** | 每个仓位独立保证金 | 只影响该仓 |

**仓位数据结构：**
```java
public class Position {
    private String symbol;           // BTC/USDT
    private PositionSide side;       // LONG / SHORT
    private BigDecimal quantity;     // 持仓数量
    private BigDecimal entryPrice;  // 开仓均价
    private BigDecimal markPrice;    // 标记价格
    private BigDecimal margin;      // 保证金
    private BigDecimal liquidationPrice;  // 强平价格
}
```

**未实现盈亏计算：**
```java
// 多头盈亏 = (标记价格 - 开仓价) × 数量
// 空头盈亏 = (开仓价 - 标记价格) × 数量

public BigDecimal calculateUnrealizedPnl(Position position) {
    BigDecimal markPrice = getMarkPrice(position.getSymbol());
    
    if (position.getSide() == PositionSide.LONG) {
        return position.getQuantity()
            .multiply(markPrice.subtract(position.getEntryPrice()));
    } else {
        return position.getQuantity()
            .multiply(position.getEntryPrice().subtract(markPrice));
    }
}
```

**强平触发流程：**
```
1. 定时扫描所有仓位（每100ms）
         ↓
2. 计算保证金率 = 保证金 / 合约价值
         ↓
3. 检查是否 < 维持保证金率
         ↓
4. 触发强平
   ├── 撤销所有挂单
   ├── 发送通知
   ├── 强平成交
   └── 结算保证金
```

**强平价格计算（多头）：**
```
强平价 = 开仓价 × (1 - 初始保证金率 + 维持保证金率)

示例：
开仓价 = 50000
杠杆 = 20x
初始保证金率 = 1/20 = 5%
维持保证金率 = 0.5%

强平价 = 50000 × (1 - 5% + 0.5%)
       = 50000 × 95.5%
       = 47750
```

---

## 5. K线数据如何生成？

**题目：**
交易系统的 K 线（蜡烛图）数据是如何生成的？

**答案：**
**K 线结构：**
```
┌─────────────────────────┐
│       上影线（最高价）     │
├─────────────────────────┤
│  ┌─────────────────┐   │
│  │     实体        │   │  开盘价 → 收盘价
│  └─────────────────┘   │
│       下影线（最低价）     │
└─────────────────────────┘

OHLCV：
- Open：开盘价
- High：最高价  
- Low：最低价
- Close：收盘价
- Volume：成交量
```

**K 线聚合：**
```java
public class CandlestickAggregator {
    
    public void processTrade(Trade trade) {
        Candlestick candle = getCurrentCandle(
            trade.getSymbol(),
            trade.getTimestamp()
        );
        
        // 更新 OHLCV
        if (candle.getOpenPrice() == null) {
            candle.setOpenPrice(trade.getPrice());
        }
        
        candle.setHighPrice(max(candle.getHighPrice(), trade.getPrice()));
        candle.setLowPrice(min(candle.getLowPrice(), trade.getPrice()));
        candle.setClosePrice(trade.getPrice());
        candle.setVolume(candle.getVolume().add(trade.getQuantity()));
        
        // 检查是否需要生成新 K 线
        if (isNewCandleStarted(candle, trade.getTimestamp())) {
            saveCandleToHistory(candle);
            createNewCandle(candle.getSymbol(), trade.getTimestamp());
        }
    }
}
```

**K 线周期：**
```java
public enum CandlestickInterval {
    INTERVAL_1m("1m"),   // 1分钟
    INTERVAL_5m("5m"),    // 5分钟
    INTERVAL_15m("15m"),  // 15分钟
    INTERVAL_1h("1h"),    // 1小时
    INTERVAL_4h("4h"),    // 4小时
    INTERVAL_1d("1d"),    // 日线
    INTERVAL_1w("1w");     // 周线
}
```

**WebSocket 推送：**
```javascript
{
    "e": "kline",
    "E": 1234567890,        // 事件时间
    "s": "BTC/USDT",        // 交易对
    "k": {
        "t": 1234567890,    // K线起始时间
        "T": 1234567950,    // K线结束时间
        "o": "50000.00",    // 开盘价
        "h": "50200.00",    // 最高价
        "l": "49900.00",    // 最低价
        "c": "50100.00",    // 收盘价
        "v": "100.5",       // 成交量
        "n": 150           // 成交笔数
    }
}
```

---

## 6. 深度图（OrderBook）如何实现？

**题目：**
交易系统的深度图（OrderBook）是如何实现的？

**答案：**
**深度图结构：**
```
BTC/USDT 深度图
┌─────────────────────┬────────────────────┐
│ 卖盘（Ask）         │ 买盘（Bid）        │
├─────────────────────┼────────────────────┤
│ 价格      数量      │ 价格    数量       │
├─────────────────────┼────────────────────┤
│ 50100    0.50      │ 50050   1.20      │
│ 50200    1.00      │ 50000   2.50      │
│ 50300    0.30      │ 49980   0.80      │
├─────────────────────┼────────────────────┤
│ 卖一价：50100       │ 买一价：50050      │
│ 盘口价差：50 USDT   │                    │
└─────────────────────┴────────────────────┘

盘口价差 = 卖一价 - 买一价 = 50100 - 50050 = 50
```

**数据结构：**
```java
public class OrderBook {
    
    // 卖盘：价格从低到高（TreeMap）
    private final TreeMap<BigDecimal, BigDecimal> asks = 
        new TreeMap<>(Comparator.reverseOrder());
    
    // 买盘：价格从高到低（TreeMap）
    private final TreeMap<BigDecimal, BigDecimal> bids = 
        new TreeMap<>();
    
    // 更新订单簿
    public void updateOrder(Order order) {
        String priceKey = order.getPrice().toPlainString();
        
        if (order.getSide() == OrderSide.SELL) {
            updateLevel(asks, priceKey, order.getRemainingQty());
        } else {
            updateLevel(bids, priceKey, order.getRemainingQty());
        }
    }
    
    // 获取深度
    public OrderBookDepth getDepth(int levels) {
        return new OrderBookDepth(
            asks.entrySet().stream()
                .limit(levels)
                .map(e -> new DepthEntry(e.getKey(), e.getValue()))
                .collect(Collectors.toList()),
            
            bids.entrySet().stream()
                .limit(levels)
                .map(e -> new DepthEntry(e.getKey(), e.getValue()))
                .collect(Collectors.toList())
        );
    }
}
```

---

## 7. 账户体系设计？

**题目：**
数字货币交易系统的账户体系是如何设计的？

**答案：**
**账户类型：**
| 类型 | 说明 | 示例 |
|------|------|------|
| **现金账户** | 现货交易资产 | USDT、BTC 余额 |
| **合约账户** | 合约保证金 | 多空仓位、保证金 |
| **杠杆账户** | 杠杆借贷资产 | 借贷、利息 |
| **OTC 账户** | 场外交易 | 法币充值、提现 |

**账户数据结构：**
```java
public class Account {
    private String accountId;
    private AccountType type;
    private Map<String, BigDecimal> balances;  // 币种 → 余额
    private Map<String, BigDecimal> frozen;    // 冻结金额
    private BigDecimal totalAsset;            // 总资产
    private BigDecimal netAsset;              // 净资产
}

public class AccountBalance {
    private String symbol;           // 币种
    private BigDecimal available;    // 可用余额
    private BigDecimal locked;       // 挂单冻结
    private BigDecimal borrowed;     // 借贷金额
    private BigDecimal interest;     // 借贷利息
    private BigDecimal net;        // 净余额 = available - borrowed
}
```

**划转系统：**
```java
// 账户间划转
public TransferResult transfer(TransferRequest request) {
    // 1. 检查来源账户余额
    BigDecimal fromAvailable = getAvailableBalance(
        request.getFromAccountId(), request.getSymbol());
    
    if (fromAvailable.compareTo(request.getAmount()) < 0) {
        throw new InsufficientBalanceException();
    }
    
    // 2. 冻结来源账户
    freezeBalance(request.getFromAccountId(), 
        request.getSymbol(), request.getAmount());
    
    // 3. 增加目标账户
    addBalance(request.getToAccountId(),
        request.getSymbol(), request.getAmount());
    
    // 4. 解冻来源账户
    unfreezeBalance(request.getFromAccountId(),
        request.getSymbol(), request.getAmount());
    
    // 5. 记录流水
    recordTransferJournal(request);
}
```

---

## 8. 冷热钱包分离？

**题目：**
数字货币交易系统的冷热钱包分离是如何实现的？

**答案：**
**冷热钱包区别：**
```
┌─────────────────────────────────────────────────────────────┐
│                    冷热钱包对比                             │
├────────────────┬─────────────────┬─────────────────────────┤
│     类型       │     热钱包       │      冷钱包            │
├────────────────┼─────────────────┼─────────────────────────┤
│  网络连接      │     在线         │      离线              │
│  私钥位置      │     服务器       │      硬件/纸质         │
│  安全性        │     低          │       高               │
│  便捷性        │     高          │       低               │
│  使用场景      │     日常交易     │       大额存储         │
│  资产占比      │     5%         │       95%              │
└────────────────┴─────────────────┴─────────────────────────┘
```

**钱包架构：**
```
┌─────────────────────────────────────────────────────────────┐
│                    钱包架构                                 │
│                                                              │
│  ┌─────────────────────────────────────────────────┐      │
│  │                  热钱包服务器                         │      │
│  │  ┌─────────┐ ┌─────────┐ ┌─────────┐          │      │
│  │  │ BTC 钱包 │ │ ETH 钱包 │ │ USDT 钱包│          │      │
│  │  └────┬────┘ └────┬────┘ └────┬────┘          │      │
│  └───────┼─────────────┼─────────────┼───────────────────┘      │
│          │             │             │                          │
│          ▼             ▼             ▼                          │
│  ┌─────────────────────────────────────────────────┐      │
│  │              冷钱包存储（离线）                    │      │
│  │  ┌─────────┐ ┌─────────┐ ┌─────────┐          │      │
│  │  │ 硬件钱包 │ │ 纸质钱包 │ │ 多重签名 │          │      │
│  │  └─────────┘ └─────────┘ └─────────┘          │      │
│  └─────────────────────────────────────────────────┘      │
│                                                              │
│  ┌─────────────────────────────────────────────────┐      │
│  │              资金调度系统                          │      │
│  │  1. 自动监控热钱包余额                           │      │
│  │  2. 定期将大额转冷                            │      │
│  │  3. 冷转热需要多人审批                         │      │
│  │  4. 大额提现需人工审核                         │      │
│  └─────────────────────────────────────────────────┘      │
└─────────────────────────────────────────────────────────────┘
```

**资金调度实现：**
```java
public class WalletManager {
    
    // 热钱包阈值（资产占比 5%）
    private static final BigDecimal HOT_WALLET_RATIO = 
        new BigDecimal("0.05");
    
    // 自动归集
    @Scheduled(fixedRate = 60000)  // 每分钟
    public void autoCollect() {
        BigDecimal hotBalance = getHotWalletBalance();
        BigDecimal totalBalance = getTotalBalance();
        
        // 热钱包余额超过阈值，归集到冷钱包
        if (hotBalance.compareTo(
                totalBalance.multiply(HOT_WALLET_RATIO)) > 0) {
            
            BigDecimal transferAmount = hotBalance.subtract(
                totalBalance.multiply(HOT_WALLET_RATIO));
            
            // 需要多人审批
            transferToColdWallet(transferAmount);
        }
    }
    
    // 提现处理
    public void processWithdrawal(WithdrawalRequest request) {
        if (request.getAmount().compareTo(THRESHOLD_LARGE) > 0) {
            // 大额提现需要人工审核
            requireManualApproval(request);
        } else {
            // 小额从热钱包出
            processFromHotWallet(request);
        }
    }
}
```

---

## 9. 系统性能优化？

**题目：**
数字货币交易系统有哪些性能优化手段？

**答案：**
**性能指标：**
```
┌─────────────────────────────────────────────────────────────┐
│                    性能要求                                 │
├────────────────────────────┬────────────────────────────┤
│     指标                 │       要求                     │
├────────────────────────────┼────────────────────────────┤
│  订单延迟（P99）        │       < 100ms               │
│ 撮合引擎吞吐量          │    > 100,000 订单/秒        │
│  系统可用性             │       > 99.99%              │
│  延迟抖动               │       < 10ms                │
└────────────────────────────┴────────────────────────────┘
```

**优化手段：**
```
1. 内存撮合引擎
   - 全内存运行，避免磁盘 I/O
   - 订单簿完全在内存中

2. 高性能数据结构
   - TreeMap 维护订单簿（O(log n)）
   - ConcurrentHashMap 并发安全

3. 无锁设计
   - Disruptor 消息队列
   - CAS 原子操作

4. 批量处理
   - 订单批量聚合
   - 批量写入数据库

5. 异步处理
   - WebSocket 异步推送
   - 消息队列削峰

6. 读写分离
   - 订单簿：写主节点
   - 深度图：读从节点
```

**异步架构：**
```java
// 使用 Disruptor 处理订单
public class OrderProcessor {
    
    private final RingBuffer<OrderEvent> ringBuffer;
    
    public void submitOrder(Order order) {
        long sequence = ringBuffer.next();
        try {
            OrderEvent event = ringBuffer.get(sequence);
            event.setOrder(order);
        } finally {
            ringBuffer.publish(sequence);
        }
    }
    
    // 消费者：撮合引擎
    @Subscribe
    public void onOrder(OrderEvent event) {
        matchingEngine.match(event.getOrder());
    }
}

// 使用 Kafka 异步写入
public class TradeWriter {
    
    private final KafkaTemplate<String, Trade> kafkaTemplate;
    
    @Async
    public void writeTrades(List<Trade> trades) {
        kafkaTemplate.send("trades", JsonUtils.toJson(trades));
    }
}
```

---

## 10. API 设计要点？

**题目：**
数字货币交易系统的 API 设计有哪些要点？

**答案：**
**API 分类：**
| 类型 | 说明 | 示例 |
|------|------|------|
| **REST API** | 通用接口 | 下单、查询 |
| **WebSocket** | 实时推送 | 深度、K线、成交 |
| **FIX API** | 机构接口 | 高频交易 |

**REST API 设计：**
```java
// 订单 REST API
@RestController
@RequestMapping("/api/v1")
public class OrderController {
    
    @PostMapping("/order")
    public Result<OrderResponse> createOrder(
            @Valid @RequestBody OrderRequest request) {
        
        // 限流检查
        rateLimiter.check(request.getApiKey());
        
        // 签名验证
        signatureValidator.validate(request);
        
        // 下单
        Order order = orderService.createOrder(request);
        
        return Result.success(order);
    }
    
    @GetMapping("/order/{orderId}")
    public Result<Order> getOrder(
            @PathVariable String orderId,
            @RequestHeader("X-API-Key") String apiKey) {
        return Result.success(orderService.getOrder(orderId, apiKey));
    }
}

// WebSocket API
// ws://exchange.com/ws
ws.send(JSON.stringify({
    "method": "SUBSCRIBE",
    "params": [
        "btcusdt@trade",      // 成交
        "btcusdt@depth20",    // 深度
        "btcusdt@kline_1m"    // K线
    ],
    "id": 1234
}));
```

**签名验证：**
```java
// HMAC-SHA256 签名
public class SignatureValidator {
    
    public boolean validate(SignedRequest request) {
        // 1. 获取 API Key 对应的 Secret
        String secret = getSecret(request.getApiKey());
        
        // 2. 构建签名字符串
        String signString = buildSignString(
            request.getMethod(),
            request.getPath(),
            request.getTimestamp(),
            request.getBody()
        );
        
        // 3. 计算签名
        String signature = HmacSha256(signString, secret);
        
        // 4. 验证
        return signature.equals(request.getSignature());
    }
}

// 请求签名示例
// POST /api/v1/order
// timestamp: 1234567890
// body: {"symbol":"BTC/USDT","side":"BUY","type":"LIMIT","quantity":"1","price":"50000"}

// 签名字符串：POST\n/api/v1/order\n1234567890\n{"symbol":"BTC/USDT"...}
```

**限流策略：**
```java
// API 限流
public class RateLimiter {
    
    private final Map<String, RateLimitInfo> limits = new ConcurrentHashMap<>();
    
    public void check(String apiKey) {
        RateLimitInfo info = limits.computeIfAbsent(
            apiKey, k -> new RateLimitInfo());
        
        // 检查请求次数
        if (info.getRequestCount() > MAX_REQUESTS_PER_SECOND) {
            throw new RateLimitExceededException();
        }
        
        // 限流响应头
        return new RateLimitResult(
            info.getRemainingRequests(),
            info.getResetTime()
        );
    }
}

// 响应头
// X-RateLimit-Limit: 100
// X-RateLimit-Remaining: 99
// X-RateLimit-Reset: 1234567890
```
