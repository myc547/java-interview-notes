# Netty 零拷贝破坏案例补充

## 哪些操作会破坏 Netty 的零拷贝？

**问题：**
哪些操作会破坏 Netty 的零拷贝特性？

**答案：**
**破坏零拷贝的操作：**

**1. copy() 方法：**
```java
// ❌ 破坏零拷贝：创建新 Buffer，拷贝数据
ByteBuf original = Unpooled.copiedBuffer("Hello World".getBytes());
ByteBuf copied = original.copy();  // 拷贝所有数据

// ❌ 部分拷贝：slice(0, 5).copy()
ByteBuf sliceCopy = original.slice(0, 5).copy();  // 拷贝
```

**2. getBytes() / readBytes()：**
```java
// ❌ 破坏零拷贝：读取数据到新数组
ByteBuf original = Unpooled.copiedBuffer("Hello".getBytes());
byte[] array = new byte[original.readableBytes()];
original.readBytes(array);  // 拷贝到新数组

// ❌ 读取到另一个 Buffer
ByteBuf another = Unpooled.buffer();
original.readBytes(another);  // 拷贝
```

**3. writeBytes() 触发扩容：**
```java
// ❌ 破坏零拷贝：写入数据导致 Buffer 扩展
ByteBuf buf = Unpooled.buffer(4);  // 初始容量 4
buf.writeBytes("Hello World".getBytes());  // 自动扩容，拷贝数据

// ✅ 正确方式：预先分配足够空间
ByteBuf buf = Unpooled.buffer(20);  // 预估大小
buf.writeBytes("Hello World".getBytes());
```

**4. nioBuffer() 多次调用：**
```java
// ❌ 每次调用都创建新 NIO Buffer
ByteBuf original = Unpooled.copiedBuffer("Hello".getBytes());
ByteBuffer nio1 = original.nioBuffer();
ByteBuffer nio2 = original.nioBuffer();  // 每次都拷贝

// ✅ 正确方式：只调用一次
ByteBuffer nio = original.nioBuffer();
```

**5. retainedSlice() 误用导致内存泄漏：**
```java
// ❌ retain() 次数不匹配，导致内存泄漏
ByteBuf original = Unpooled.copiedBuffer("Hello World".getBytes());
original.retain();  // 引用计数 +1
original.retain();  // 引用计数 +1
original.release();  // 引用计数 -1（仍然是 1）
// original 永远不会释放，内存泄漏

// ✅ 正确方式：使用 retainedSlice()
ByteBuf retainedSlice = original.retainedSlice(0, 5);
```

**6. CompositeBuffer 组件修改后访问：**
```java
// ❌ removeComponent 后访问
CompositeByteBuf composite = Unpooled.compositeBuffer();
ByteBuf buf1 = Unpooled.copiedBuffer("Hello".getBytes());
ByteBuf buf2 = Unpooled.copiedBuffer(" World".getBytes());
composite.addComponents(true, buf1, buf2);
composite.removeComponent(0);
buf1.setByte(0, 'X');  // 野指针访问

// ✅ 正确方式：先获取再修改
Component component = composite.component(0);
ByteBuf componentBuf = component.content();
componentBuf.setByte(0, 'X');
```

**7. toByteBuffer() 转换：**
```java
// ❌ toByteBuffer() 创建新 Buffer
ByteBuf original = Unpooled.copiedBuffer("Hello".getBytes());
ByteBuffer buffer = original.toByteBuffer();  // 拷贝

// ✅ 正确方式：使用 nioBuffer()
ByteBuffer nio = original.nioBuffer();
```

**8. 错误使用 indexOf()：**
```java
// ❌ 在大数据量时性能差
ByteBuf original = Unpooled.copiedBuffer("Hello World".getBytes());
int index = original.indexOf(0, original.readableBytes(), (byte) 'W');  // 遍历

// ✅ 正确方式：使用 forEachByte()
original.forEachByte(0, original.readableBytes(), byteProcessor -> {
    if (byteProcessor.value() == 'W') {
        return false;  // 停止遍历
    }
    return true;
});
```

**9. unsafe.getBytes() 误用：**
```java
// ❌ 直接访问内部数组（破坏封装）
ByteBuf original = Unpooled.copiedBuffer("Hello".getBytes());
byte[] array = new byte[original.readableBytes()];
// 通过 Unsafe 直接访问底层数组，可能破坏零拷贝

// ✅ 正确方式：使用官方 API
byte[] array = new byte[original.readableBytes()];
original.getBytes(0, array);
```

**10. release() 次数不匹配：**
```java
// ❌ release() 次数不匹配
ByteBuf buf = Unpooled.copiedBuffer("Hello");
buf.retain();
buf.retain();
buf.release();  // 引用计数仍为 1，内存泄漏

// ✅ 正确方式：try-finally 确保释放
ByteBuf buf = Unpooled.copiedBuffer("Hello");
try {
    // 使用 buf
} finally {
    buf.release();  // 确保释放
}
```

---

## 零拷贝最佳实践

**正确做法：**
```java
public class ZeroCopyBestPractice {
    
    // 1. 使用 FileRegion 传输文件（零拷贝）
    public void goodExample(Channel channel, File file) throws IOException {
        FileRegion region = new DefaultFileRegion(
            file.getChannel(), 0, file.length());
        channel.writeAndFlush(region);
    }
    
    // 2. 使用 CompositeByteBuf（零拷贝）
    public void goodExample2(ByteBuf buf1, ByteBuf buf2) {
        CompositeByteBuf composite = Unpooled.compositeBuffer();
        composite.addComponents(true, buf1, buf2);
        // 处理 composite（使用后记得 release）
    }
    
    // 3. 使用 slice()（零拷贝）
    public void goodExample3(ByteBuf original) {
        ByteBuf slice = original.slice(0, 
            Math.min(100, original.readableBytes()));
        // 处理 slice（注意：slice 共享原 Buffer 的生命周期）
    }
}
```

**内存泄漏检测：**
```bash
# JVM 参数开启泄漏检测
-Dio.netty.leakDetectionLevel=ADVANCED

# 级别：
# DISABLED - 禁用
# SIMPLE   - 简单检测
# ADVANCED - 高级检测（推荐开发环境）
# PARANOID - 激进检测（影响性能）
```

---

## 常见错误总结

| 操作 | 破坏零拷贝 | 替代方案 |
|------|-----------|---------|
| copy() | ✅ | slice() / retainedSlice() |
| readBytes(array) | ✅ | getBytes() 少量数据 |
| writeBytes() 扩容 | ✅ | 预先分配足够空间 |
| nioBuffer() 多次 | ✅ | 只调用一次 |
| retain() 不配对 | ⚠️ | try-finally 配对释放 |
| toByteBuffer() | ✅ | nioBuffer() |
