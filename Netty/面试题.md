# Netty 面试题

## 1. 什么是 Netty？它有什么特点？

**题目：**
Netty 是什么？它有哪些核心特点？

**答案：**
**Netty 概述：**
Netty 是一个基于 NIO 的高性能网络通信框架，用于快速开发可维护的高协议服务器和客户端。

**核心特点：**
- 高吞吐量：基于 NIO，相比 BIO 性能提升明显
- 低延迟：减少不必要的内存拷贝
- 高可靠性：完善的异常处理和重连机制
- 灵活扩展：支持多种协议（HTTP、WebSocket、TCP、UDP）
- 易用性：简洁的 API，降低网络编程复杂度

**核心组件：**
```java
// Channel：网络套接字的抽象
Channel channel = ...;

// EventLoop：处理 Channel 的 I/O 事件，单线程执行
EventLoopGroup group = new NioEventLoopGroup();

// ChannelFuture：异步操作结果
ChannelFuture future = channel.writeAndFlush(data);

// ChannelHandler：处理 I/O 事件
public class MyHandler extends ChannelInboundHandlerAdapter {
    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) {
        // 处理接收的数据
    }
}

// ChannelPipeline：责任链模式，管理 ChannelHandler
ChannelPipeline pipeline = channel.pipeline();
```

---

## 2. BIO、NIO、AIO 的区别？

**题目：**
请详细说明 BIO、NIO、AIO 的区别。

**答案：**
**三种 I/O 模型对比：**
```
┌────────────────┬────────────────┬────────────────┬────────────────┐
│      特性      │     BIO       │      NIO       │      AIO       │
├────────────────┼────────────────┼────────────────┼────────────────┤
│  同步/异步    │     同步       │      同步       │      异步      │
│  阻塞/非阻塞   │     阻塞       │     非阻塞      │      非阻塞     │
│  线程模型     │   1:1         │    1:N         │    1:1         │
│  复杂度       │     简单       │     复杂        │      复杂      │
│  适用场景     │   连接数少     │   连接数多      │    高并发       │
│  JDK 版本     │    1.0+       │     1.4+        │     1.7+       │
└────────────────┴────────────────┴────────────────┴────────────────┘
```

**BIO（Blocking I/O）：**
```java
// 传统 BIO：每个连接一个线程
try (ServerSocket server = new ServerSocket(8080)) {
    while (true) {
        Socket client = server.accept();  // 阻塞等待连接
        new Thread(() -> {
            try {
                InputStream in = client.getInputStream();
                // 处理请求
            } catch (IOException e) {
                e.printStackTrace();
            }
        }).start();
    }
}
```

**NIO（Non-blocking I/O）：**
```java
// NIO：多路复用
Selector selector = Selector.open();
ServerSocketChannel serverChannel = ServerSocketChannel.open();
serverChannel.configureBlocking(false);
serverChannel.register(selector, SelectionKey.OP_ACCEPT);

while (true) {
    selector.select();
    for (SelectionKey key : selector.selectedKeys()) {
        if (key.isAcceptable()) {
            // 处理连接
        } else if (key.isReadable()) {
            // 处理读取
        }
        keys.remove(key);
    }
}
```

**AIO（Asynchronous I/O）：**
```java
// AIO：异步非阻塞
AsynchronousServerSocketChannel server = 
    AsynchronousServerSocketChannel.open().bind(8080);

server.accept(null, new CompletionHandler<AsynchronousSocketChannel, Void>() {
    @Override
    public void completed(AsynchronousSocketChannel result, Void attachment) {
        // 处理连接
        server.accept(null, this);
    }
});
```

---

## 3. Netty 线程模型？

**题目：**
Netty 的线程模型是怎样的？

**答案：**
**Boss/Worker 线程分工：**
```
Boss EventLoop：接受连接，将 Channel 注册到 Worker
Worker EventLoop：处理读写事件，执行 ChannelHandler
```

**配置示例：**
```java
// 单线程模型
EventLoopGroup group = new NioEventLoopGroup(1);
bootstrap.group(group);

// 多线程模型
EventLoopGroup group = new NioEventLoopGroup();  // 默认 CPU*2

// 主从模型
EventLoopGroup bossGroup = new NioEventLoopGroup(1);
EventLoopGroup workerGroup = new NioEventLoopGroup();
bootstrap.group(bossGroup, workerGroup);
```

**Task Queue：**
```java
// 提交普通任务
channel.eventLoop().execute(() -> {});

// 提交定时任务
channel.eventLoop().schedule(() -> {}, 5, TimeUnit.SECONDS);
channel.eventLoop().scheduleAtFixedRate(() -> {}, 1, 5, TimeUnit.SECONDS);
```

---

## 4. Netty 零拷贝？

**题目：**
Netty 的零拷贝（Zero-Copy）是如何实现的？

**答案：**
**零拷贝实现：**
- **CompositeByteBuf**：合并多个 Buffer，不拷贝数据
- **slice() / duplicate()**：共享底层数据
- **FileRegion**：直接在操作系统层面传输文件

**示例：**
```java
// 传统方式：多次拷贝
ByteBuf combined = Unpooled.copiedBuffer(buf1, buf2);

// Netty 零拷贝：不拷贝
CompositeByteBuf composite = Unpooled.compositeBuffer();
composite.addComponents(true, buf1, buf2);

// FileRegion 文件传输
FileRegion region = new DefaultFileRegion(
    file.getChannel(), 0, file.length());
channel.writeAndFlush(region);  // 直接在内核空间传输
```

---

## 5. Netty 心跳机制？

**题目：**
Netty 如何实现心跳机制？

**答案：**
**IdleStateHandler 实现：**
```java
// 配置心跳检测
ch.pipeline().addLast(
    new IdleStateHandler(60, 45, 0));  // 读超时60，写超时45

public class HeartbeatHandler extends ChannelInboundHandlerAdapter {
    
    @Override
    public void userEventTriggered(ChannelHandlerContext ctx, Object evt) {
        if (evt instanceof IdleStateEvent) {
            IdleStateEvent event = (IdleStateEvent) evt;
            
            switch (event.state()) {
                case READER_IDLE:
                    ctx.close();  // 读空闲，关闭连接
                    break;
                case WRITER_IDLE:
                    ctx.writeAndFlush("PING\n");  // 写空闲，发送心跳
                    break;
            }
        }
    }
}
```

---

## 6. Netty 编解码机制？

**题目：**
Netty 的编解码机制是怎样的？

**答案：**
**编解码器分类：**
```
ByteToMessageDecoder / MessageToByteEncoder  // 基本编解码
LengthFieldPrepender / LengthFieldBasedFrameDecoder  // 长度帧编解码
```

**解决 TCP 粘包/拆包：**
```java
// 方案1：固定长度
new FixedLengthFrameDecoder(1024);

// 方案2：行分隔符
new LineBasedFrameDecoder(1024);

// 方案3：自定义分隔符
new DelimiterBasedFrameDecoder(1024,
    Unpooled.copiedBuffer("$$".getBytes()));

// 方案4：LengthFieldPrepender + LengthFieldBasedFrameDecoder
ch.pipeline().addLast(new LengthFieldPrepender(4));
ch.pipeline().addLast(new LengthFieldBasedFrameDecoder(65535, 0, 4, 0, 4));
```

**自定义协议编解码：**
```java
// 编码器
public class MyEncoder extends MessageToByteEncoder<MyProtocol> {
    @Override
    protected void encode(ChannelHandlerContext ctx, 
                        MyProtocol msg, ByteBuf out) {
        out.writeInt(msg.getMagic());
        out.writeInt(msg.getLength());
        out.writeBytes(msg.getData());
    }
}

// 解码器
public class MyDecoder extends ByteToMessageDecoder {
    @Override
    protected void decode(ChannelHandlerContext ctx, 
                         ByteBuf in, List<Object> out) {
        if (in.readableBytes() < 8) return;
        
        int length = in.readInt();
        if (in.readableBytes() < length) {
            in.readerIndex(in.readerIndex() - 8);
            return;
        }
        
        byte[] data = new byte[length];
        in.readBytes(data);
        out.add(new MyProtocol(data));
    }
}
```

---

## 7. Netty 高并发性能优化？

**题目：**
Netty 有哪些高并发性能优化策略？

**答案：**
**优化策略：**
```java
// 1. 使用对象池
Recycler<User> recycler = new Recycler<User>() {
    @Override
    protected User newObject(Handle<User> handle) {
        return new User(handle);
    }
};

// 2. 使用直接内存
ByteBuf buf = Unpooled.directBuffer(1024);

// 3. 合理的线程模型
EventLoopGroup workerGroup = new NioEventLoopGroup(
    Runtime.getRuntime().availableProcessors() * 2);

// 4. 参数调优
bootstrap.childOption(ChannelOption.SO_KEEPALIVE, true);
bootstrap.childOption(ChannelOption.TCP_NODELAY, true);
bootstrap.childOption(ChannelOption.SO_SNDBUF, 64 * 1024);
bootstrap.childOption(ChannelOption.SO_RCVBUF, 64 * 1024);

// 5. 使用 Epoll（Linux）
EventLoopGroup epollGroup = new EpollEventLoopGroup();
```

---

## 8. Netty 断线重连机制？

**题目：**
Netty 如何实现断线重连？

**答案：**
**断线检测和重连：**
```java
public class NettyClient {
    
    private static final int RECONNECT_DELAY = 5;
    
    public void connect() {
        EventLoopGroup group = new NioEventLoopGroup();
        Bootstrap bootstrap = new Bootstrap();
        bootstrap.group(group)
                 .channel(NioSocketChannel.class)
                 .handler(new ClientHandler());
        
        doConnect(bootstrap);
    }
    
    private void doConnect(Bootstrap bootstrap) {
        ChannelFuture future = bootstrap.connect(HOST, PORT);
        
        future.addListener((ChannelFutureListener) f -> {
            if (!f.isSuccess()) {
                System.out.println("连接失败，5秒后重试");
                f.channel().eventLoop().schedule(
                    () -> doConnect(bootstrap), 
                    RECONNECT_DELAY, TimeUnit.SECONDS);
            } else {
                System.out.println("连接成功");
            }
        });
    }
}

public class ClientHandler extends ChannelInboundHandlerAdapter {
    
    @Override
    public void channelInactive(ChannelHandlerContext ctx) {
        System.out.println("断线，重连中...");
        ctx.channel().eventLoop().schedule(
            () -> connectBootstrap(), 
            5, TimeUnit.SECONDS);
    }
}
```

---

## 9. Netty 与 Tomcat 的区别？

**题目：**
Netty 与 Tomcat 有什么区别？

**答案：**
**对比：**
```
┌──────────────────┬─────────────────────┬─────────────────────┐
│       特性       │       Netty         │       Tomcat        │
├──────────────────┼─────────────────────┼─────────────────────┤
│  协议支持       │   TCP/UDP 自定义协议  │   HTTP/HTTPS        │
│  线程模型       │   NIO（单线程/多线程） │   BIO/NIO          │
│  使用场景       │   底层网络通信       │   Web 容器          │
│  性能           │   高（定制性强）      │   高（针对 HTTP）    │
│  灵活性         │   高                │   低                │
│  开发复杂度     │   高                │   低                │
└──────────────────┴─────────────────────┴─────────────────────┘
```

**选择建议：**
- 需要自定义协议 → Netty
- 开发 Web 应用 → Tomcat
- 高性能服务 → Netty

---

## 10. Netty WebSocket 应用？

**题目：**
如何使用 Netty 实现 WebSocket 通信？

**答案：**
**WebSocket 服务端：**
```java
public class WebSocketServer {
    
    public static void main(String[] args) {
        EventLoopGroup bossGroup = new NioEventLoopGroup();
        EventLoopGroup workerGroup = new NioEventLoopGroup();
        
        try {
            ServerBootstrap bootstrap = new ServerBootstrap();
            bootstrap.group(bossGroup, workerGroup)
                     .channel(NioServerSocketChannel.class)
                     .childHandler(new ChannelInitializer<SocketChannel>() {
                         @Override
                         protected void initChannel(SocketChannel ch) {
                             ch.pipeline()
                                .addLast(new HttpServerCodec())
                                .addLast(new HttpObjectAggregator(65536))
                                .addLast(new WebSocketServerProtocolHandler("/ws"))
                                .addLast(new WebSocketHandler());
                         }
                     });
            
            Channel channel = bootstrap.bind(8080).sync().channel();
            channel.closeFuture().sync();
            
        } finally {
            bossGroup.shutdownGracefully();
            workerGroup.shutdownGracefully();
        }
    }
}

public class WebSocketHandler extends 
        SimpleChannelInboundHandler<TextWebSocketFrame> {
    
    @Override
    protected void channelRead0(ChannelHandlerContext ctx, 
                                TextWebSocketFrame msg) {
        String text = msg.text();
        System.out.println("收到消息：" + text);
        
        // 广播消息
        ctx.writeAndFlush(new TextWebSocketFrame("回复：" + text));
    }
    
    @Override
    public void handlerAdded(ChannelHandlerContext ctx) {
        System.out.println("客户端连接：" + ctx.channel().id());
    }
}
```

**客户端连接：**
```javascript
// JavaScript WebSocket 客户端
var ws = new WebSocket("ws://localhost:8080/ws");

ws.onopen = function() {
    console.log("连接成功");
    ws.send("Hello Netty!");
};

ws.onmessage = function(event) {
    console.log("收到消息：" + event.data);
};
```
