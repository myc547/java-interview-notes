# Redis面试题答案

## 1. Redis有哪些数据类型？

**题目：**
Redis支持哪些数据类型？

**答案：**
**5种基本数据类型：**

| 类型 | 结构 | 特点 | 使用场景 |
|------|------|------|----------|
| **String** | 字符串/数字/二进制 | 最大512MB | 缓存、计数器 |
| **Hash** | 键值对集合 | 适合对象 | 用户信息、商品信息 |
| **List** | 双向链表 | 有序、可重复 | 消息队列、最新列表 |
| **Set** | 无序集合 | 不重复、无序 | 标签、好友关系 |
| **ZSet** | 有序集合 | 不重复、有分数 | 排行榜、优先级队列 |

**3种特殊类型：**

| 类型 | 结构 | 使用场景 |
|------|------|----------|
| **Bitmap** | 位图 | 签到、用户统计 |
| **HyperLogLog** | 基数估算 | UV统计 |
| **Geospatial** | 地理位置 | 附近的人 |

**底层实现：**
```
String：SDS（Simple Dynamic String）
Hash：ziplist + hashtable
List：quicklist
Set：intset + hashtable
ZSet：ziplist + skiplist
```

**常用命令：**
```bash
# String
SET key value
GET key
INCR key
MGET key1 key2

# Hash
HSET key field value
HGET key field
HGETALL key

# List
LPUSH key v1 v2
RPOP key
LRANGE key 0 -1

# Set
SADD key v1 v2
SMEMBERS key
SINTER key1 key2

# ZSet
ZADD key score v1
ZRANGE key 0 -1 WITHSCORES
ZREVRANGE key 0 9
```

---

## 2. Redis和Memcached的区别？

**题目：**
Redis和Memcached有什么区别？

**答案：**
| 特性 | Redis | Memcached |
|------|-------|-----------|
| **数据类型** | 丰富（5+3种） | 单一（String） |
| **持久化** | 支持（RDB+AOF） | 不支持 |
| **集群** | 原生支持 | 需客户端实现 |
| **线程模型** | 单线程+多IO | 多线程 |
| **内存管理** | 自己实现 | slab allocator |
| **数据结构** | 多种数据结构 | 简单字符串 |
| **主从复制** | 支持 | 不支持 |
| **事务** | 支持（弱） | 不支持 |
| **Lua脚本** | 支持 | 不支持 |

**选择建议：**
```
Redis：需要复杂数据结构、持久化、主从复制
Memcached：纯缓存、追求高性能、简单kv
```

---

## 3. Redis持久化机制？

**题目：**
Redis有哪些持久化机制？

**答案：**
**RDB（Redis Database）：**
```
定时生成数据快照
默认开启
生成dump.rdb文件
```

**RDB配置：**
```bash
# 触发条件
save 900 1      # 900秒至少1个key变化
save 300 10     # 300秒至少10个key变化
save 60 10000   # 60秒至少10000个key变化

# 禁止RDB
save ""

# 后台生成
rdbcompression yes
dbfilename dump.rdb
```

**RDB优缺点：**
- ✅ 恢复速度快
- ✅ 文件紧凑
- ✅ 适合备份
- ❌ 可能丢失部分数据
- ❌ fork子进程有开销

**AOF（Append Only File）：**
```
记录所有写命令
默认不开启
生成aof文件
```

**AOF配置：**
```bash
appendonly yes
appendfilename "appendonly.aof"

# 同步策略
appendfsync always     # 每个命令都同步（最安全，最慢）
appendfsync everysec   # 每秒同步（默认）
appendfsync no         # 由系统决定（最快，可能丢数据）

# AOF重写
auto-aof-rewrite-percentage 100
auto-aof-rewrite-min-size 64mb
```

**AOF优缺点：**
- ✅ 数据更完整
- ✅ 可读性好
- ❌ 文件较大
- ❌ 恢复速度慢

**混合持久化（4.0+）：**
```bash
aof-use-rdb-preamble yes
```

**恢复策略：**
```
1. AOF开启 → 优先用AOF恢复
2. AOF关闭 → 用RDB恢复
3. AOF损坏 → redis-check-aof修复
```

---

## 4. Redis过期策略？

**题目：**
Redis过期键如何删除？

**答案：**
**三种过期策略：**

**1. 定时删除**
- 设置定时器，过期立即删除
- CPU消耗高

**2. 惰性删除**
- 访问时检查，过期则删除
- 内存消耗高

**3. 定期删除**
- 定期扫描过期键
- 平衡CPU和内存

**Redis实现：**
```
Redis使用惰性删除 + 定期删除
```

**惰性删除：**
```c
// 访问key时检查
if (expired) {
    delete(key);
}
```

**定期删除：**
```c
// serverCron定时任务
// 随机扫描部分key
// 删除过期的key
// 控制时间在25ms内
```

**关注点：**
- 不会扫描所有key
- 依赖内存淘汰策略
- 可以手动触发

**命令：**
```bash
# 查看过期时间
TTL key

# 设置过期时间
EXPIRE key 60
SETEX key 60 value

# 移除过期时间
PERSIST key
```

---

## 5. Redis淘汰策略？

**题目：**
Redis内存淘汰策略有哪些？

**答案：**
**8种淘汰策略：**

| 策略 | 说明 |
|------|------|
| **noeviction** | 不淘汰，返回错误（默认） |
| **volatile-lru** | LRU淘汰有过期时间的key |
| **allkeys-lru** | LRU淘汰所有key |
| **volatile-ttl** | 淘汰TTL最短的key |
| **volatile-random** | 随机淘汰有过期时间的key |
| **allkeys-random** | 随机淘汰所有key |
| **volatile-lfu** | LFU淘汰有过期时间的key（4.0+） |
| **allkeys-lfu** | LFU淘汰所有key（4.0+） |

**配置方式：**
```bash
maxmemory 1gb
maxmemory-policy allkeys-lru
```

**LRU算法：**
```
Least Recently Used
最近最少使用
```

**LFU算法：**
```
Least Frequently Used
最近最少频率使用
```

**近似LRU：**
```
Redis使用近似LRU算法
采样N个key，选择最优
性能更好
```

**选择建议：**
```
缓存场景：allkeys-lru
会话存储：volatile-lru
```

---

## 6. Redis主从复制原理？

**题目：**
Redis主从复制原理是什么？

**答案：**
**主从复制架构：**
```
┌──────────┐         ┌──────────┐
│  Master  │ ──────> │  Slave   │
│  (主库)  │ 复制    │  (从库)  │
└──────────┘         └──────────┘
```

**复制流程：**
```
1. Slave连接Master
2. Master返回PONG
3. Master执行BGSAVE生成RDB
4. Master发送RDB到Slave
5. Slave加载RDB
6. Master发送缓存命令
7. Slave执行缓存命令
8. 保持长连接，实时同步
```

**全量复制：**
```
1. Slave发送PSYNC ? -1
2. Master执行BGSAVE
3. Master发送RDB
4. Master发送缓存命令
```

**增量复制：**
```
1. Slave发送PSYNC runid offset
2. Master返回CONTINUE
3. Master发送差距的命令
```

**配置主从：**
```bash
# 从库配置
replicaof masterip masterport
# 或
slaveof masterip masterport

# 只读
replica-read-only yes

# 认证
masterauth password
```

**复制原理：**
```
Replication ID：复制ID（数据集标识）
Offset：偏移量（同步位置）
```

**常见问题：**
- 网络延迟
- Master压力
- 数据不一致

---

## 7. Redis集群方案？

**题目：**
Redis有哪些集群方案？

**答案：**
**1. 主从复制**
- 一主多从
- 读写分离
- 自动故障转移（需Sentinel）

**2. Redis Sentinel（哨兵）**
```
┌──────────┐
│  Sentinel│  ← 监控、选举、故障转移
└────┬─────┘
     │
┌────┴─────┐
│ Master   │
└────┬─────┘
     │
┌────┴─────┐
│ Slave1   │
│ Slave2   │
└──────────┘
```

**Sentinel配置：**
```bash
sentinel monitor mymaster 127.0.0.1 6379 2
sentinel auth-pass mymaster password
sentinel down-after-milliseconds mymaster 30000
```

**3. Redis Cluster**
- 数据分片（16384个槽）
- 自动故障转移
- Gossip协议通信

**Cluster架构：**
```
┌─────────────────────────────────────┐
│           客户端路由                  │
└──────────────────┬──────────────────┘
                   │
    ┌──────────────┼──────────────┐
    │              │              │
┌───┴───┐    ┌─────┴─────┐   ┌────┴───┐
│Node 1  │    │ Node 2   │   │Node 3  │
│0-5460  │    │5461-10922│   │10923-16383
└────┬───┘    └─────┬─────┘   └────┬───┘
     │              │              │
┌────┴─────┐  ┌─────┴─────┐  ┌────┴─────┐
│Slave1-1  │  │Slave2-1   │  │Slave3-1  │
└──────────┘  └──────────┘  └──────────┘
```

**Cluster配置：**
```bash
cluster-enabled yes
cluster-config-file nodes-6379.conf
cluster-node-timeout 15000

# 数据分片
redis-cli --cluster create 127.0.0.1:6379 127.0.0.1:6380 ...
```

**方案对比：**
| 特性 | 主从+Sentinel | Cluster |
|------|---------------|---------|
| 数据分片 | 否 | 是 |
| 扩展性 | 有限 | 好 |
| 复杂度 | 中 | 高 |
| 客户端支持 | 广泛 | 需要智能客户端 |

---

## 8. 什么是缓存穿透、击穿、雪崩？

**题目：**
缓存穿透、击穿、雪崩是什么？

**答案：**
**1. 缓存穿透**
```
定义：查询不存在的数据，穿透缓存到数据库
问题：大量请求打垮数据库
原因：恶意攻击、代码bug

解决：
1. 缓存空值
   SET key null WITH_EXPIRE
2. 布隆过滤器
   Bloom Filter判断key是否存在
3. 接口校验
   参数校验、限流
```

**2. 缓存击穿**
```
定义：热点key过期，瞬间大量请求到数据库
问题：数据库压力骤增
原因：热点数据过期瞬间

解决：
1. 永不过期
   逻辑过期（定时更新）
2. 互斥锁
   SETNX key value WITH_EXPIRE
   只有一个请求查DB
3. 分布式锁
   Redisson Lock
```

**3. 缓存雪崩**
```
定义：大量缓存同时失效，请求打到数据库
问题：数据库压力骤增
原因：大量key同时过期

解决：
1. 随机过期时间
   EXPIRE key random(60, 120)
2. 永不过期
3. 多级缓存
   L1 + L2 + DB
4. 限流降级
   Hystrix/Sentinel
```

**应对策略：**
```
┌─────────────────────────────────────────────────┐
│                   缓存架构                        │
│                                                 │
│  请求 → 限流 → 布隆过滤 → 缓存 → 锁 → 数据库    │
│                                                 │
│  雪崩 → 多级缓存                                 │
│  击穿 → 互斥锁                                   │
│  穿透 → 布隆过滤                                 │
└─────────────────────────────────────────────────┘
```

---

## 9. 如何保证缓存一致性？

**题目：**
如何保证缓存和数据库一致性？

**答案：**
**Cache Aside（旁路缓存）：**
```
读取：
1. 查缓存
2. 缓存没有查DB
3. 写缓存

更新：
1. 删缓存
2. 更新DB
```

**问题与解决：**

**1. 并发问题**
```
时间线：
1. 查缓存miss
2. 查DB得到旧值
3. 写缓存（缓存旧值）
4. 更新DB（新值）
5. 删缓存

解决：延迟双删
```

**延迟双删：**
```java
public void updateUser(User user) {
    // 1. 删除缓存
    redis.delete("user:" + user.getId());
    
    // 2. 更新DB
    userMapper.update(user);
    
    // 3. 延迟删除
    try {
        Thread.sleep(500);
    } catch (InterruptedException e) {}
    redis.delete("user:" + user.getId());
}
```

**2. 删除失败**
```
解决：删除重试
- 消息队列
- Canal订阅binlog
```

**其他方案：**

**Write Through：**
```
同时写缓存和DB
强一致，但性能低
```

**Read Through：**
```
读取时自动加载缓存
对业务透明
```

**订阅binlog：**
```
MySQL → Binlog → Canal → Redis
异步同步，保证最终一致
```

---

## 10. Redis分布式锁实现？

**题目：**
如何用Redis实现分布式锁？

**答案：**
**简单实现（SETNX）：**
```java
// 获取锁
String lockKey = "lock:product:" + productId;
boolean locked = redisTemplate.opsForValue()
    .setIfAbsent(lockKey, "1", 30, TimeUnit.SECONDS);

if (locked) {
    try {
        // 业务逻辑
    } finally {
        // 释放锁
        redisTemplate.delete(lockKey);
    }
}
```

**问题：**
- 锁过期，但业务未完成
- 释放别人的锁

**改进方案（Lua脚本）：**
```java
String script = 
    "if redis.call('get', KEYS[1]) == ARGV[1] then " +
    "    return redis.call('del', KEYS[1]) " +
    "else " +
    "    return 0 " +
    "end";

// 释放锁时执行
redisTemplate.execute(script, 
    Collections.singletonList(lockKey), 
    lockValue);
```

**Redisson实现：**
```java
// 获取锁
RLock lock = redissonClient.getLock("lockKey");
lock.lock();

// 带超时
lock.lock(10, TimeUnit.SECONDS);

// 尝试获取
if (lock.tryLock(100, 10, TimeUnit.SECONDS)) {
    try {
        // 业务逻辑
    } finally {
        lock.unlock();
    }
}

// 看门狗（自动续期）
Config config = new Config();
config.setLockWatchdogTimeout(30000);
```

**Redisson优势：**
- 自动续期（看门狗）
- 公平锁、可重入锁
- 读写锁支持

---

## 11. Redis为什么快？

**题目：**
Redis为什么速度快？

**答案：**
**1. 基于内存**
```
数据存储在内存
内存访问速度：ns级别
```

**2. 单线程模型**
```
避免锁竞争
无线程切换开销
```

**3. IO多路复用**
```
epoll/select/kqueue
单线程处理大量连接
```

**4. 优化的数据结构**
```
SDS：字符串
ziplist：压缩列表
quicklist：快速列表
skiplist：跳表
hashtable：哈希表
```

**5. 简单协议**
```
RESP协议
简洁、高效
```

**架构图：**
```
┌─────────────────────────────────────────────────┐
│                    Redis                         │
│                                                 │
│  ┌───────────────────────────────────────────┐  │
│  │           单线程处理命令                    │  │
│  │      client → event loop → command        │  │
│  └───────────────────────────────────────────┘  │
│                     ↑                           │
│  ┌───────────────────────────────────────────┐  │
│  │          IO多路复用（epoll）               │  │
│  └───────────────────────────────────────────┘  │
│                     ↑                           │
│  ┌───────────────────────────────────────────┐  │
│  │              网络连接（Socket）            │  │
│  └───────────────────────────────────────────┘  │
│                                                 │
│  ┌───────────────────────────────────────────┐  │
│  │              内存数据存储                   │  │
│  │         SDS + ziplist + skiplist          │  │
│  └───────────────────────────────────────────┘  │
└─────────────────────────────────────────────────┘
```

---

## 12. Redis的事务支持？

**题目：**
Redis支持事务吗？

**答案：**
**Redis事务：**
```
通过MULTI、EXEC、DISCARD、WATCH实现
保证命令原子执行
```

**基本用法：**
```bash
# 开启事务
MULTI

# 命令入队
SET key1 value1
SET key2 value2
INCR count

# 执行事务
EXEC

# 取消事务
DISCARD
```

**WATCH实现乐观锁：**
```java
// 监视key
redis.watch("key");

// 开启事务
redis.multi();

// 修改
redis.set("key", "newValue");

// 执行
List<Object> results = redis.exec();

if (results == null) {
    // 事务失败（被其他客户端修改）
}
```

**事务特性：**
```
1. 原子性：不保证原子性
   - 命令失败不回滚
   - EXEC前命令失败继续执行
   
2. 隔离性：单线程保证
   - 事务串行执行
   
3. 一致性：命令保证
   - 命令格式错误不执行
```

**注意：**
```
Redis事务不支持回滚（除语法错误）
需要业务层保证一致性
```

---

## 13. Redis的Lua脚本？

**题目：**
Redis Lua脚本有什么用？

**答案：**
**Lua脚本优势：**
- 原子性执行
- 减少网络开销
- 复用逻辑

**使用示例：**
```java
// 限流脚本
String script = 
    "local key = KEYS[1] " +
    "local limit = tonumber(ARGV[1]) " +
    "local expire = tonumber(ARGV[2]) " +
    "local current = redis.call('GET', key) or 0 " +
    "if current + 1 > limit then " +
    "    return 0 " +
    "end " +
    "redis.call('INCR', key) " +
    "if current == 0 then " +
    "    redis.call('EXPIRE', key, expire) " +
    "end " +
    "return 1";

Long result = redisTemplate.execute(
    script,
    Collections.singletonList("rate:limit:user1"),
    100, 60
);
```

**应用场景：**
- 限流
- 分布式锁
- 库存扣减
- 排行榜计算

**脚本管理：**
```bash
# 加载脚本
SCRIPT LOAD "return redis.call('GET', KEYS[1])"

# 执行脚本
EVAL "return redis.call('GET', KEYS[1])" 1 mykey

# 使用缓存脚本
EVALSHA "script_sha1" 1 mykey
```

---

## 14. Redis实现延迟队列？

**题目：**
如何用Redis实现延迟队列？

**答案：**
**方案：ZSet + Redis执行器**

**实现原理：**
```
延迟任务 → 存入ZSet（score=执行时间）
执行器 → 定时扫描ZSet
        → 获取到期的任务
        → 放入普通队列执行
```

**代码实现：**
```java
// 添加延迟任务
public void addDelayTask(String taskId, long delayMs) {
    long executeTime = System.currentTimeMillis() + delayMs;
    redisTemplate.opsForZSet()
        .add("delay_queue", taskId, executeTime);
}

// 执行器
public void executeTask() {
    Set<String> tasks = redisTemplate.opsForZSet()
        .rangeByScore("delay_queue", 0, System.currentTimeMillis());
    
    for (String taskId : tasks) {
        // 移动到执行队列
        redisTemplate.opsForZSet()
            .remove("delay_queue", taskId);
        redisTemplate.opsForList()
            .rightPush("task_queue", taskId);
        
        // 处理任务
        processTask(taskId);
    }
}
```

**使用场景：**
- 订单超时取消
- 消息重试
- 定时提醒

**与RabbitMQ延迟队列对比：**
| 特性 | Redis延迟队列 | RabbitMQ延迟插件 |
|------|---------------|------------------|
| 可靠性 | 一般 | 高 |
| 复杂度 | 低 | 中 |
| 持久化 | 需配置 | 原生支持 |
| 适用场景 | 简单延迟 | 企业级 |

---

## 15. Redis大Key问题？

**题目：**
Redis大Key有什么问题？如何处理？

**答案：**
**大Key定义：**
```
String类型：value > 10MB
Collection类型：元素 > 10000
```

**大Key问题：**
```
1. 内存占用高
2. 加载慢，阻塞主线程
3. 网络传输慢
4. 内存碎片
5. 持久化/备份慢
```

**发现问题：**
```bash
# Redis 4.0+ 支持
redis-cli --bigkeys

# 手动扫描
redis-cli --scan --bigkeys

# 使用工具
rdbtools
```

**处理方案：**

**1. 拆分大Key**
```java
// 拆分Hash
// 原来：user:10000 包含所有字段
// 拆分：user:10000:name, user:10000:age, ...

// 拆分List
// 原来：user:10000:orders 包含100000订单
// 拆分：user:10000:orders:0, user:10000:orders:1, ...
```

**2. 压缩存储**
```java
// String类型使用压缩
GZIPOutputStream gzip = new GZIPOutputStream(
    new ByteArrayOutputStream());
gzip.write(value.getBytes());
byte[] compressed = gzip.toByteArray();
redis.set(key, compressed);
```

**3. 定期清理**
```java
// 设置TTL
expire(key, 86400 * 7);
```

**4. 使用替代方案**
```
大Value → 存到文件/MongoDB/HBase
```

**预防措施：**
```
1. 监控大Key
2. 限制Value大小
3. 规范数据结构
```

---

*更多Redis面试题答案*
