# 分布式事务 面试题

## 题目
## 2. 2PC两阶段提交原理？
## 3. 3PC三阶段提交原理？
## 4. TCC事务原理？
## 5. Seata AT模式原理？
## 6. 消息事务方案？
## 7. 本地消息表方案？
## 8. 分布式事务选型？
## 9. 如何保证幂等性？
## 10. 分布式事务和本地事务区别？

更多题目请查看答案文件

## 答案

**题目：**
什么是CAP定理和BASE理论？

**答案：**
**CAP定理：**
```
分布式系统最多同时满足两个特性：

C（Consistency）：强一致性
A（Availability）：可用性  
P（Partition Tolerance）：分区容错性

分布式系统必须满足P，只能在C和A之间权衡
```

**CAP权衡：**
```
CP系统：优先保证一致性（银行转账）
AP系统：优先保证可用性（电商系统）
CA系统：单机系统（放弃P）
```

**BASE理论：**
```
Basically Available：基本可用
Soft State：软状态
Eventually Consistent：最终一致

核心思想：牺牲强一致，追求可用性和最终一致
```

**BASE vs ACID：**
| BASE | ACID |
|------|------|
| 最终一致 | 强一致 |
| 软状态 | 硬状态 |
| 可用优先 | 隔离性优先 |
| 最终一致性 | 立即一致性 |

---

## 2. 2PC两阶段提交原理？

**题目：**
2PC两阶段提交是什么？原理是什么？

**答案：**
**2PC定义：**
Two-Phase Commit，两阶段提交，分布式事务协议。

**两个阶段：**
```
阶段1：Prepare（准备阶段）
阶段2：Commit（提交阶段）
```

**流程：**
```
┌─────────────────────────────────────────────────────────────┐
│                    2PC两阶段提交流程                         │
│                                                             │
│  协调者                    参与者1           参与者2        │
│    │                         │                 │           │
│    │──── Prepare ────────────>│                 │           │
│    │                         │                 │           │
│    │                         │── Prepare ─────>│           │
│    │                         │                 │           │
│    │<── Yes/No ──────────────│                 │           │
│    │<────────── Yes/No ────────────────────────>│           │
│    │                         │                 │           │
│    │         ┌────────────────┴────────────────┐           │
│    │         │  汇总结果                        │           │
│    │         └────────────────┬────────────────┘           │
│    │                          │                            │
│    │──── Commit ─────────────>│                 │           │
│    │                         │                 │           │
│    │                         │── Commit ──────>│           │
│    │                         │                 │           │
│    │<── ACK ─────────────────│                 │           │
│    │<──────────── ACK ────────────────────────>│           │
│    │                         │                 │           │
└─────────────────────────────────────────────────────────────┘
```

**2PC问题：**
```
1. 同步阻塞
2. 协调者单点故障
3. 数据不一致风险（阶段2部分成功）
```

---

## 3. 3PC三阶段提交原理？

**题目：**
3PC三阶段提交是什么？和2PC有什么区别？

**答案：**
**3PC定义：**
Three-Phase Commit，三阶段提交。

**三个阶段：**
```
阶段1：CanCommit（能否提交）
阶段2：PreCommit（准备提交）
阶段3：DoCommit（真正提交）
```

**流程：**
```
┌─────────────────────────────────────────────────────────────┐
│                    3PC三阶段提交流程                         │
│                                                             │
│  协调者                    参与者                           │
│    │                         │                             │
│    │──── CanCommit ─────────>│                             │
│    │                         │                             │
│    │<── Yes/No ──────────────│                             │
│    │                         │                             │
│    │         ┌───────────────┴───────────────┐             │
│    │         │  汇总结果                      │             │
│    │         └───────────────┬───────────────┘             │
│    │                         │                             │
│    │──── PreCommit ─────────>│                             │
│    │                         │                             │
│    │<── ACK ─────────────────│                             │
│    │                         │                             │
│    │──── DoCommit ──────────>│                             │
│    │                         │                             │
│    │<── ACK ─────────────────│                             │
│    │                         │                             │
└─────────────────────────────────────────────────────────────┘
```

**2PC vs 3PC：**
| 特性 | 2PC | 3PC |
|------|-----|-----|
| **阶段** | 2 | 3 |
| **阻塞时间** | 长 | 短 |
| **协调者故障** | 可能阻塞 | 可恢复 |
| **复杂度** | 低 | 高 |
| **实际应用** | 少 | 很少 |

---

## 4. TCC事务原理？

**题目：**
TCC事务是什么？原理是什么？

**答案：**
**TCC定义：**
Try-Confirm-Cancel，基于业务层的分布式事务方案。

**三个阶段：**
```
Try：预留资源（锁定）
Confirm：确认执行（扣款）
Cancel：取消回滚（释放）
```

**流程：**
```
┌─────────────────────────────────────────────────────────────┐
│                      TCC事务流程                             │
│                                                             │
│  Try阶段：                                                   │
│  ┌─────────────────────────────────────────────────────┐   │
│  │ - 冻结库存（库存-冻结=可用）                          │   │
│  │ - 预留金额（余额-冻结=可用）                          │   │
│  │ - 创建订单（待支付状态）                              │   │
│  └─────────────────────────────────────────────────────┘   │
│                            ↓                                │
│  Confirm阶段：                                               │
│  ┌─────────────────────────────────────────────────────┐   │
│  │ - 扣减冻结库存                                       │   │
│  │ - 扣减冻结金额                                       │   │
│  │ - 更新订单状态（已支付）                              │   │
│  └─────────────────────────────────────────────────────┘   │
│                            ↓                                │
│  Cancel阶段：                                                │
│  ┌─────────────────────────────────────────────────────┐   │
│  │ - 释放冻结库存                                       │   │
│  │ - 释放冻结金额                                       │   │
│  │ - 取消订单                                           │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

**代码示例：**
```java
@LocalTCC
public interface OrderService {
    
    @TwoPhaseBusinessAction(
        name = "createOrder",
        commitMethod = "confirmOrder",
        rollbackMethod = "cancelOrder"
    )
    void tryOrder(
        @BusinessActionContextParameter(paramName = "orderId") 
        String orderId,
        @BusinessActionContextParameter(paramName = "amount") 
        BigDecimal amount);
    
    void confirmOrder(BusinessActionContext context);
    
    void cancelOrder(BusinessActionContext context);
}
```

**TCC特点：**
```
✅ 最终一致性
✅ 性能较好
❌ 侵入性强（业务改造成本高）
❌ 需要处理空回滚、幂等问题
```

---

## 5. Seata AT模式原理？

**题目：**
Seata AT模式是什么？原理是什么？

**答案：**
**Seata定义：**
阿里巴巴开源的分布式事务解决方案，支持AT、TCC、Saga、XA模式。

**AT模式原理：**
```
1. 一阶段：执行SQL，生成undo log，提交
2. 二阶段：异步删除undo log，回滚时反向补偿
```

**AT流程：**
```
┌─────────────────────────────────────────────────────────────┐
│                    Seata AT模式流程                          │
│                                                             │
│  一阶段（执行）：                                            │
│  ┌─────────────────────────────────────────────────────┐   │
│  │ 1. 解析SQL，获取表、主键                            │   │
│  │ 2. 执行SQL，生成undo log（反向SQL）                │   │
│  │ 3. 前后镜像保存到seata库                           │   │
│  │ 4. 执行业务SQL                                     │   │
│  │ 5. 注册分支事务，写binlog                         │   │
│  │ 6. 提交事务                                        │   │
│  └─────────────────────────────────────────────────────┘   │
│                            ↓                                │
│  二阶段（提交）：                                            │
│  ┌─────────────────────────────────────────────────────┐   │
│  │ - 异步删除undo log                                 │   │
│  └─────────────────────────────────────────────────────┘   │
│                            ↓                                │
│  二阶段（回滚）：                                            │
│  ┌─────────────────────────────────────────────────────┐   │
│  │ 1. 查找undo log                                    │   │
│  │ 2. 生成反向SQL（INSERT → DELETE，UPDATE逆向）      │   │
│  │ 3. 执行反向SQL                                     │   │
│  │ 4. 删除undo log                                    │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

**使用示例：**
```java
@GlobalTransactional
@Transactional
public void createOrder(OrderDTO order) {
    // 扣减库存
    storageService.decrease(order.getProductId(), order.getCount());
    
    // 创建订单
    orderMapper.insert(order);
    
    // 扣减余额
    accountService.decrease(order.getUserId(), order.getAmount());
}
```

---

## 6. 消息事务方案？

**题目：**
基于消息队列的分布式事务方案是什么？

**答案：**
**消息事务原理：**
```
半消息 → 本地事务 → 确认提交 → 消息投递
```

**RocketMQ事务消息：**
```java
// 1. 发送半消息
Message message = new Message("OrderTopic", 
    JSON.toJSONString(order).getBytes());
TransactionListener listener = new TransactionListener() {
    
    public LocalTransactionState executeLocalTransaction(
        Message msg, Object arg) {
        try {
            // 本地事务：创建订单
            orderService.createOrder(order);
            return LocalTransactionState.COMMIT_MESSAGE;
        } catch (Exception e) {
            return LocalTransactionState.ROLLBACK_MESSAGE;
        }
    }
    
    public LocalTransactionState checkLocalTransaction(
        Message msg) {
        // 事务回查
        if (orderService.checkOrder(msg)) {
            return LocalTransactionState.COMMIT_MESSAGE;
        }
        return LocalTransactionState.ROLLBACK_MESSAGE;
    }
};

TransactionMQProducer producer = new TransactionMQProducer();
producer.setTransactionListener(listener);
producer.sendMessageInTransaction(message, null);
```

**消息事务特点：**
```
✅ 最终一致性
✅ 业务侵入性低
✅ 性能较好
❌ 依赖消息队列事务消息支持
❌ 有延迟（半消息到确认）
```

---

## 7. 本地消息表方案？

**题目：**
本地消息表方案是什么？

**答案：**
**本地消息表原理：**
```
本地数据库 + 消息表 + 定时任务
```

**流程：**
```
┌─────────────────────────────────────────────────────────────┐
│                    本地消息表方案                            │
│                                                             │
│  1. 写入业务数据和消息表（同一事务）                          │
│  ┌─────────────────────────────────────────────────────┐   │
│  │ BEGIN;                                              │   │
│  │ INSERT INTO order (...) VALUES (...);               │   │
│  │ INSERT INTO message (topic, body, status)           │   │
│  │   VALUES ('order', '...', 'INIT');                 │   │
│  │ COMMIT;                                             │   │
│  └─────────────────────────────────────────────────────┘   │
│                            ↓                                │
│  2. 定时任务扫描消息表，发送消息                              │
│  ┌─────────────────────────────────────────────────────┐   │
│  │ SELECT * FROM message WHERE status = 'INIT';        │   │
│  │                                                     │   │
│  │ FOR msg IN messages:                                │   │
│  │   kafka.send(msg.topic, msg.body);                 │   │
│  │   UPDATE message SET status = 'SENT' WHERE id=...  │   │
│  └─────────────────────────────────────────────────────┘   │
│                            ↓                                │
│  3. 消费者回调确认                                           │
│  ┌─────────────────────────────────────────────────────┐   │
│  │ 消费成功后：                                        │   │
│  │   UPDATE message SET status = 'DONE' WHERE id=...  │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

**消息表设计：**
```sql
CREATE TABLE message (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    topic VARCHAR(100) NOT NULL,
    body TEXT NOT NULL,
    status VARCHAR(20) NOT NULL,  -- INIT, SENT, DONE, FAILED
    retry_count INT DEFAULT 0,
    create_time DATETIME DEFAULT CURRENT_TIMESTAMP,
    update_time DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE
);

-- 索引
INDEX idx_status_retry (status, retry_count);
```

**特点：**
```
✅ 实现简单
✅ 不依赖外部组件
❌ 业务和消息耦合
❌ 需要定时任务
```

---

## 8. 分布式事务选型？

**题目：**
分布式事务方案如何选择？

**答案：**
**方案对比：**

| 方案 | 一致性 | 性能 | 复杂度 | 侵入性 | 适用场景 |
|------|--------|------|--------|--------|----------|
| **2PC** | 强一致 | 低 | 高 | 高 | 银行转账 |
| **3PC** | 强一致 | 低 | 高 | 高 | 很少使用 |
| **TCC** | 最终一致 | 中 | 高 | 高 | 电商订单 |
| **Seata AT** | 最终一致 | 中 | 中 | 低 | 通用场景 |
| **消息事务** | 最终一致 | 高 | 中 | 低 | 消息驱动 |
| **本地消息表** | 最终一致 | 中 | 低 | 低 | 异步场景 |
| **Saga** | 最终一致 | 高 | 中 | 中 | 长事务 |

**选型建议：**

**强一致性场景：**
```
金融交易 → 2PC/Seata XA
```

**最终一致性场景：**
```
电商订单 → TCC / Seata AT
消息驱动 → 消息事务 / 本地消息表
长事务流程 → Saga
```

**性能优先：**
```
消息队列 + 本地事务
```

**业务改造成本：**
```
Seata AT（低侵入）
TCC（高侵入）
```

---

## 9. 如何保证幂等性？

**题目：**
分布式事务中如何保证幂等性？

**答案：**
**幂等性定义：**
多次调用结果与一次调用结果相同。

**保证方案：**

**1. 唯一索引**
```sql
-- 数据库唯一约束
CREATE TABLE order (
    order_no VARCHAR(32) PRIMARY KEY,
    ...
);

-- 重复插入报错
INSERT INTO order (order_no, ...) 
VALUES ('ORDER123', ...) 
ON DUPLICATE KEY UPDATE status = 'PAID';
```

**2. 分布式锁**
```java
String lockKey = "process:" + orderNo;
boolean locked = redisTemplate.opsForValue()
    .setIfAbsent(lockKey, "1", 10, TimeUnit.SECONDS);

if (!locked) {
    return "重复请求";
}
try {
    processOrder(orderNo);
} finally {
    redisTemplate.delete(lockKey);
}
```

**3. 状态机**
```java
// 订单状态流转
if (!"待支付".equals(order.getStatus())) {
    return "订单状态异常";
}
order.setStatus("支付中");
```

**4. 去重表**
```sql
CREATE TABLE idem_key (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    `key` VARCHAR(100) UNIQUE,
    status VARCHAR(20),
    create_time DATETIME
);

-- 插入前检查
INSERT INTO idem_key (`key`) VALUES ('REQ123');
```

---

## 10. 分布式事务和本地事务区别？

**题目：**
分布式事务和本地事务有什么区别？

**答案：**
**对比表格：**

| 特性 | 本地事务 | 分布式事务 |
|------|----------|------------|
| **范围** | 单数据库 | 多数据库/服务 |
| **ACID** | 完全支持 | 只能保证最终一致 |
| **实现** | 数据库原生支持 | 需要中间件/协议 |
| **性能** | 高 | 低 |
| **复杂度** | 低 | 高 |
| **隔离性** | 强 | 弱 |
| **一致性** | 强一致 | 最终一致 |

**本地事务：**
```
单数据库
ACID保证
性能高
```

**分布式事务：**
```
多数据源
BASE理论
性能较低
复杂度高
```

**使用场景：**
```
本地事务：单库操作
分布式事务：跨库、跨服务
```

---

*更多分布式事务面试题答案*
