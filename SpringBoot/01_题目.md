# Spring Boot 面试题

## 1. Spring Boot 是什么？

**题目：**
Spring Boot 是什么？它有什么特点？

**答案：**
**Spring Boot 定义：**
Spring Boot 是 Spring 框架的子项目，旨在简化 Spring 应用的创建和开发过程。它提供了自动配置、起步依赖等特性，让开发者可以快速搭建生产级别的 Spring 应用。

**核心特点：**
| 特性 | 说明 |
|------|------|
| **自动配置** | 根据类路径和配置自动配置 Spring 应用 |
| **起步依赖** | 打包好的依赖集合，简化 Maven/Gradle 配置 |
| **内嵌服务器** | 内嵌 Tomcat、Jetty、Undertow，无需部署 WAR |
| **Actuator** | 提供生产级别的监控和管理功能 |
| **无代码生成** | 不需要 XML 配置，通过注解和配置实现 |
| **约定优于配置** | 提供合理的默认配置，快速开发 |

**Spring Boot 的优势：**
```java
// 传统 Spring MVC 项目需要大量配置
// 1. 配置 DispatcherServlet
// 2. 配置 ViewResolver
// 3. 配置组件扫描
// 4. 配置数据源
// 5. 配置事务管理
// ... 等等

// Spring Boot 只需要一个启动类
@SpringBootApplication
public class Application {
    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }
}
```

---

## 2. @SpringBootApplication 注解的作用？

**题目：**
@SpringBootApplication 注解是什么？它包含哪些注解？

**答案：**
**@SpringBootApplication 定义：**
这是 Spring Boot 应用的启动注解，通常放在主类上。它是一个组合注解，包含三个核心注解。

**注解组成：**
```java
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Configuration  // 1. 标记为配置类
@EnableAutoConfiguration  // 2. 开启自动配置
@ComponentScan  // 3. 组件扫描
public @interface SpringBootApplication {
    // ... 属性配置
}
```

**各注解作用：**
1. **@Configuration**
   - 标记类为 Spring 配置类
   - 可以使用 @Bean 定义 Bean

2. **@EnableAutoConfiguration**
   - 启用 Spring Boot 的自动配置机制
   - 根据类路径中的依赖自动配置 Spring 应用
   - 例如：检测到 Spring Data JPA，自动配置 JPA 相关 Bean

3. **@ComponentScan**
   - 自动扫描当前包及其子包中的 @Component、@Service、@Repository、@Controller 等注解
   - 默认扫描主类所在包及其子包

**排除特定自动配置：**
```java
// 方式1：排除某个自动配置
@SpringBootApplication(exclude = {DataSourceAutoConfiguration.class})

// 方式2：通过配置文件排除
// spring.autoconfigure.exclude=org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration
```

---

## 3. Spring Boot 自动配置原理？

**题目：**
Spring Boot 的自动配置是如何实现的？

**答案：**
**自动配置核心原理：**
Spring Boot 自动配置基于 `@EnableAutoConfiguration` 注解，通过 `SpringFactoriesLoader` 加载类路径下的 `META-INF/spring.factories` 文件。

**实现步骤：**
```java
// 1. @EnableAutoConfiguration 注解
@Import(AutoConfigurationImportSelector.class)
public @interface EnableAutoConfiguration {
    // ...
}

// 2. AutoConfigurationImportSelector 实现
public class AutoConfigurationImportSelector 
    implements ImportSelector, BeanClassLoaderAware {
    
    // 加载 META-INF/spring.factories
    protected List<String> getCandidateConfigurations() {
        return SpringFactoriesLoader.loadFactoryNames(
            getSpringFactoriesLoaderFactoryClass(), 
            getBeanClassLoader()
        );
    }
}
```

**自动配置过程：**
```
1. Spring Boot 启动
   ↓
2. @SpringBootApplication → @EnableAutoConfiguration
   ↓
3. 加载 spring.factories 文件
   ↓
4. 获取所有自动配置类列表
   ↓
5. 按条件过滤（@Conditional 注解）
   ↓
6. 加载符合条件的自动配置类
   ↓
7. 配置相应的 Bean
```

**@Conditional 条件注解：**
```java
// @ConditionalOnClass - 类路径存在时才配置
@Configuration
@ConditionalOnClass(DataSource.class)
public class DataSourceAutoConfiguration {
    // ...
}

// @ConditionalOnMissingClass - 类路径不存在时才配置
@ConditionalOnMissingClass("com.example.OldClass")
public class NewClassAutoConfiguration {
    // ...
}

// @ConditionalOnBean - 容器中存在某个 Bean 时才配置
@ConditionalOnBean(DataSource.class)
public class JdbcTemplateAutoConfiguration {
    // ...
}

// @ConditionalOnProperty - 配置属性满足条件时才配置
@ConditionalOnProperty(prefix = "spring.datasource", name = "url")
public class DataSourceProperties {
    // ...
}
```

---

## 4. Spring Boot 启动流程？

**题目：**
Spring Boot 应用是如何启动的？请描述其启动流程。

**答案：**
**SpringApplication 启动流程：**
```java
public static void main(String[] args) {
    SpringApplication.run(Application.class, args);
}
```

**详细启动步骤：**
```
1. 创建 SpringApplication 对象
   ├── 推断应用类型（WebApplicationType）
   ├── 设置 ApplicationContextInitializer
   ├── 设置 ApplicationListener
   └── 推断主类（Main Class）

2. 执行 run() 方法
   ├── 准备环境（ConfigurableEnvironment）
   ├── 配置 Spring 上下文
   ├── 刷新上下文
   └── 执行 Runner
```

**源码流程：**
```java
public ConfigurableApplicationContext run(String... args) {
    // 1. 创建启动计时器
    StopWatch stopWatch = new StopWatch();
    stopWatch.start();
    
    // 2. 创建引导上下文（Bootstrap Context）
    DefaultBootstrapContext bootstrapContext = 
        createBootstrapContext();
    
    // 3. 配置环境
    ConfigurableEnvironment environment = 
        prepareEnvironment(listeners, bootstrapContext);
    
    // 4. 配置忽略的 Bean
    configureIgnoreBeanInfo(environment);
    
    // 5. 打印 Banner
    Banner printedBanner = printBanner(environment);
    
    // 6. 创建 ApplicationContext
    context = createApplicationContext();
    
    // 7. 准备上下文
    prepareContext(context, environment, 
        listeners, bootstrapContext, printedBanner);
    
    // 8. 刷新上下文
    refreshContext(context);
    
    // 9. 执行 Runner
    afterRefresh(context, applicationArguments);
    
    // 10. 发布启动完成事件
    listeners.started(context);
    
    // 11. 调用 Runner
    callRunners(context, applicationArguments);
    
    return context;
}
```

**扩展点：**
```java
// ApplicationRunner 和 CommandLineRunner
@Component
public class MyRunner implements ApplicationRunner {
    @Override
    public void run(ApplicationArguments args) {
        // 应用启动后执行
    }
}

// ApplicationContextInitializer
public class MyInitializer 
    implements ApplicationContextInitializer<ConfigurableApplicationContext> {
    @Override
    public void initialize(
        ConfigurableApplicationContext context) {
        // 上下文初始化前执行
    }
}
```

---

## 5. Spring Boot 配置文件优先级？

**题目：**
Spring Boot 的配置文件有哪些？它们的优先级顺序是什么？

**答案：**
**配置文件类型：**
- `application.properties`
- `application.yml` / `application.yaml`
- `application-{profile}.properties`

**配置文件位置（优先级从高到低）：**
```
1. 当前项目根目录的 /config 目录
2. 当前项目根目录
3. 类路径的 /config 目录
4. 类路径根目录
```

**配置文件优先级顺序：**
```
1. 命令行参数（最高优先级）
   --spring.config.location=/path/to/config/

2. 操作系统环境变量
   SPRING_APPLICATION_JSON

3. Java 系统属性
   -Dspring.config.location=/path/

4. jar 包外的 application-{profile}.yml
   /config/application-{profile}.yml

5. jar 包内的 application-{profile}.yml

6. jar 包外的 application.yml
   /config/application.yml

7. jar 包内的 application.yml（最低优先级）

8. 默认值（最低）
```

**profile 特定的配置文件：**
```properties
# application-dev.properties（开发环境）
spring.datasource.url=jdbc:mysql://localhost:3306/dev
server.port=8080

# application-prod.properties（生产环境）
spring.datasource.url=jdbc:mysql://prod:3306/prod
server.port=80

# 激活 profile
# 命令行：--spring.profiles.active=prod
# 配置：spring.profiles.active=dev
```

**配置属性占位符：**
```properties
# 随机值
app.secret=${random.value}
app.number=${random.int}

# 引用其他配置
app.name=${APP_NAME:默认值}

# 多文档配置（YAML）
spring:
  config:
    activate:
      on-profile: "dev"
---
spring:
  config:
    activate:
      on-profile: "prod"
```

---

## 6. Spring Boot 日志配置？

**题目：**
Spring Boot 如何配置日志？有哪些日志框架？

**答案：**
**Spring Boot 日志框架：**
Spring Boot 默认使用 **SLF4J + Logback** 作为日志框架。

**日志级别：**
```
TRACE < DEBUG < INFO < WARN < ERROR < FATAL < OFF
```

**配置文件方式：**
```properties
# application.properties
logging.level.root=INFO
logging.level.com.example=DEBUG
logging.level.org.springframework=WARN

# 日志文件
logging.file.name=app.log
logging.file.max-size=10MB
logging.file.max-history=30

# 格式
logging.pattern.console=%d{yyyy-MM-dd HH:mm:ss} -%msg%n
```

```yaml
# application.yml
logging:
  level:
    root: INFO
    com.example: DEBUG
    org.springframework: DEBUG
  file:
    name: app.log
  pattern:
    console: "%d{yyyy-MM-dd HH:mm:ss} -%msg%n"
```

**Logback 详细配置（logback-spring.xml）：**
```xml
<?xml version="1.0" encoding="UTF-8"?>
<configuration>
    <!-- 定义日志文件位置 -->
    <property name="LOG_PATH" value="./logs"/>
    
    <!-- 控制台输出 -->
    <appender name="CONSOLE" 
              class="ch.qos.logback.core.ConsoleAppender">
        <encoder>
            <pattern>%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n</pattern>
        </encoder>
    </appender>
    
    <!-- 文件输出 -->
    <appender name="FILE" 
              class="ch.qos.logback.core.rolling.RollingFileAppender">
        <file>${LOG_PATH}/app.log</file>
        <rollingPolicy 
            class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <fileNamePattern>${LOG_PATH}/app.%d{yyyy-MM-dd}.log</fileNamePattern>
            <maxHistory>30</maxHistory>
        </rollingPolicy>
        <encoder>
            <pattern>%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n</pattern>
        </encoder>
    </appender>
    
    <!-- 异步输出 -->
    <appender name="ASYNC_FILE" 
              class="ch.qos.logback.classic.AsyncAppender">
        <appender-ref ref="FILE"/>
        <queueSize>512</queueSize>
        <discardingThreshold>0</discardingThreshold>
    </appender>
    
    <!-- 日志级别 -->
    <root level="INFO">
        <appender-ref ref="CONSOLE"/>
        <appender-ref ref="ASYNC_FILE"/>
    </root>
    
    <!-- 特定包日志级别 -->
    <logger name="com.example.dao" level="DEBUG"/>
</configuration>
```

**在代码中使用：**
```java
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

@Service
public class UserService {
    private static final Logger logger = 
        LoggerFactory.getLogger(UserService.class);
    
    public void addUser(User user) {
        logger.debug("添加用户: {}", user);
        logger.info("用户添加成功: {}", user.getName());
        logger.error("用户添加失败", e);
    }
}
```

---

## 7. Spring Boot 常用注解？

**题目：**
Spring Boot 有哪些常用注解？请举例说明。

**答案：**
**Spring Boot 核心注解：**

| 注解 | 说明 | 示例 |
|------|------|------|
| **@SpringBootApplication** | Spring Boot 启动注解 | 主类 |
| **@Configuration** | 配置类 | @Configuration |
| **@Bean** | 定义 Bean | @Bean |
| **@ComponentScan** | 组件扫描 | 自动扫描 |
| **@EnableAutoConfiguration** | 开启自动配置 | 内部使用 |

**Spring MVC 注解：**

| 注解 | 说明 | 示例 |
|------|------|------|
| **@Controller** | 控制器 | 页面控制器 |
| **@RestController** | REST 控制器 | API 接口 |
| **@RequestMapping** | 请求映射 | @RequestMapping("/api") |
| **@GetMapping** | GET 请求 | @GetMapping("/users") |
| **@PostMapping** | POST 请求 | @PostMapping("/users") |
| **@RequestBody** | 请求体绑定 | @RequestBody User user |
| **@ResponseBody** | 响应体返回 | 直接返回 JSON |
| **@PathVariable** | 路径变量 | @PathVariable Long id |
| **@RequestParam** | 请求参数 | @RequestParam String name |

**Spring IOC 注解：**

| 注解 | 说明 | 示例 |
|------|------|------|
| **@Component** | 通用组件 | @Component |
| **@Service** | 服务层 | @Service |
| **@Repository** | 数据访问层 | @Repository |
| **@Autowired** | 自动注入 | @Autowired |
| **@Qualifier** | 指定 Bean 名称 | @Qualifier("userService") |
| **@Resource** | Java 标准注入 | @Resource |
| **@Value** | 注入配置值 | @Value("${server.port}") |
| **@ConfigurationProperties** | 配置属性绑定 | @ConfigurationProperties(prefix = "db") |

**使用示例：**
```java
// Controller
@RestController
@RequestMapping("/users")
public class UserController {
    
    @Autowired
    private UserService userService;
    
    @GetMapping("/{id}")
    public User getUser(@PathVariable Long id) {
        return userService.findById(id);
    }
    
    @PostMapping
    public User createUser(@RequestBody @Valid User user) {
        return userService.save(user);
    }
}

// Service
@Service
public class UserService {
    
    @Autowired
    private UserRepository userRepository;
    
    @Value("${server.port}")
    private int port;
    
    @Transactional
    public User save(User user) {
        return userRepository.save(user);
    }
}

// Component
@Component
@ConfigurationProperties(prefix = "redis")
public class RedisProperties {
    private String host;
    private int port;
    
    // getters and setters
}

// Repository
@Repository
public interface UserRepository 
    extends JpaRepository<User, Long> {
    
    @Query("SELECT u FROM User u WHERE u.name = :name")
    User findByName(@Param("name") String name);
}
```

---

## 8. Spring Boot 数据访问？

**题目：**
Spring Boot 如何连接数据库？有哪些数据访问方式？

**答案：**
**数据访问配置：**
```properties
# application.properties
spring.datasource.url=jdbc:mysql://localhost:3306/mydb
spring.datasource.username=root
spring.datasource.password=123456
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver

# 连接池
spring.datasource.hikari.maximum-pool-size=10
spring.datasource.hikari.minimum-idle=5

# JPA/Hibernate
spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.format_sql=true
```

**Spring Data JPA：**
```java
// 实体类
@Entity
@Table(name = "users")
public class User {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(nullable = false, length = 50)
    private String name;
    
    @Column(unique = true)
    private String email;
    
    // getters and setters
}

// Repository
public interface UserRepository 
    extends JpaRepository<User, Long> {
    
    // 方法命名查询
    User findByEmail(String email);
    
    List<User> findByNameContaining(String name);
    
    // JPQL 查询
    @Query("SELECT u FROM User u WHERE u.name = :name")
    User findByNameJPQL(@Param("name") String name);
    
    // 原生 SQL 查询
    @Query(value = "SELECT * FROM users WHERE name = :name", 
           nativeQuery = true)
    User findByNameSQL(@Param("name") String name);
    
    // 分页查询
    Page<User> findByAgeGreaterThan(int age, Pageable pageable);
}

// Service
@Service
@Transactional
public class UserService {
    
    @Autowired
    private UserRepository userRepository;
    
    public User save(User user) {
        return userRepository.save(user);
    }
    
    public Optional<User> findById(Long id) {
        return userRepository.findById(id);
    }
    
    public Page<User> findAll(Pageable pageable) {
        return userRepository.findAll(pageable);
    }
}

// Controller
@RestController
@RequestMapping("/users")
public class UserController {
    
    @Autowired
    private UserService userService;
    
    @GetMapping
    public Page<User> list(Pageable pageable) {
        return userService.findAll(pageable);
    }
}
```

**多数据源配置：**
```java
// 主数据源
@Configuration
@Primary
@EnableJpaRepositories(
    basePackages = "com.example.repository.primary",
    entityManagerFactoryRef = "primaryEntityManager",
    transactionManagerRef = "primaryTransactionManager"
)
public class PrimaryDataSourceConfig {
    
    @Bean
    @Primary
    @ConfigurationProperties(prefix = "spring.datasource.primary")
    public DataSource primaryDataSource() {
        return DataSourceBuilder.create().build();
    }
    
    // EntityManagerFactory 和 TransactionManager 配置...
}

// 从数据源
@Configuration
@EnableJpaRepositories(
    basePackages = "com.example.repository.secondary",
    entityManagerFactoryRef = "secondaryEntityManager",
    transactionManagerRef = "secondaryTransactionManager"
)
public class SecondaryDataSourceConfig {
    // 类似配置...
}
```

---

## 9. Spring Boot 异常处理？

**题目：**
Spring Boot 如何处理全局异常？

**答案：**
**全局异常处理：**
```java
@ControllerAdvice
public class GlobalExceptionHandler {
    
    private static final Logger logger = 
        LoggerFactory.getLogger(GlobalExceptionHandler.class);
    
    // 处理参数校验异常
    @ExceptionHandler(MethodArgumentNotValidException.class)
    @ResponseBody
    public Result<Void> handleValidationException(
            MethodArgumentNotValidException e) {
        BindingResult bindingResult = e.getBindingResult();
        String message = bindingResult.getFieldErrors().stream()
            .map(FieldError::getDefaultMessage)
            .collect(Collectors.joining(", "));
        return Result.error(message);
    }
    
    // 处理业务异常
    @ExceptionHandler(BusinessException.class)
    @ResponseBody
    public Result<Void> handleBusinessException(
            BusinessException e) {
        logger.warn("业务异常: {}", e.getMessage());
        return Result.error(e.getMessage());
    }
    
    // 处理其他异常
    @ExceptionHandler(Exception.class)
    @ResponseBody
    public Result<Void> handleException(Exception e) {
        logger.error("系统异常", e);
        return Result.error("系统繁忙，请稍后重试");
    }
    
    // 404 处理
    @ExceptionHandler(NoHandlerFoundException.class)
    @ResponseBody
    public Result<Void> handle404(
            NoHandlerFoundException e) {
        return Result.error("请求的资源不存在");
    }
}
```

**统一响应结果：**
```java
@Data
@NoArgsConstructor
@AllArgsConstructor
public class Result<T> {
    private int code;
    private String message;
    private T data;
    
    public static <T> Result<T> success(T data) {
        return new Result<>(200, "success", data);
    }
    
    public static <T> Result<T> success() {
        return new Result<>(200, "success", null);
    }
    
    public static <T> Result<T> error(String message) {
        return new Result<>(500, message, null);
    }
    
    public static <T> Result<T> error(int code, String message) {
        return new Result<>(code, message, null);
    }
}
```

**自定义业务异常：**
```java
@Data
public class BusinessException extends RuntimeException {
    private int code;
    
    public BusinessException(String message) {
        super(message);
        this.code = 500;
    }
    
    public BusinessException(int code, String message) {
        super(message);
        this.code = code;
    }
}
```

---

## 10. Spring Boot 拦截器和过滤器？

**题目：**
Spring Boot 中的拦截器和过滤器有什么区别？如何使用？

**答案：**
**Filter（过滤器）：**
- Servlet 规范的一部分
- 在请求到达 DispatcherServlet 之前执行
- 可以过滤所有请求（包括静态资源）

**HandlerInterceptor（拦截器）：**
- Spring MVC 的一部分
- 在请求到达 Controller 之前执行
- 可以访问 HandlerMethod 和 HandlerExecutionChain

**Filter 使用：**
```java
// 方式1：使用 @WebFilter 注解
@WebFilter(urlPatterns = "/*")
public class TimeFilter implements Filter {
    
    @Override
    public void doFilter(ServletRequest request, 
                        ServletResponse response,
                        FilterChain chain) 
            throws IOException, ServletException {
        long start = System.currentTimeMillis();
        
        chain.doFilter(request, response);
        
        long time = System.currentTimeMillis() - start;
        System.out.println("请求耗时: " + time + "ms");
    }
}

// 方式2：使用 FilterRegistrationBean
@Configuration
public class FilterConfig {
    
    @Bean
    public FilterRegistrationBean<TimeFilter> timeFilter() {
        FilterRegistrationBean<TimeFilter> registration = 
            new FilterRegistrationBean<>();
        registration.setFilter(new TimeFilter());
        registration.addUrlPatterns("/*");
        registration.setOrder(1);
        return registration;
    }
}
```

**Interceptor 使用：**
```java
// 1. 创建拦截器
@Component
public class LoginInterceptor implements HandlerInterceptor {
    
    @Override
    public boolean preHandle(HttpServletRequest request,
                           HttpServletResponse response,
                           Object handler) throws Exception {
        // 检查用户是否登录
        Object user = request.getSession().getAttribute("user");
        if (user == null) {
            response.sendRedirect("/login");
            return false;
        }
        return true;
    }
    
    @Override
    public void postHandle(HttpServletRequest request,
                          HttpServletResponse response,
                          Object handler,
                          ModelAndView modelAndView) throws Exception {
        // Controller 方法执行后，视图渲染前
    }
    
    @Override
    public void afterCompletion(HttpServletRequest request,
                               HttpServletResponse response,
                               Object handler,
                               Exception ex) throws Exception {
        // 请求完成后（视图渲染后）
    }
}

// 2. 注册拦截器
@Configuration
public class WebConfig implements WebMvcConfigurer {
    
    @Autowired
    private LoginInterceptor loginInterceptor;
    
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(loginInterceptor)
            .addPathPatterns("/api/**")  // 拦截的路径
            .excludePathPatterns("/api/login", 
                                "/api/register");  // 排除的路径
    }
}
```

**执行顺序：**
```
Filter → Interceptor.preHandle → Controller → 
Interceptor.postHandle → Interceptor.afterCompletion → View
```

---

*更多 Spring Boot 面试题请查看答案文件*
