# SpringBoot 面试题

## 题目

**题目：**
Spring Boot 是什么？它有什么特点？

**答案：**
**Spring Boot 定义：**
Spring Boot 是 Spring 框架的子项目，旨在简化 Spring 应用的创建和开发过程。它提供了自动配置、起步依赖等特性，让开发者可以快速搭建生产级别的 Spring 应用。

**核心特点：**
| 特性 | 说明 |
|------|------|
| **自动配置** | 根据类路径和配置自动配置 Spring 应用 |
| **起步依赖** | 打包好的依赖集合，简化 Maven/Gradle 配置 |
| **内嵌服务器** | 内嵌 Tomcat、Jetty、Undertow，无需部署 WAR |
| **Actuator** | 提供生产级别的监控和管理功能 |
| **无代码生成** | 不需要 XML 配置，通过注解和配置实现 |
| **约定优于配置** | 提供合理的默认配置，快速开发 |

**Spring Boot 的优势：**
```java
// 传统 Spring MVC 项目需要大量配置
// 1. 配置 DispatcherServlet
// 2. 配置 ViewResolver
// 3. 配置组件扫描
// 4. 配置数据源
// 5. 配置事务管理
// ... 等等

// Spring Boot 只需要一个启动类
@SpringBootApplication
public class Application {
    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }
}
```

---

## 2. @SpringBootApplication 注解的作用？

**题目：**
@SpringBootApplication 注解是什么？它包含哪些注解？

**答案：**
**@SpringBootApplication 定义：**
这是 Spring Boot 应用的启动注解，通常放在主类上。它是一个组合注解，包含三个核心注解。

**注解组成：**
```java
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Configuration  // 1. 标记为配置类
@EnableAutoConfiguration  // 2. 开启自动配置
@ComponentScan  // 3. 组件扫描
public @interface SpringBootApplication {
    // ... 属性配置
}
```

**各注解作用：**
1. **@Configuration**
   - 标记类为 Spring 配置类
   - 可以使用 @Bean 定义 Bean

2. **@EnableAutoConfiguration**
   - 启用 Spring Boot 的自动配置机制
   - 根据类路径中的依赖自动配置 Spring 应用
   - 例如：检测到 Spring Data JPA，自动配置 JPA 相关 Bean

3. **@ComponentScan**
   - 自动扫描当前包及其子包中的 @Component、@Service、@Repository、@Controller 等注解
   - 默认扫描主类所在包及其子包

**排除特定自动配置：**
```java
// 方式1：排除某个自动配置
@SpringBootApplication(exclude = {DataSourceAutoConfiguration.class})

// 方式2：通过配置文件排除
// spring.autoconfigure.exclude=org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration
```

---

## 3. Spring Boot 自动配置原理？

**题目：**
Spring Boot 的自动配置是如何实现的？

**答案：**
**自动配置核心原理：**
Spring Boot 自动配置基于 `@EnableAutoConfiguration` 注解，通过 `SpringFactoriesLoader` 加载类路径下的 `META-INF/spring.factories` 文件。

**实现步骤：**
```java
// 1. @EnableAutoConfiguration 注解
@Import(AutoConfigurationImportSelector.class)
public @interface EnableAutoConfiguration {
    // ...
}

// 2. AutoConfigurationImportSelector 实现
public class AutoConfigurationImportSelector 
    implements ImportSelector, BeanClassLoaderAware {
    
    // 加载 META-INF/spring.factories
    protected List<String> getCandidateConfigurations() {
        return SpringFactoriesLoader.loadFactoryNames(
            getSpringFactoriesLoaderFactoryClass(), 
            getBeanClassLoader()
        );
    }
}
```

**自动配置过程：**
```
1. Spring Boot 启动
   ↓
2. @SpringBootApplication → @EnableAutoConfiguration
   ↓
3. 加载 spring.factories 文件
   ↓
4. 获取所有自动配置类列表
   ↓
5. 按条件过滤（@Conditional 注解）
   ↓
6. 加载符合条件的自动配置类
   ↓
7. 配置相应的 Bean
```

**@Conditional 条件注解：**
```java
// @ConditionalOnClass - 类路径存在时才配置
@Configuration
@ConditionalOnClass(DataSource.class)
public class DataSourceAutoConfiguration {
    // ...
}

// @ConditionalOnMissingClass - 类路径不存在时才配置
@ConditionalOnMissingClass("com.example.OldClass")
public class NewClassAutoConfiguration {
    // ...
}

// @ConditionalOnBean - 容器中存在某个 Bean 时才配置
@ConditionalOnBean(DataSource.class)
public class JdbcTemplateAutoConfiguration {
    // ...
}

// @ConditionalOnProperty - 配置属性满足条件时才配置
@ConditionalOnProperty(prefix = "spring.datasource", name = "url")
public class DataSourceProperties {
    // ...
}
```

---

## 4. Spring Boot 启动流程？

**题目：**
Spring Boot 应用是如何启动的？请描述其启动流程。

**答案：**
**SpringApplication 启动流程：**
```java
public static void main(String[] args) {
    SpringApplication.run(Application.class, args);
}
```

**详细启动步骤：**
```
1. 创建 SpringApplication 对象
   ├── 推断应用类型（WebApplicationType）
   ├── 设置 ApplicationContextInitializer
   ├── 设置 ApplicationListener
   └── 推断主类（Main Class）

2. 执行 run() 方法
   ├── 准备环境（ConfigurableEnvironment）
   ├── 配置 Spring 上下文
   ├── 刷新上下文
   └── 执行 Runner
```

**源码流程：**
```java
public ConfigurableApplicationContext run(String... args) {
    // 1. 创建启动计时器
    StopWatch stopWatch = new StopWatch();
    stopWatch.start();
    
    // 2. 创建引导上下文（Bootstrap Context）
    DefaultBootstrapContext bootstrapContext = 
        createBootstrapContext();
    
    // 3. 配置环境
    ConfigurableEnvironment environment = 
        prepareEnvironment(listeners, bootstrapContext);
    
    // 4. 配置忽略的 Bean
    configureIgnoreBeanInfo(environment);
    
    // 5. 打印 Banner
    Banner printedBanner = printBanner(environment);
    
    // 6. 创建 ApplicationContext
    context = createApplicationContext();
    
    // 7. 准备上下文
    prepareContext(context, environment, 
        listeners, bootstrapContext, printedBanner);
    
    // 8. 刷新上下文
    refreshContext(context);
    
    // 9. 执行 Runner
    afterRefresh(context, applicationArguments);
    
    // 10. 发布启动完成事件
    listeners.started(context);
    
    // 11. 调用 Runner
    callRunners(context, applicationArguments);
    
    return context;
}
```

**扩展点：**
```java
// ApplicationRunner 和 CommandLineRunner
@Component
public class MyRunner implements ApplicationRunner {
    @Override
    public void run(ApplicationArguments args) {
        // 应用启动后执行
    }
}

// ApplicationContextInitializer
public class MyInitializer 
    implements ApplicationContextInitializer<ConfigurableApplicationContext> {
    @Override
    public void initialize(
        ConfigurableApplicationContext context) {
        // 上下文初始化前执行
    }
}
```

---

## 5. Spring Boot 配置文件优先级？

**题目：**
Spring Boot 的配置文件有哪些？它们的优先级顺序是什么？

**答案：**
**配置文件类型：**
- `application.properties`
- `application.yml` / `application.yaml`
- `application-{profile}.properties`

**配置文件位置（优先级从高到低）：**
```
1. 当前项目根目录的 /config 目录
2. 当前项目根目录
3. 类路径的 /config 目录
4. 类路径根目录
```

**配置文件优先级顺序：**
```
1. 命令行参数（最高优先级）
   --spring.config.location=/path/to/config/

2. 操作系统环境变量
   SPRING_APPLICATION_JSON

3. Java 系统属性
   -Dspring.config.location=/path/

4. jar 包外的 application-{profile}.yml
   /config/application-{profile}.yml

5. jar 包内的 application-{profile}.yml

6. jar 包外的 application.yml
   /config/application.yml

7. jar 包内的 application.yml（最低优先级）

8. 默认值（最低）
```

**profile 特定的配置文件：**
```properties
# application-dev.properties（开发环境）
spring.datasource.url=jdbc:mysql://localhost:3306/dev
server.port=8080

# application-prod.properties（生产环境）
spring.datasource.url=jdbc:mysql://prod:3306/prod
server.port=80

# 激活 profile
# 命令行：--spring.profiles.active=prod
# 配置：spring.profiles.active=dev
```

**配置属性占位符：**
```properties
# 随机值
app.secret=${random.value}
app.number=${random.int}

# 引用其他配置
app.name=${APP_NAME:默认值}

# 多文档配置（YAML）
spring:
  config:
    activate:
      on-profile: "dev"
---
spring:
  config:
    activate:
      on-profile: "prod"
```

---

## 6. Spring Boot 日志配置？

**题目：**
Spring Boot 如何配置日志？有哪些日志框架？

**答案：**
**Spring Boot 日志框架：**
Spring Boot 默认使用 **SLF4J + Logback** 作为日志框架。

**日志级别：**
```
TRACE < DEBUG < INFO < WARN < ERROR < FATAL < OFF
```

**配置文件方式：**
```properties
# application.properties
logging.level.root=INFO
logging.level.com.example=DEBUG
logging.level.org.springframework=WARN

# 日志文件
logging.file.name=app.log
logging.file.max-size=10MB
logging.file.max-history=30

# 格式
logging.pattern.console=%d{yyyy-MM-dd HH:mm:ss} -%msg%n
```

```yaml
# application.yml
logging:
  level:
    root: INFO
    com.example: DEBUG
    org.springframework: DEBUG
  file:
    name: app.log
  pattern:
    console: "%d{yyyy-MM-dd HH:mm:ss} -%msg%n"
```

**Logback 详细配置（logback-spring.xml）：**
```xml
<?xml version="1.0" encoding="UTF-8"?>
<configuration>
    <!-- 定义日志文件位置 -->
    <property name="LOG_PATH" value="./logs"/>
    
    <!-- 控制台输出 -->
    <appender name="CONSOLE" 
              class="ch.qos.logback.core.ConsoleAppender">
        <encoder>
            <pattern>%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n</pattern>
        </encoder>
    </appender>
    
    <!-- 文件输出 -->
    <appender name="FILE" 
              class="ch.qos.logback.core.rolling.RollingFileAppender">
        <file>${LOG_PATH}/app.log</file>
        <rollingPolicy 
            class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <fileNamePattern>${LOG_PATH}/app.%d{yyyy-MM-dd}.log</fileNamePattern>
            <maxHistory>30</maxHistory>
        </rollingPolicy>
        <encoder>
            <pattern>%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n</pattern>
        </encoder>
    </appender>
    
    <!-- 异步输出 -->
    <appender name="ASYNC_FILE" 
              class="ch.qos.logback.classic.AsyncAppender">
        <appender-ref ref="FILE"/>
        <queueSize>512</queueSize>
        <discardingThreshold>0</discardingThreshold>
    </appender>
    
    <!-- 日志级别 -->
    <root level="INFO">
        <appender-ref ref="CONSOLE"/>
        <appender-ref ref="ASYNC_FILE"/>
    </root>
    
    <!-- 特定包日志级别 -->
    <logger name="com.example.dao" level="DEBUG"/>
</configuration>
```

**在代码中使用：**
```java
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

@Service
public class UserService {
    private static final Logger logger = 
        LoggerFactory.getLogger(UserService.class);
    
    public void addUser(User user) {
        logger.debug("添加用户: {}", user);
        logger.info("用户添加成功: {}", user.getName());
        logger.error("用户添加失败", e);
    }
}
```

---

## 7. Spring Boot 常用注解？

**题目：**
Spring Boot 有哪些常用注解？请举例说明。

**答案：**
**Spring Boot 核心注解：**

| 注解 | 说明 | 示例 |
|------|------|------|
| **@SpringBootApplication** | Spring Boot 启动注解 | 主类 |
| **@Configuration** | 配置类 | @Configuration |
| **@Bean** | 定义 Bean | @Bean |
| **@ComponentScan** | 组件扫描 | 自动扫描 |
| **@EnableAutoConfiguration** | 开启自动配置 | 内部使用 |

**Spring MVC 注解：**

| 注解 | 说明 | 示例 |
|------|------|------|
| **@Controller** | 控制器 | 页面控制器 |
| **@RestController** | REST 控制器 | API 接口 |
| **@RequestMapping** | 请求映射 | @RequestMapping("/api") |
| **@GetMapping** | GET 请求 | @GetMapping("/users") |
| **@PostMapping** | POST 请求 | @PostMapping("/users") |
| **@RequestBody** | 请求体绑定 | @RequestBody User user |
| **@ResponseBody** | 响应体返回 | 直接返回 JSON |
| **@PathVariable** | 路径变量 | @PathVariable Long id |
| **@RequestParam** | 请求参数 | @RequestParam String name |

**Spring IOC 注解：**

| 注解 | 说明 | 示例 |
|------|------|------|
| **@Component** | 通用组件 | @Component |
| **@Service** | 服务层 | @Service |
| **@Repository** | 数据访问层 | @Repository |
| **@Autowired** | 自动注入 | @Autowired |
| **@Qualifier** | 指定 Bean 名称 | @Qualifier("userService") |
| **@Resource** | Java 标准注入 | @Resource |
| **@Value** | 注入配置值 | @Value("${server.port}") |
| **@ConfigurationProperties** | 配置属性绑定 | @ConfigurationProperties(prefix = "db") |

**使用示例：**
```java
// Controller
@RestController
@RequestMapping("/users")
public class UserController {
    
    @Autowired
    private UserService userService;
    
    @GetMapping("/{id}")
    public User getUser(@PathVariable Long id) {
        return userService.findById(id);
    }
    
    @PostMapping
    public User createUser(@RequestBody @Valid User user) {
        return userService.save(user);
    }
}

// Service
@Service
public class UserService {
    
    @Autowired
    private UserRepository userRepository;
    
    @Value("${server.port}")
    private int port;
    
    @Transactional
    public User save(User user) {
        return userRepository.save(user);
    }
}

// Component
@Component
@ConfigurationProperties(prefix = "redis")
public class RedisProperties {
    private String host;
    private int port;
    
    // getters and setters
}

// Repository
@Repository
public interface UserRepository 
    extends JpaRepository<User, Long> {
    
    @Query("SELECT u FROM User u WHERE u.name = :name")
    User findByName(@Param("name") String name);
}
```

---

## 8. Spring Boot 数据访问？

**题目：**
Spring Boot 如何连接数据库？有哪些数据访问方式？

**答案：**
**数据访问配置：**
```properties
# application.properties
spring.datasource.url=jdbc:mysql://localhost:3306/mydb
spring.datasource.username=root
spring.datasource.password=123456
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver

# 连接池
spring.datasource.hikari.maximum-pool-size=10
spring.datasource.hikari.minimum-idle=5

# JPA/Hibernate
spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.format_sql=true
```

**Spring Data JPA：**
```java
// 实体类
@Entity
@Table(name = "users")
public class User {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(nullable = false, length = 50)
    private String name;
    
    @Column(unique = true)
    private String email;
    
    // getters and setters
}

// Repository
public interface UserRepository 
    extends JpaRepository<User, Long> {
    
    // 方法命名查询
    User findByEmail(String email);
    
    List<User> findByNameContaining(String name);
    
    // JPQL 查询
    @Query("SELECT u FROM User u WHERE u.name = :name")
    User findByNameJPQL(@Param("name") String name);
    
    // 原生 SQL 查询
    @Query(value = "SELECT * FROM users WHERE name = :name", 
           nativeQuery = true)
    User findByNameSQL(@Param("name") String name);
    
    // 分页查询
    Page<User> findByAgeGreaterThan(int age, Pageable pageable);
}

// Service
@Service
@Transactional
public class UserService {
    
    @Autowired
    private UserRepository userRepository;
    
    public User save(User user) {
        return userRepository.save(user);
    }
    
    public Optional<User> findById(Long id) {
        return userRepository.findById(id);
    }
    
    public Page<User> findAll(Pageable pageable) {
        return userRepository.findAll(pageable);
    }
}

// Controller
@RestController
@RequestMapping("/users")
public class UserController {
    
    @Autowired
    private UserService userService;
    
    @GetMapping
    public Page<User> list(Pageable pageable) {
        return userService.findAll(pageable);
    }
}
```

**多数据源配置：**
```java
// 主数据源
@Configuration
@Primary
@EnableJpaRepositories(
    basePackages = "com.example.repository.primary",
    entityManagerFactoryRef = "primaryEntityManager",
    transactionManagerRef = "primaryTransactionManager"
)
public class PrimaryDataSourceConfig {
    
    @Bean
    @Primary
    @ConfigurationProperties(prefix = "spring.datasource.primary")
    public DataSource primaryDataSource() {
        return DataSourceBuilder.create().build();
    }
    
    // EntityManagerFactory 和 TransactionManager 配置...
}

// 从数据源
@Configuration
@EnableJpaRepositories(
    basePackages = "com.example.repository.secondary",
    entityManagerFactoryRef = "secondaryEntityManager",
    transactionManagerRef = "secondaryTransactionManager"
)
public class SecondaryDataSourceConfig {
    // 类似配置...
}
```

---

## 9. Spring Boot 异常处理？

**题目：**
Spring Boot 如何处理全局异常？

**答案：**
**全局异常处理：**
```java
@ControllerAdvice
public class GlobalExceptionHandler {
    
    private static final Logger logger = 
        LoggerFactory.getLogger(GlobalExceptionHandler.class);
    
    // 处理参数校验异常
    @ExceptionHandler(MethodArgumentNotValidException.class)
    @ResponseBody
    public Result<Void> handleValidationException(
            MethodArgumentNotValidException e) {
        BindingResult bindingResult = e.getBindingResult();
        String message = bindingResult.getFieldErrors().stream()
            .map(FieldError::getDefaultMessage)
            .collect(Collectors.joining(", "));
        return Result.error(message);
    }
    
    // 处理业务异常
    @ExceptionHandler(BusinessException.class)
    @ResponseBody
    public Result<Void> handleBusinessException(
            BusinessException e) {
        logger.warn("业务异常: {}", e.getMessage());
        return Result.error(e.getMessage());
    }
    
    // 处理其他异常
    @ExceptionHandler(Exception.class)
    @ResponseBody
    public Result<Void> handleException(Exception e) {
        logger.error("系统异常", e);
        return Result.error("系统繁忙，请稍后重试");
    }
    
    // 404 处理
    @ExceptionHandler(NoHandlerFoundException.class)
    @ResponseBody
    public Result<Void> handle404(
            NoHandlerFoundException e) {
        return Result.error("请求的资源不存在");
    }
}
```

**统一响应结果：**
```java
@Data
@NoArgsConstructor
@AllArgsConstructor
public class Result<T> {
    private int code;
    private String message;
    private T data;
    
    public static <T> Result<T> success(T data) {
        return new Result<>(200, "success", data);
    }
    
    public static <T> Result<T> success() {
        return new Result<>(200, "success", null);
    }
    
    public static <T> Result<T> error(String message) {
        return new Result<>(500, message, null);
    }
    
    public static <T> Result<T> error(int code, String message) {
        return new Result<>(code, message, null);
    }
}
```

**自定义业务异常：**
```java
@Data
public class BusinessException extends RuntimeException {
    private int code;
    
    public BusinessException(String message) {
        super(message);
        this.code = 500;
    }
    
    public BusinessException(int code, String message) {
        super(message);
        this.code = code;
    }
}
```

---

## 10. Spring Boot 拦截器和过滤器？

**题目：**
Spring Boot 中的拦截器和过滤器有什么区别？如何使用？

**答案：**
**Filter（过滤器）：**
- Servlet 规范的一部分
- 在请求到达 DispatcherServlet 之前执行
- 可以过滤所有请求（包括静态资源）

**HandlerInterceptor（拦截器）：**
- Spring MVC 的一部分
- 在请求到达 Controller 之前执行
- 可以访问 HandlerMethod 和 HandlerExecutionChain

**Filter 使用：**
```java
// 方式1：使用 @WebFilter 注解
@WebFilter(urlPatterns = "/*")
public class TimeFilter implements Filter {
    
    @Override
    public void doFilter(ServletRequest request, 
                        ServletResponse response,
                        FilterChain chain) 
            throws IOException, ServletException {
        long start = System.currentTimeMillis();
        
        chain.doFilter(request, response);
        
        long time = System.currentTimeMillis() - start;
        System.out.println("请求耗时: " + time + "ms");
    }
}

// 方式2：使用 FilterRegistrationBean
@Configuration
public class FilterConfig {
    
    @Bean
    public FilterRegistrationBean<TimeFilter> timeFilter() {
        FilterRegistrationBean<TimeFilter> registration = 
            new FilterRegistrationBean<>();
        registration.setFilter(new TimeFilter());
        registration.addUrlPatterns("/*");
        registration.setOrder(1);
        return registration;
    }
}
```

**Interceptor 使用：**
```java
// 1. 创建拦截器
@Component
public class LoginInterceptor implements HandlerInterceptor {
    
    @Override
    public boolean preHandle(HttpServletRequest request,
                           HttpServletResponse response,
                           Object handler) throws Exception {
        // 检查用户是否登录
        Object user = request.getSession().getAttribute("user");
        if (user == null) {
            response.sendRedirect("/login");
            return false;
        }
        return true;
    }
    
    @Override
    public void postHandle(HttpServletRequest request,
                          HttpServletResponse response,
                          Object handler,
                          ModelAndView modelAndView) throws Exception {
        // Controller 方法执行后，视图渲染前
    }
    
    @Override
    public void afterCompletion(HttpServletRequest request,
                               HttpServletResponse response,
                               Object handler,
                               Exception ex) throws Exception {
        // 请求完成后（视图渲染后）
    }
}

// 2. 注册拦截器
@Configuration
public class WebConfig implements WebMvcConfigurer {
    
    @Autowired
    private LoginInterceptor loginInterceptor;
    
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(loginInterceptor)
            .addPathPatterns("/api/**")  // 拦截的路径
            .excludePathPatterns("/api/login", 
                                "/api/register");  // 排除的路径
    }
}
```

**执行顺序：**
```
Filter → Interceptor.preHandle → Controller → 
Interceptor.postHandle → Interceptor.afterCompletion → View
```

---

*更多 Spring Boot 面试题请查看答案文件*

## 答案

**题目：**
Spring Boot 是什么？它有什么特点？

**答案：**
**Spring Boot 定义：**
Spring Boot 是 Spring 框架的子项目，旨在简化 Spring 应用的创建和开发过程。它提供了自动配置、起步依赖等特性，让开发者可以快速搭建生产级别的 Spring 应用。

**核心特点：**
| 特性 | 说明 |
|------|------|
| **自动配置** | 根据类路径和配置自动配置 Spring 应用 |
| **起步依赖** | 打包好的依赖集合，简化 Maven/Gradle 配置 |
| **内嵌服务器** | 内嵌 Tomcat、Jetty、Undertow，无需部署 WAR |
| **Actuator** | 提供生产级别的监控和管理功能 |
| **无代码生成** | 不需要 XML 配置，通过注解和配置实现 |
| **约定优于配置** | 提供合理的默认配置，快速开发 |

**Spring Boot 的优势：**
```java
// 传统 Spring MVC 项目需要大量配置
// 1. 配置 DispatcherServlet
// 2. 配置 ViewResolver
// 3. 配置组件扫描
// 4. 配置数据源
// 5. 配置事务管理
// ... 等等

// Spring Boot 只需要一个启动类
@SpringBootApplication
public class Application {
    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }
}
```

---

## 2. @SpringBootApplication 注解的作用？

**题目：**
@SpringBootApplication 注解是什么？它包含哪些注解？

**答案：**
**@SpringBootApplication 定义：**
这是 Spring Boot 应用的启动注解，通常放在主类上。它是一个组合注解，包含三个核心注解。

**注解组成：**
```java
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Configuration  // 1. 标记为配置类
@EnableAutoConfiguration  // 2. 开启自动配置
@ComponentScan  // 3. 组件扫描
public @interface SpringBootApplication {
    // ... 属性配置
}
```

**各注解作用：**
1. **@Configuration**
   - 标记类为 Spring 配置类
   - 可以使用 @Bean 定义 Bean

2. **@EnableAutoConfiguration**
   - 启用 Spring Boot 的自动配置机制
   - 根据类路径中的依赖自动配置 Spring 应用
   - 例如：检测到 Spring Data JPA，自动配置 JPA 相关 Bean

3. **@ComponentScan**
   - 自动扫描当前包及其子包中的 @Component、@Service、@Repository、@Controller 等注解
   - 默认扫描主类所在包及其子包

**排除特定自动配置：**
```java
// 方式1：排除某个自动配置
@SpringBootApplication(exclude = {DataSourceAutoConfiguration.class})

// 方式2：通过配置文件排除
// spring.autoconfigure.exclude=org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration
```

---

## 3. Spring Boot 自动配置原理？

**题目：**
Spring Boot 的自动配置是如何实现的？

**答案：**
**自动配置核心原理：**
Spring Boot 自动配置基于 `@EnableAutoConfiguration` 注解，通过 `SpringFactoriesLoader` 加载类路径下的 `META-INF/spring.factories` 文件。

**实现步骤：**
```java
// 1. @EnableAutoConfiguration 注解
@Import(AutoConfigurationImportSelector.class)
public @interface EnableAutoConfiguration {
    // ...
}

// 2. AutoConfigurationImportSelector 实现
public class AutoConfigurationImportSelector 
    implements ImportSelector, BeanClassLoaderAware {
    
    // 加载 META-INF/spring.factories
    protected List<String> getCandidateConfigurations() {
        return SpringFactoriesLoader.loadFactoryNames(
            getSpringFactoriesLoaderFactoryClass(), 
            getBeanClassLoader()
        );
    }
}
```

**自动配置过程：**
```
1. Spring Boot 启动
   ↓
2. @SpringBootApplication → @EnableAutoConfiguration
   ↓
3. 加载 spring.factories 文件
   ↓
4. 获取所有自动配置类列表
   ↓
5. 按条件过滤（@Conditional 注解）
   ↓
6. 加载符合条件的自动配置类
   ↓
7. 配置相应的 Bean
```

**@Conditional 条件注解：**
```java
// @ConditionalOnClass - 类路径存在时才配置
@Configuration
@ConditionalOnClass(DataSource.class)
public class DataSourceAutoConfiguration {
    // ...
}

// @ConditionalOnMissingClass - 类路径不存在时才配置
@ConditionalOnMissingClass("com.example.OldClass")
public class NewClassAutoConfiguration {
    // ...
}

// @ConditionalOnBean - 容器中存在某个 Bean 时才配置
@ConditionalOnBean(DataSource.class)
public class JdbcTemplateAutoConfiguration {
    // ...
}

// @ConditionalOnProperty - 配置属性满足条件时才配置
@ConditionalOnProperty(prefix = "spring.datasource", name = "url")
public class DataSourceProperties {
    // ...
}
```

---

## 4. Spring Boot 启动流程？

**题目：**
Spring Boot 应用是如何启动的？请描述其启动流程。

**答案：**
**SpringApplication 启动流程：**
```java
public static void main(String[] args) {
    SpringApplication.run(Application.class, args);
}
```

**详细启动步骤：**
```
1. 创建 SpringApplication 对象
   ├── 推断应用类型（WebApplicationType）
   ├── 设置 ApplicationContextInitializer
   ├── 设置 ApplicationListener
   └── 推断主类（Main Class）

2. 执行 run() 方法
   ├── 准备环境（ConfigurableEnvironment）
   ├── 配置 Spring 上下文
   ├── 刷新上下文
   └── 执行 Runner
```

**源码流程：**
```java
public ConfigurableApplicationContext run(String... args) {
    // 1. 创建启动计时器
    StopWatch stopWatch = new StopWatch();
    stopWatch.start();
    
    // 2. 创建引导上下文（Bootstrap Context）
    DefaultBootstrapContext bootstrapContext = 
        createBootstrapContext();
    
    // 3. 配置环境
    ConfigurableEnvironment environment = 
        prepareEnvironment(listeners, bootstrapContext);
    
    // 4. 配置忽略的 Bean
    configureIgnoreBeanInfo(environment);
    
    // 5. 打印 Banner
    Banner printedBanner = printBanner(environment);
    
    // 6. 创建 ApplicationContext
    context = createApplicationContext();
    
    // 7. 准备上下文
    prepareContext(context, environment, 
        listeners, bootstrapContext, printedBanner);
    
    // 8. 刷新上下文
    refreshContext(context);
    
    // 9. 执行 Runner
    afterRefresh(context, applicationArguments);
    
    // 10. 发布启动完成事件
    listeners.started(context);
    
    // 11. 调用 Runner
    callRunners(context, applicationArguments);
    
    return context;
}
```

**扩展点：**
```java
// ApplicationRunner 和 CommandLineRunner
@Component
public class MyRunner implements ApplicationRunner {
    @Override
    public void run(ApplicationArguments args) {
        // 应用启动后执行
    }
}

// ApplicationContextInitializer
public class MyInitializer 
    implements ApplicationContextInitializer<ConfigurableApplicationContext> {
    @Override
    public void initialize(
        ConfigurableApplicationContext context) {
        // 上下文初始化前执行
    }
}
```

---

## 5. Spring Boot 配置文件优先级？

**题目：**
Spring Boot 的配置文件有哪些？它们的优先级顺序是什么？

**答案：**
**配置文件类型：**
- `application.properties`
- `application.yml` / `application.yaml`
- `application-{profile}.properties`

**配置文件位置（优先级从高到低）：**
```
1. 当前项目根目录的 /config 目录
2. 当前项目根目录
3. 类路径的 /config 目录
4. 类路径根目录
```

**配置文件优先级顺序：**
```
1. 命令行参数（最高优先级）
   --spring.config.location=/path/to/config/

2. 操作系统环境变量
   SPRING_APPLICATION_JSON

3. Java 系统属性
   -Dspring.config.location=/path/

4. jar 包外的 application-{profile}.yml
   /config/application-{profile}.yml

5. jar 包内的 application-{profile}.yml

6. jar 包外的 application.yml
   /config/application.yml

7. jar 包内的 application.yml（最低优先级）

8. 默认值（最低）
```

**profile 特定的配置文件：**
```properties
# application-dev.properties（开发环境）
spring.datasource.url=jdbc:mysql://localhost:3306/dev
server.port=8080

# application-prod.properties（生产环境）
spring.datasource.url=jdbc:mysql://prod:3306/prod
server.port=80

# 激活 profile
# 命令行：--spring.profiles.active=prod
# 配置：spring.profiles.active=dev
```

**配置属性占位符：**
```properties
# 随机值
app.secret=${random.value}
app.number=${random.int}

# 引用其他配置
app.name=${APP_NAME:默认值}

# 多文档配置（YAML）
spring:
  config:
    activate:
      on-profile: "dev"
---
spring:
  config:
    activate:
      on-profile: "prod"
```

---

## 6. Spring Boot 日志配置？

**题目：**
Spring Boot 如何配置日志？有哪些日志框架？

**答案：**
**Spring Boot 日志框架：**
Spring Boot 默认使用 **SLF4J + Logback** 作为日志框架。

**日志级别：**
```
TRACE < DEBUG < INFO < WARN < ERROR < FATAL < OFF
```

**配置文件方式：**
```properties
# application.properties
logging.level.root=INFO
logging.level.com.example=DEBUG
logging.level.org.springframework=WARN

# 日志文件
logging.file.name=app.log
logging.file.max-size=10MB
logging.file.max-history=30

# 格式
logging.pattern.console=%d{yyyy-MM-dd HH:mm:ss} -%msg%n
```

```yaml
# application.yml
logging:
  level:
    root: INFO
    com.example: DEBUG
    org.springframework: DEBUG
  file:
    name: app.log
  pattern:
    console: "%d{yyyy-MM-dd HH:mm:ss} -%msg%n"
```

**Logback 详细配置（logback-spring.xml）：**
```xml
<?xml version="1.0" encoding="UTF-8"?>
<configuration>
    <!-- 定义日志文件位置 -->
    <property name="LOG_PATH" value="./logs"/>
    
    <!-- 控制台输出 -->
    <appender name="CONSOLE" 
              class="ch.qos.logback.core.ConsoleAppender">
        <encoder>
            <pattern>%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n</pattern>
        </encoder>
    </appender>
    
    <!-- 文件输出 -->
    <appender name="FILE" 
              class="ch.qos.logback.core.rolling.RollingFileAppender">
        <file>${LOG_PATH}/app.log</file>
        <rollingPolicy 
            class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <fileNamePattern>${LOG_PATH}/app.%d{yyyy-MM-dd}.log</fileNamePattern>
            <maxHistory>30</maxHistory>
        </rollingPolicy>
        <encoder>
            <pattern>%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n</pattern>
        </encoder>
    </appender>
    
    <!-- 异步输出 -->
    <appender name="ASYNC_FILE" 
              class="ch.qos.logback.classic.AsyncAppender">
        <appender-ref ref="FILE"/>
        <queueSize>512</queueSize>
        <discardingThreshold>0</discardingThreshold>
    </appender>
    
    <!-- 日志级别 -->
    <root level="INFO">
        <appender-ref ref="CONSOLE"/>
        <appender-ref ref="ASYNC_FILE"/>
    </root>
    
    <!-- 特定包日志级别 -->
    <logger name="com.example.dao" level="DEBUG"/>
</configuration>
```

**在代码中使用：**
```java
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

@Service
public class UserService {
    private static final Logger logger = 
        LoggerFactory.getLogger(UserService.class);
    
    public void addUser(User user) {
        logger.debug("添加用户: {}", user);
        logger.info("用户添加成功: {}", user.getName());
        logger.error("用户添加失败", e);
    }
}
```

---

## 7. Spring Boot 常用注解？

**题目：**
Spring Boot 有哪些常用注解？请举例说明。

**答案：**
**Spring Boot 核心注解：**

| 注解 | 说明 | 示例 |
|------|------|------|
| **@SpringBootApplication** | Spring Boot 启动注解 | 主类 |
| **@Configuration** | 配置类 | @Configuration |
| **@Bean** | 定义 Bean | @Bean |
| **@ComponentScan** | 组件扫描 | 自动扫描 |
| **@EnableAutoConfiguration** | 开启自动配置 | 内部使用 |

**Spring MVC 注解：**

| 注解 | 说明 | 示例 |
|------|------|------|
| **@Controller** | 控制器 | 页面控制器 |
| **@RestController** | REST 控制器 | API 接口 |
| **@RequestMapping** | 请求映射 | @RequestMapping("/api") |
| **@GetMapping** | GET 请求 | @GetMapping("/users") |
| **@PostMapping** | POST 请求 | @PostMapping("/users") |
| **@RequestBody** | 请求体绑定 | @RequestBody User user |
| **@ResponseBody** | 响应体返回 | 直接返回 JSON |
| **@PathVariable** | 路径变量 | @PathVariable Long id |
| **@RequestParam** | 请求参数 | @RequestParam String name |

**Spring IOC 注解：**

| 注解 | 说明 | 示例 |
|------|------|------|
| **@Component** | 通用组件 | @Component |
| **@Service** | 服务层 | @Service |
| **@Repository** | 数据访问层 | @Repository |
| **@Autowired** | 自动注入 | @Autowired |
| **@Qualifier** | 指定 Bean 名称 | @Qualifier("userService") |
| **@Resource** | Java 标准注入 | @Resource |
| **@Value** | 注入配置值 | @Value("${server.port}") |
| **@ConfigurationProperties** | 配置属性绑定 | @ConfigurationProperties(prefix = "db") |

**使用示例：**
```java
// Controller
@RestController
@RequestMapping("/users")
public class UserController {
    
    @Autowired
    private UserService userService;
    
    @GetMapping("/{id}")
    public User getUser(@PathVariable Long id) {
        return userService.findById(id);
    }
    
    @PostMapping
    public User createUser(@RequestBody @Valid User user) {
        return userService.save(user);
    }
}

// Service
@Service
public class UserService {
    
    @Autowired
    private UserRepository userRepository;
    
    @Value("${server.port}")
    private int port;
    
    @Transactional
    public User save(User user) {
        return userRepository.save(user);
    }
}

// Component
@Component
@ConfigurationProperties(prefix = "redis")
public class RedisProperties {
    private String host;
    private int port;
    
    // getters and setters
}

// Repository
@Repository
public interface UserRepository 
    extends JpaRepository<User, Long> {
    
    @Query("SELECT u FROM User u WHERE u.name = :name")
    User findByName(@Param("name") String name);
}
```

---

## 8. Spring Boot 数据访问？

**题目：**
Spring Boot 如何连接数据库？有哪些数据访问方式？

**答案：**
**数据访问配置：**
```properties
# application.properties
spring.datasource.url=jdbc:mysql://localhost:3306/mydb
spring.datasource.username=root
spring.datasource.password=123456
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver

# 连接池
spring.datasource.hikari.maximum-pool-size=10
spring.datasource.hikari.minimum-idle=5

# JPA/Hibernate
spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.format_sql=true
```

**Spring Data JPA：**
```java
// 实体类
@Entity
@Table(name = "users")
public class User {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(nullable = false, length = 50)
    private String name;
    
    @Column(unique = true)
    private String email;
    
    // getters and setters
}

// Repository
public interface UserRepository 
    extends JpaRepository<User, Long> {
    
    // 方法命名查询
    User findByEmail(String email);
    
    List<User> findByNameContaining(String name);
    
    // JPQL 查询
    @Query("SELECT u FROM User u WHERE u.name = :name")
    User findByNameJPQL(@Param("name") String name);
    
    // 原生 SQL 查询
    @Query(value = "SELECT * FROM users WHERE name = :name", 
           nativeQuery = true)
    User findByNameSQL(@Param("name") String name);
    
    // 分页查询
    Page<User> findByAgeGreaterThan(int age, Pageable pageable);
}

// Service
@Service
@Transactional
public class UserService {
    
    @Autowired
    private UserRepository userRepository;
    
    public User save(User user) {
        return userRepository.save(user);
    }
    
    public Optional<User> findById(Long id) {
        return userRepository.findById(id);
    }
    
    public Page<User> findAll(Pageable pageable) {
        return userRepository.findAll(pageable);
    }
}

// Controller
@RestController
@RequestMapping("/users")
public class UserController {
    
    @Autowired
    private UserService userService;
    
    @GetMapping
    public Page<User> list(Pageable pageable) {
        return userService.findAll(pageable);
    }
}
```

**多数据源配置：**
```java
// 主数据源
@Configuration
@Primary
@EnableJpaRepositories(
    basePackages = "com.example.repository.primary",
    entityManagerFactoryRef = "primaryEntityManager",
    transactionManagerRef = "primaryTransactionManager"
)
public class PrimaryDataSourceConfig {
    
    @Bean
    @Primary
    @ConfigurationProperties(prefix = "spring.datasource.primary")
    public DataSource primaryDataSource() {
        return DataSourceBuilder.create().build();
    }
    
    // EntityManagerFactory 和 TransactionManager 配置...
}

// 从数据源
@Configuration
@EnableJpaRepositories(
    basePackages = "com.example.repository.secondary",
    entityManagerFactoryRef = "secondaryEntityManager",
    transactionManagerRef = "secondaryTransactionManager"
)
public class SecondaryDataSourceConfig {
    // 类似配置...
}
```

---

## 9. Spring Boot 异常处理？

**题目：**
Spring Boot 如何处理全局异常？

**答案：**
**全局异常处理：**
```java
@ControllerAdvice
public class GlobalExceptionHandler {
    
    private static final Logger logger = 
        LoggerFactory.getLogger(GlobalExceptionHandler.class);
    
    // 处理参数校验异常
    @ExceptionHandler(MethodArgumentNotValidException.class)
    @ResponseBody
    public Result<Void> handleValidationException(
            MethodArgumentNotValidException e) {
        BindingResult bindingResult = e.getBindingResult();
        String message = bindingResult.getFieldErrors().stream()
            .map(FieldError::getDefaultMessage)
            .collect(Collectors.joining(", "));
        return Result.error(message);
    }
    
    // 处理业务异常
    @ExceptionHandler(BusinessException.class)
    @ResponseBody
    public Result<Void> handleBusinessException(
            BusinessException e) {
        logger.warn("业务异常: {}", e.getMessage());
        return Result.error(e.getMessage());
    }
    
    // 处理其他异常
    @ExceptionHandler(Exception.class)
    @ResponseBody
    public Result<Void> handleException(Exception e) {
        logger.error("系统异常", e);
        return Result.error("系统繁忙，请稍后重试");
    }
    
    // 404 处理
    @ExceptionHandler(NoHandlerFoundException.class)
    @ResponseBody
    public Result<Void> handle404(
            NoHandlerFoundException e) {
        return Result.error("请求的资源不存在");
    }
}
```

**统一响应结果：**
```java
@Data
@NoArgsConstructor
@AllArgsConstructor
public class Result<T> {
    private int code;
    private String message;
    private T data;
    
    public static <T> Result<T> success(T data) {
        return new Result<>(200, "success", data);
    }
    
    public static <T> Result<T> success() {
        return new Result<>(200, "success", null);
    }
    
    public static <T> Result<T> error(String message) {
        return new Result<>(500, message, null);
    }
    
    public static <T> Result<T> error(int code, String message) {
        return new Result<>(code, message, null);
    }
}
```

**自定义业务异常：**
```java
@Data
public class BusinessException extends RuntimeException {
    private int code;
    
    public BusinessException(String message) {
        super(message);
        this.code = 500;
    }
    
    public BusinessException(int code, String message) {
        super(message);
        this.code = code;
    }
}
```

---

## 10. Spring Boot 拦截器和过滤器？

**题目：**
Spring Boot 中的拦截器和过滤器有什么区别？如何使用？

**答案：**
**Filter（过滤器）：**
- Servlet 规范的一部分
- 在请求到达 DispatcherServlet 之前执行
- 可以过滤所有请求（包括静态资源）

**HandlerInterceptor（拦截器）：**
- Spring MVC 的一部分
- 在请求到达 Controller 之前执行
- 可以访问 HandlerMethod 和 HandlerExecutionChain

**Filter 使用：**
```java
// 方式1：使用 @WebFilter 注解
@WebFilter(urlPatterns = "/*")
public class TimeFilter implements Filter {
    
    @Override
    public void doFilter(ServletRequest request, 
                        ServletResponse response,
                        FilterChain chain) 
            throws IOException, ServletException {
        long start = System.currentTimeMillis();
        
        chain.doFilter(request, response);
        
        long time = System.currentTimeMillis() - start;
        System.out.println("请求耗时: " + time + "ms");
    }
}

// 方式2：使用 FilterRegistrationBean
@Configuration
public class FilterConfig {
    
    @Bean
    public FilterRegistrationBean<TimeFilter> timeFilter() {
        FilterRegistrationBean<TimeFilter> registration = 
            new FilterRegistrationBean<>();
        registration.setFilter(new TimeFilter());
        registration.addUrlPatterns("/*");
        registration.setOrder(1);
        return registration;
    }
}
```

**Interceptor 使用：**
```java
// 1. 创建拦截器
@Component
public class LoginInterceptor implements HandlerInterceptor {
    
    @Override
    public boolean preHandle(HttpServletRequest request,
                           HttpServletResponse response,
                           Object handler) throws Exception {
        // 检查用户是否登录
        Object user = request.getSession().getAttribute("user");
        if (user == null) {
            response.sendRedirect("/login");
            return false;
        }
        return true;
    }
    
    @Override
    public void postHandle(HttpServletRequest request,
                          HttpServletResponse response,
                          Object handler,
                          ModelAndView modelAndView) throws Exception {
        // Controller 方法执行后，视图渲染前
    }
    
    @Override
    public void afterCompletion(HttpServletRequest request,
                               HttpServletResponse response,
                               Object handler,
                               Exception ex) throws Exception {
        // 请求完成后（视图渲染后）
    }
}

// 2. 注册拦截器
@Configuration
public class WebConfig implements WebMvcConfigurer {
    
    @Autowired
    private LoginInterceptor loginInterceptor;
    
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(loginInterceptor)
            .addPathPatterns("/api/**")  // 拦截的路径
            .excludePathPatterns("/api/login", 
                                "/api/register");  // 排除的路径
    }
}
```

**执行顺序：**
```
Filter → Interceptor.preHandle → Controller → 
Interceptor.postHandle → Interceptor.afterCompletion → View
```

---

## 11. Spring Boot AOP？

**题目：**
Spring Boot 如何使用 AOP？请举例说明。

**答案：**
**AOP 相关概念：**
- **切面（Aspect）**：横切关注点的模块化
- **切点（Pointcut）**：定义在哪些地方执行通知
- **通知（Advice）**：切面的具体行为
- **连接点（Join Point）**：程序执行的某个位置

**AOP 注解：**
| 注解 | 说明 |
|------|------|
| **@Aspect** | 标记为切面 |
| **@Pointcut** | 定义切点表达式 |
| **@Before** | 前置通知 |
| **@After** | 后置通知 |
| **@AfterReturning** | 返回通知 |
| **@AfterThrowing** | 异常通知 |
| **@Around** | 环绕通知 |

**使用示例：**
```java
// 1. 开启 AOP
@Configuration
@EnableAspectJAutoProxy
public class AopConfig {
    // 或者在主类上添加 @EnableAspectJAutoProxy
}

// 2. 创建切面
@Aspect
@Component
public class LogAspect {
    
    private static final Logger logger = 
        LoggerFactory.getLogger(LogAspect.class);
    
    // 定义切点：所有 Service 层的 public 方法
    @Pointcut("execution(public * com.example.service.*.*(..))")
    public void servicePointcut() {}
    
    // 前置通知
    @Before("servicePointcut()")
    public void beforeAdvice(JoinPoint joinPoint) {
        String methodName = joinPoint.getSignature().getName();
        Object[] args = joinPoint.getArgs();
        logger.info("方法执行前: {}({})", methodName, args);
    }
    
    // 后置通知
    @After("servicePointcut()")
    public void afterAdvice(JoinPoint joinPoint) {
        String methodName = joinPoint.getSignature().getName();
        logger.info("方法执行后: {}", methodName);
    }
    
    // 返回通知
    @AfterReturning(
        pointcut = "servicePointcut()",
        returning = "result"
    )
    public void afterReturningAdvice(
            JoinPoint joinPoint, Object result) {
        logger.info("方法返回: {} = {}", 
            joinPoint.getSignature().getName(), result);
    }
    
    // 异常通知
    @AfterThrowing(
        pointcut = "servicePointcut()",
        throwing = "ex"
    )
    public void afterThrowingAdvice(
            JoinPoint joinPoint, Exception ex) {
        logger.error("方法异常: {}", ex.getMessage());
    }
    
    // 环绕通知
    @Around("servicePointcut()")
    public Object aroundAdvice(ProceedingJoinPoint pjp) 
            throws Throwable {
        long start = System.currentTimeMillis();
        
        // 执行目标方法
        Object result = pjp.proceed();
        
        long time = System.currentTimeMillis() - start;
        logger.info("环绕通知 - 方法耗时: {}ms", time);
        
        return result;
    }
}
```

**切点表达式：**
```java
// 匹配所有方法
@Pointcut("execution(* *.*(..))")

// 匹配指定包下所有类的所有方法
@Pointcut("execution(* com.example.service.*.*(..))")

// 匹配指定包及其子包
@Pointcut("execution(* com.example..*.*(..))")

// 匹配以 Service 结尾的方法
@Pointcut("execution(* *Service.*(..))")

// 匹配 public 方法
@Pointcut("execution(public * *.*(..))")

// 匹配特定注解
@Pointcut("@annotation(org.springframework.transaction.annotation.Transactional)")
public void transactionalPointcut() {}
```

**基于注解的 AOP：**
```java
// 自定义注解
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface Loggable {
    String value() default "";
}

// 使用注解
@Service
public class UserService {
    
    @Loggable("保存用户")
    public User save(User user) {
        return userRepository.save(user);
    }
}

// 切面
@Aspect
@Component
public class AnnotationAspect {
    
    @Pointcut("@annotation(com.example.annotation.Loggable)")
    public void annotationPointcut() {}
    
    @Around("annotationPointcut()")
    public Object aroundAnnotation(
            ProceedingJoinPoint pjp) throws Throwable {
        MethodSignature signature = (MethodSignature) pjp.getSignature();
        Loggable loggable = signature.getMethod()
            .getAnnotation(Loggable.class);
        String operation = loggable.value();
        
        logger.info("执行操作: {}", operation);
        return pjp.proceed();
    }
}
```

---

## 12. Spring Boot 事务管理？

**题目：**
Spring Boot 如何管理事务？有哪些事务传播行为？

**答案：**
**事务配置：**
```java
// 方式1：使用 @EnableTransactionManagement
@Configuration
@EnableTransactionManagement
public class TransactionConfig {
    
    @Bean
    public PlatformTransactionManager 
            transactionManager(DataSource dataSource) {
        return new DataSourceTransactionManager(dataSource);
    }
}

// 方式2：Spring Boot 自动配置（推荐）
// 只需要引入 spring-boot-starter-data-jpa
// Spring Boot 会自动配置事务管理器
```

**@Transactional 注解：**
```java
@Service
@Transactional  // 类级别：所有方法都开启事务
public class UserService {
    
    @Autowired
    private UserRepository userRepository;
    
    @Transactional  // 方法级别：覆盖类级别配置
    public User save(User user) {
        return userRepository.save(user);
    }
    
    // 只读事务（优化性能）
    @Transactional(readOnly = true)
    public User findById(Long id) {
        return userRepository.findById(id).orElse(null);
    }
    
    // 指定回滚异常
    @Transactional(rollbackFor = BusinessException.class)
    public void businessOperation() {
        // ...
    }
    
    // 指定不回滚异常
    @Transactional(noRollbackFor = RuntimeException.class)
    public void noRollbackOperation() {
        // ...
    }
}
```

**事务传播行为：**
```java
// 7种事务传播行为
public enum Propagation {
    REQUIRED      // 默认：如果当前有事务，则加入；没有则创建（常用）
    SUPPORTS      // 如果当前有事务，则加入；没有则以非事务执行
    MANDATORY     // 必须在一个事务中，否则抛出异常
    REQUIRES_NEW  // 总是创建新事务，挂起当前事务
    NOT_SUPPORTED // 以非事务执行，挂起当前事务
    NEVER         // 以非事务执行，如果当前有事务则抛出异常
    NESTED        // 如果当前有事务，则在嵌套事务中执行；没有则创建
}
```

**使用示例：**
```java
@Service
public class OrderService {
    
    @Autowired
    private OrderRepository orderRepository;
    
    @Autowired
    private InventoryService inventoryService;
    
    @Autowired
    private PaymentService paymentService;
    
    @Transactional
    public void createOrder(Order order) {
        // 1. 保存订单
        orderRepository.save(order);
        
        // 2. 扣减库存（在同一个事务中）
        inventoryService.deduct(order.getItems());
        
        // 3. 支付（如果支付失败，整个事务回滚）
        paymentService.pay(order);
    }
}

@Service
public class InventoryService {
    
    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void deduct(List<OrderItem> items) {
        // 独立事务，即使外部事务回滚，这里也提交
        // 适用于：库存扣减失败不影响订单创建的场景
    }
}
```

**编程式事务：**
```java
@Service
public class UserService {
    
    @Autowired
    private PlatformTransactionManager 
            transactionManager;
    
    public void transfer(Long fromId, Long toId, BigDecimal amount) {
        // 1. 定义事务定义器
        DefaultTransactionDefinition definition = 
            new DefaultTransactionDefinition();
        definition.setPropagationBehavior(
            Propagation.REQUIRED.value());
        
        // 2. 开始事务
        TransactionStatus status = 
            transactionManager.getTransaction(definition);
        
        try {
            // 转出
            Account from = accountRepository.findById(fromId);
            from.setBalance(from.getBalance().subtract(amount));
            accountRepository.save(from);
            
            // 转入
            Account to = accountRepository.findById(toId);
            to.setBalance(to.getBalance().add(amount));
            accountRepository.save(to);
            
            // 3. 提交事务
            transactionManager.commit(status);
        } catch (Exception e) {
            // 4. 回滚事务
            transactionManager.rollback(status);
            throw e;
        }
    }
}
```

---

## 13. Spring Boot 定时任务？

**题目：**
Spring Boot 如何实现定时任务？

**答案：**
**开启定时任务：**
```java
@SpringBootApplication
@EnableScheduling  // 开启定时任务功能
public class Application {
    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }
}
```

**@Scheduled 注解：**
```java
@Component
public class ScheduledTasks {
    
    private static final Logger logger = 
        LoggerFactory.getLogger(ScheduledTasks.class);
    
    // 1. cron 表达式：每秒执行
    @Scheduled(cron = "* * * * * ?")
    public void everySecond() {
        logger.info("每秒钟执行一次");
    }
    
    // 2. cron 表达式：每5分钟执行
    @Scheduled(cron = "0 0/5 * * * ?")
    public void everyFiveMinutes() {
        logger.info("每5分钟执行一次");
    }
    
    // 3. cron 表达式：每天凌晨2点执行
    @Scheduled(cron = "0 0 2 * * ?")
    public void everyDayAt2AM() {
        logger.info("每天凌晨2点执行");
    }
    
    // 4. 固定频率：每隔3秒执行（从任务开始计算）
    @Scheduled(fixedRate = 3000)
    public void fixedRateTask() {
        logger.info("固定频率任务，每3秒执行一次");
    }
    
    // 5. 固定延迟：任务完成后3秒再执行
    @Scheduled(fixedDelay = 3000)
    public void fixedDelayTask() {
        logger.info("固定延迟任务，完成后3秒再执行");
    }
    
    // 6. 初始延迟：启动后5秒开始执行，之后每10秒执行
    @Scheduled(initialDelay = 5000, fixedRate = 10000)
    public void initialDelayTask() {
        logger.info("初始延迟任务");
    }
}
```

**配置文件配置：**
```properties
# application.properties
# 配置时区
spring.task.scheduling.pool.size=10
spring.task.scheduling.thread-name-prefix=scheduling-

# 开启异步执行
spring.task.execution.pool.core-size=5
spring.task.execution.pool.max-size=10
spring.task.execution.thread-name-prefix=async-
```

**多线程定时任务：**
```java
@Configuration
@EnableScheduling
public class SchedulingConfig implements 
        SchedulingConfigurer {
    
    @Override
    public void configureTasks(
            ScheduledTaskRegistrar taskRegistrar) {
        taskRegistrar.setScheduler(
            taskScheduler());
    }
    
    @Bean
    public ScheduledExecutorService taskScheduler() {
        return Executors.newScheduledThreadPool(10);
    }
}
```

**异步定时任务：**
```java
@Configuration
@EnableAsync
public class AsyncConfig {
    
    @Bean(name = "taskExecutor")
    public Executor taskExecutor() {
        ThreadPoolTaskExecutor executor = 
            new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(5);
        executor.setMaxPoolSize(10);
        executor.setQueueCapacity(25);
        executor.setThreadNamePrefix("async-");
        executor.initialize();
        return executor;
    }
}

@Component
public class AsyncScheduledTasks {
    
    @Async  // 异步执行
    @Scheduled(fixedRate = 5000)
    public void asyncTask() {
        // 这个任务会在单独的线程中执行
        // 不会阻塞其他定时任务
    }
}
```

**Cron 表达式详解：**
```
┌───────────── 秒 (0-59)
│ ┌───────────── 分钟 (0-59)
│ │ ┌───────────── 小时 (0-23)
│ │ │ ┌───────────── 日 (1-31)
│ │ │ │ ┌───────────── 月 (1-12)
│ │ │ │ │ ┌───────────── 星期 (0-6, 0=周日)
│ │ │ │ │ │
* * * * * *

特殊字符：
* - 任意值
, - 多个值，如 1,3,5
- - 范围，如 1-5
/ - 步长，如 */5（每5个单位）
```

---

## 14. Spring Boot 异步任务？

**题目：**
Spring Boot 如何实现异步任务？

**答案：**
**启用异步功能：**
```java
@Configuration
@EnableAsync
public class AsyncConfig {
    
    @Bean(name = "taskExecutor")
    public Executor taskExecutor() {
        ThreadPoolTaskExecutor executor = 
            new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(5);        // 核心线程数
        executor.setMaxPoolSize(10);        // 最大线程数
        executor.setQueueCapacity(25);      // 队列容量
        executor.setThreadNamePrefix("async-");  //