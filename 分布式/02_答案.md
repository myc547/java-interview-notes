# 分布式面试题答案

## 1. CAP定理？

**题目：**
什么是CAP定理？

**答案：**
**CAP定理：**
分布式系统最多只能同时满足以下两个特性：

```
┌─────────────────────────────────────────────────────────┐
│                    CAP Theorem                           │
│                                                         │
│    C (Consistency - 一致性) ───┐                        │
│                                │  不可能三角            │
│                                │                        │
│              P (Partition Tolerance - 分区容错性)       │
│                                │                        │
│    A (Availability - 可用性) ──┴──                     │
│                                                         │
│  分布式系统必须满足P，只能在C和A之间权衡                  │
└─────────────────────────────────────────────────────────┘
```

**三种组合：**
- **CP**：一致性 + 分区容错（放弃可用性）
- **AP**：可用性 + 分区容错（放弃强一致）
- **CA**：一致性 + 可用性（单节点，放弃P）

**实际选择：**
- 互联网应用 → AP（最终一致）
- 金融系统 → CP（强一致）
- BASE理论：Basically Available + Soft state + Eventually consistent

---

## 2. 分布式事务的实现方案？

**题目：**
分布式事务有哪些实现方案？

**答案：**
**主流方案对比：**

| 方案 | 一致性 | 性能 | 复杂度 | 适用场景 |
|------|--------|------|--------|----------|
| **2PC** | 强一致 | 低 | 高 | 银行转账 |
| **3PC** | 强一致 | 低 | 高 | 很少使用 |
| **TCC** | 最终一致 | 中 | 高 | 电商订单 |
| **Seata AT** | 最终一致 | 中 | 低 | 通用场景 |
| **RocketMQ事务消息** | 最终一致 | 高 | 中 | 消息驱动 |
| **本地消息表** | 最终一致 | 中 | 中 | 异步场景 |

**2PC（两阶段提交）：**
```
阶段1：Prepare → 所有参与者prepare
阶段2：Commit → 所有参与者commit
```

**TCC（Try-Confirm-Cancel）：**
```
Try：预留资源
Confirm：确认执行
Cancel：取消回滚
```

**Seata AT模式：**
```java
@GlobalTransactional
@Transactional
public void createOrder(OrderDTO order) {
    // 扣减库存
    storageService.decrease(order.getProductId(), order.getCount());
    // 创建订单
    orderMapper.insert(order);
    // 扣减余额
    accountService.decrease(order.getUserId(), order.getAmount());
}
```

---

## 3. 幂等性如何保证？

**题目：**
如何保证接口的幂等性？

**答案：**
**幂等性定义：**
多次调用结果与一次调用结果相同。

**保证方案：**

**1. 唯一索引**
```java
// 数据库唯一索引防止重复插入
INSERT INTO order (order_no, ...) VALUES (?, ...)
ON DUPLICATE KEY UPDATE status = status;
```

**2. 分布式锁**
```java
String lockKey = "order:create:" + orderNo;
boolean locked = redisTemplate.opsForValue()
    .setIfAbsent(lockKey, "1", 10, TimeUnit.SECONDS);

if (!locked) {
    return "重复请求";
}
try {
    // 业务逻辑
} finally {
    redisTemplate.delete(lockKey);
}
```

**3. 状态机**
```java
// 订单状态：待支付 → 支付中 → 已支付
if (!"待支付".equals(order.getStatus())) {
    return "订单状态异常";
}
order.setStatus("支付中");
```

**4. Token机制**
```java
// 1. 获取token
String token = redisTemplate.opsForValue().get("token");

// 2. 验证并删除
Boolean deleted = redisTemplate.delete(token);
if (!deleted) {
    return "重复请求";
}
```

---

## 4. 分布式锁的实现？

**题目：**
如何实现分布式锁？

**答案：**
**Redis实现：**
```java
// 1. SETNX实现
String lockKey = "lock:product:" + productId;
boolean locked = redisTemplate.opsForValue()
    .setIfAbsent(lockKey, "1", 30, TimeUnit.SECONDS);

if (locked) {
    try {
        // 业务逻辑
    } finally {
        redisTemplate.delete(lockKey);
    }
}

// 2. Lua脚本原子操作
String script = 
    "if redis.call('get', KEYS[1]) == ARGV[1] then " +
    "    return redis.call('del', KEYS[1]) " +
    "else " +
    "    return 0 " +
    "end";
```

**Zookeeper实现：**
```java
// 创建临时顺序节点
String path = "/locks/" + lockName;
String node = zkClient.createEphemeralSequential(path, "");

// 获取所有子节点，判断是否是第一个
List<String> children = zkClient.getChildren("/locks");
Collections.sort(children);
if (children.get(0).equals(node)) {
    // 获取锁成功
}
```

**Redis vs Zookeeper：**
| 特性 | Redis | Zookeeper |
|------|-------|-----------|
| 性能 | 高 | 中 |
| 可靠性 | AP | CP |
| 过期机制 | 支持 | 自动删除 |
| 公平锁 | 需自行实现 | 支持 |

---

## 5. 消息队列的作用？

**题目：**
消息队列有什么作用？

**答案：**
**消息队列4大作用：**

**1. 异步解耦**
```
同步调用：服务A → 服务B（阻塞等待）
异步调用：服务A → MQ → 服务B（非阻塞）
```

**2. 流量削峰**
```
高峰期请求：10000 QPS
处理能力：1000 QPS

消息队列缓冲请求，平滑处理
```

**3. 延迟处理**
```
订单超时取消：发送延迟消息
定时任务：消息延迟投递
```

**4. 分布式事务**
```
半消息 → 本地事务 → 确认提交
```

**常用消息队列：**
- **Kafka**：高吞吐，日志处理
- **RabbitMQ**：功能丰富，灵活
- **RocketMQ**：电商，金融场景
- **Pulsar**：云原生，新特性

---

## 6. 如何设计高可用系统？

**题目：**
如何设计高可用系统？

**答案：**
**高可用设计原则：**

**1. 冗余**
```
多实例部署
主备切换
数据冗余
```

**2. 负载均衡**
```
Nginx负载均衡
LVS
云原生：Service Mesh
```

**3. 容错**
```
熔断降级（Hystrix、Sentinel）
限流
超时重试
```

**4. 监控告警**
```
Prometheus + Grafana
日志聚合
链路追踪（SkyWalking）
```

**5. 弹性伸缩**
```
Kubernetes HPA
云弹性伸缩
```

**架构示例：**
```
用户请求
    ↓
Nginx集群（Keepalived）
    ↓
Gateway集群
    ↓
服务集群（多实例）
    ↓
数据存储（主从 + 分片）
```

---

## 7. 一致性哈希原理？

**题目：**
一致性哈希是什么？原理是什么？

**答案：**
**一致性哈希：**
用于分布式系统中，数据分布和负载均衡。

**原理：**
```
哈希环：
0 → 2^32-1

节点A → hash(A) → 位置
节点B → hash(B) → 位置
节点C → hash(C) → 位置

数据Key → hash(Key) → 位置
顺时针找到第一个节点
```

**数据倾斜问题：**
```
解决方案：虚拟节点
真实节点：3个
虚拟节点：300个（每个真实节点100个）

提高均匀性
```

**优点：**
- 增加/删除节点影响小
- 负载均衡
- 支持扩容

---

## 8. 雪花算法原理？

**题目：**
雪花算法是什么？原理是什么？

**答案：**
**雪花算法（Snowflake）：**
分布式ID生成算法，64位long类型。

**结构：**
```
┌────────────────────────────────────────────────────────┐
│  1位符号位 │ 41位时间戳 │ 10位机器ID │ 12位序列号     │
│     0     │  41位     │   10位    │    12位       │
└────────────────────────────────────────────────────────┘

总长度：64位
```

**各部分：**
- **符号位**：0（正数）
- **时间戳**：41位，可支持69年
- **机器ID**：10位，支持1024个节点
- **序列号**：12位，每毫秒4096个ID

**实现：**
```java
public class SnowflakeIdWorker {
    private long sequence = 0L;
    private long lastTimestamp = -1L;
    
    public synchronized long nextId() {
        long timestamp = System.currentTimeMillis();
        
        if (timestamp < lastTimestamp) {
            throw new RuntimeException("时钟回拨");
        }
        
        if (timestamp == lastTimestamp) {
            sequence = (sequence + 1) & 4095;
        } else {
            sequence = 0L;
        }
        
        lastTimestamp = timestamp;
        
        return (timestamp - 1288834974657L) << 22
             | (workerId & 1023) << 12
             | sequence;
    }
}
```

---

## 9. 分库分表策略？

**题目：**
分库分表有哪些策略？

**答案：**
**分库分表类型：**

**1. 垂直拆分**
```
按业务拆分
用户库、订单库、商品库
```

**2. 水平拆分**
```
按数据量拆分
用户表1、用户表2、用户表3
```

**分片策略：**
```java
// 哈希分片
shardingKey = userId % 4

// 范围分片
shardingKey = userId / 1000000

// 地理分片
shardingKey = regionCode
```

**分库分表中间件：**
- **ShardingSphere**
- **MyCat**
- **TDDL（淘宝）**

**问题与解决：**
- **跨库查询**：应用层聚合
- **分页查询**：先查询后合并
- **事务**：XA事务、最终一致
- **Join**：应用层处理、冗余数据

---

## 10. 限流算法？

**题目：**
常见的限流算法有哪些？

**答案：**
**4种限流算法：**

**1. 计数器**
```
固定时间窗口内计数
超过阈值拒绝
```

**2. 滑动窗口**
```
将时间窗口划分为小格子
滑动统计
```

**3. 漏桶**
```
请求进入漏桶
以固定速率漏出
超过桶容量拒绝
```

**4. 令牌桶**
```
按固定速率生成令牌
请求获取令牌
无令牌拒绝
```

**算法对比：**
| 算法 | 特点 | 适用场景 |
|------|------|----------|
| 计数器 | 简单 | 简单限流 |
| 滑动窗口 | 平滑 | 平滑限流 |
| 漏桶 | 流量整形 | 稳定输出 |
| 令牌桶 | 允许突发 | 弹性限流 |

**Redis+Lua实现：**
```lua
-- 令牌桶
local key = KEYS[1]
local rate = tonumber(ARGV[1])
local capacity = tonumber(ARGV[2])
local now = tonumber(ARGV[3])
local requested = tonumber(ARGV[4])

local tokens = redis.call('GET', key)
if tokens == false then
    tokens = capacity
end

local fill = (now - last_time) * rate
tokens = math.min(capacity, tokens + fill)

local allowed = math.min(requested, tokens)
redis.call('SET', key, tokens - allowed, 'EX', 60)

return allowed
```

---

*更多分布式面试题答案*
