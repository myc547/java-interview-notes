# MySQL 面试题

## 题目

**题目：**
请详细说明 InnoDB Redo Log 的写入机制，包括 WAL 和两阶段提交。

**答案：**
**Redo Log 是什么：**
Redo Log 是 InnoDB 引擎的物理日志，记录数据页的物理修改，用于崩溃恢复。

**Redo Log 结构：**
```
┌─────────────────────────────────────────────────────┐
│                   Redo Log Buffer                    │
│  ┌─────────┬─────────┬─────────┬─────────┐          │
│  │ Log Seq │ Log Seq │ Log Seq │ Log Seq │          │
│  │ Number  │ Number  │ Number  │ Number  │          │
│  │   1000  │   1001  │   1002  │   1003  │          │← lsn
│  └─────────┴─────────┴─────────┴─────────┘          │
└─────────────────────────────────────────────────────┘
                    ↓ fsync
┌─────────────────────────────────────────────────────┐
│                   Redo Log File                      │
│  ┌─────────┬─────────┬─────────┬─────────┐          │
│  │ redo_01 │ redo_02 │ redo_03 │ redo_04 │  循环使用 │
│  └─────────┴─────────┴─────────┴─────────┘          │
│                      checkpoint                     │
└─────────────────────────────────────────────────────┘
```

**Write-Ahead Logging（WAL）：**
```c
// 核心原则：先写日志，再写数据
// 1. 修改数据页之前，先记录 redo log
// 2. redo log 写入成功后，才修改内存数据页
// 3. 数据页的修改可以延迟，但日志不能延迟
```

**写入流程：**
```java
// 事务执行流程
void executeTransaction(Transaction tx) {
    // 1. 事务开始
    tx.begin();
    
    // 2. 执行 SQL，修改数据
    update user set age = 25 where id = 1;
    
    // 3. 记录 redo log（prepare 阶段）
    redoLog.write({
        type: 'update',
        tableId: 1,
        pageNo: 100,
        offset: 200,
        before: { age: 20 },
        after: { age: 25 },
        trxId: tx.id,
        lsn: currentLsn  // 比如 1000
    });
    
    // 4. 写 binlog（两阶段提交）
    binlog.write(tx.sql);
    
    // 5. redo log 标记为 commit
    redoLog.markCommit(currentLsn);
    
    // 6. 事务提交完成
    tx.commit();
}
```

**LSN（Log Sequence Number）：**
```c
// LSN 递增序列
// 1. redo log buffer 中的 LSN
// 2. 写入磁盘后的 LSN（flushed_to_disk_lsn）
// 3. checkpoint LSN

// 关系：
// checkpoint_lsn ≤ flushed_to_disk_lsn ≤ current_lsn
```

**Redo Log 刷盘策略：**
```sql
-- innodb_flush_log_at_trx_commit 参数
-- 0：每秒刷盘（可能丢失1秒数据）
-- 1：每次提交刷盘（最安全，默认）
-- 2：每次提交写操作系统缓存，由操作系统刷盘

SET GLOBAL innodb_flush_log_at_trx_commit = 1;  -- 生产环境用这个
```

**两阶段提交：**
```
┌──────────────────────────────────────────────────────────────────┐
│                     两阶段提交                                    │
│                                                                  │
│  ┌─────────┐     ┌─────────┐     ┌─────────┐     ┌─────────┐   │
│  │ 事务    │────>│ Redo    │────>│ Binlog  │────>│ Redo    │   │
│  │ 开始    │     │ prepare │     │ write   │     │ commit  │   │
│  └─────────┘     └─────────┘     └─────────┘     └─────────┘   │
│                         ↓                      ↓                │
│                   崩溃恢复点            提交完成                │
└──────────────────────────────────────────────────────────────────┘

崩溃恢复场景：
1. 如果 redo prepare 之前崩溃 → 事务回滚
2. 如果 redo prepare 之后、binlog 之前崩溃 → 事务回滚
3. 如果 binlog 之后、redo commit 之前崩溃 → 事务恢复
```

**Redo Log 循环：**
```
┌────────────────────────────────────────────────────┐
│                    Redo Log 循环                    │
│                                                    │
│  ┌──────────────────────────────────────────────┐ │
│  │              已写入磁盘区域                    │ │
│  │    ┌────────────────────────────┐            │ │
│  │    │   checkpoint LSN ←─────────┼── 可覆盖   │ │
│  │    └────────────────────────────┘            │ │
│  │              活跃日志区域                      │ │
│  │    ┌────────────────────────────┐            │ │
│  │    │   current LSN ─────────────┼── 正在写入 │    └──────────────────────── │
│  │────┘            │ │
│  └──────────────────────────────────────────────┘ │
└────────────────────────────────────────────────────┘

当活跃日志区域满时：
1. 触发 checkpoint
2. 刷新脏页到磁盘
3. 更新 checkpoint LSN
4. 释放空间继续使用
```

---

## 2. Undo Log 写入机制？

**题目：**
请详细说明 InnoDB Undo Log 的写入机制，包括回滚段和版本链。

**答案：**
**Undo Log 是什么：**
Undo Log 是逻辑日志，记录数据的旧版本，用于事务回滚和 MVCC。

**Undo Log 作用：**
```java
// 1. 事务回滚
//    事务失败时，恢复到事务开始前的状态

// 2. MVCC 读
//    读取事务开始时的快照版本

// 3. 崩溃恢复
//    回滚未提交的事务
```

**Undo Log 结构：**
```
┌─────────────────────────────────────────────────────────────┐
│                    Undo Log 结构                            │
│                                                              │
│  ┌─────────────────────────────────────────────────────┐   │
│  │                  回滚段（Rollback Segment）          │   │
│  │  ┌───────────────────────────────────────────────┐  │   │
│  │  │  Undo Segment 0  (系统表空间)                  │  │   │
│  │  │  Undo Segment 1  (用户表空间)                  │  │   │
│  │  │  Undo Segment 2                               │  │   │
│  │  │  ...                                           │  │   │
│  │  │  Undo Segment 127                             │  │   │
│  │  └───────────────────────────────────────────────┘  │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                              │
│  ┌─────────────────────────────────────────────────────┐   │
│  │                  Undo Log 链表                       │   │
│  │                                                              │
│  │  ┌─────────┐    ┌─────────┐    ┌─────────┐         │   │
│  │  │  Update │───>│  Update │───>│  Insert │         │   │
│  │  │  Undo   │    │  Undo   │    │  Undo   │         │   │
│  │  │  Log    │    │  Log    │    │  Log    │         │   │
│  │  └─────────┘    └─────────┘    └─────────┘         │   │
│  │     ↑                                            │   │
│  │     │                                            │   │
│  │  DB_ROLL_PTR                                     │   │
│  │  (回滚指针)                                       │   │
└─────────────────────────────────────────────────────────────┘
```

**Undo Log 类型：**
```sql
-- 1. Insert Undo Log
--    插入操作产生的 undo log
--    事务提交后可以直接删除

-- 2. Update Undo Log
--    更新/删除操作产生的 undo log
--    需要支持 MVCC，其他事务可能正在使用
--    事务提交后进入 history list，等待purge
```

**写入流程：**
```java
void executeUpdate(Transaction tx, String sql) {
    // 1. 分配 undo segment
    UndoSegment segment = tx.getUndoSegment();
    
    // 2. 创建 undo log header
    UndoLogHeader header = segment.allocUndoLogHeader();
    header.trxId = tx.id;
    header.trxSeq = tx.sequence;
    header.trxRollPtr = 0;
    
    // 3. 记录修改前的数据（old version）
    Row oldRow = getCurrentRow();
    UndoLogRecord record = new UndoLogRecord();
    record.type = UPDATE;  // 或 INSERT
    record.oldData = oldRow.serialize();
    record.tableId = oldRow.tableId;
    record.pageId = oldRow.pageId;
    
    // 4. 将 undo log 写入 undo tablespace
    undoSpace.write(header, record);
    
    // 5. 更新数据行的 roll_ptr，指向新创建的 undo log
    Row newRow = getRowForUpdate();
    newRow.rollPtr = header.startLsn;
    
    // 6. 执行实际的数据修改
    updateRowInMemory(newRow);
    
    // 7. 记录 redo log（为了崩溃恢复 undo log 本身）
    redoLog.write({
        type: 'undo_log',
        undoLog: record,
        lsn: getNextLsn()
    });
}
```

**版本链形成：**
```
初始数据行（trx_id=100）：
┌────────────────────────────────────────────────────┐
│  id: 1, name: '张三', age: 20                       │
│  trx_id: 100, roll_ptr: null                       │
└────────────────────────────────────────────────────┘
                         ↑
                    (update age=25)
                         │
                         ↓
修改后（trx_id=200）：
┌────────────────────────────────────────────────────┐
│  id: 1, name: '张三', age: 25                       │
│  trx_id: 200, roll_ptr: ───────────────────────────┐
└────────────────────────────────────────────────────┘
                                                        │
                                                        ↓
                                              ┌─────────────────────────────────────┐
                                              │  Undo Log (trx_id=100 时的版本)      │
                                              │  age: 20                              │
                                              │  roll_ptr: null                       │
                                              └─────────────────────────────────────┘
                                                        ↑
                                                 (update age=30)
                                                        │
                                                        ↓
修改后（trx_id=300）：
┌────────────────────────────────────────────────────┐
│  id: 1, name: '张三', age: 30                       │
│  trx_id: 300, roll_ptr: ───────────────────────────┐
└────────────────────────────────────────────────────┘
                                                        │
                                                        ↓
                                              ┌─────────────────────────────────────┐
                                              │  Undo Log (trx_id=200 时的版本)      │
                                              │  age: 25                              │
                                              │  roll_ptr: ─────────────────────────┐ │
                                              └─────────────────────────────────────┘ │
                                                                        │
                                                                        ↓
                                                              ┌───────────────────────────┐
                                                              │ Undo Log (trx_id=100)     │
                                                              │ age: 20                    │
                                                              │ roll_ptr: null             │
                                                              └───────────────────────────┘
```

**Undo Log 空间管理：**
```sql
-- 查看 undo tablespace
SHOW VARIABLES LIKE 'innodb_undo_tablespaces';

-- 默认为 2 个 undo tablespace
-- 每个 tablespace 包含多个回滚段

-- Purge 线程
-- 定期清理不再需要的 undo log
-- 条件：没有活跃事务需要该版本 + undo log 所在的事务已提交

SELECT * FROM information_schema.INNODB_TRX;  -- 查看活跃事务
SELECT * FROM information_schema.INNODB_ROLLBACK;  -- 查看回滚段
```

**Undo Log 与事务隔离：**
```java
// 读已提交（READ COMMITTED）
// 每次读都创建新的 ReadView

// 可重复读（REPEATABLE READ）
// 事务开始时创建 ReadView，整个事务复用
```

---

## 3. MVCC 视图创建时机？

**题目：**
请详细说明 MVCC 中 ReadView 的创建时机，以及不同隔离级别下的差异。

**答案：**
**ReadView 是什么：**
ReadView（读视图）是 MVCC 的核心组件，用于判断某个数据版本对当前事务是否可见。

**ReadView 结构：**
```c
struct ReadView {
    trx_id_t m_low_limit_id;      // 最大事务ID + 1，所有 >= 这个的都不可见
    trx_id_t m_up_limit_id;       // 最小活跃事务ID，所有 < 这个的都可见
    trx_id_t m_creator_trx_id;    // 当前事务ID
    std::vector<trx_id_t> m_ids;  // 活跃事务列表（>= m_up_limit_id 且 < m_low_limit_id）
    bool m_low_limit_no_trx;      // 是否没有活跃事务
};
```

**可见性判断算法：**
```c
bool isVisible(trx_id_t trx_id, trx_id_t row_trx_id) {
    // 1. 如果数据版本的事务ID等于当前事务ID，可见（自己的修改）
    if (row_trx_id == m_creator_trx_id) {
        return true;
    }
    
    // 2. 如果数据版本的事务ID小于最小活跃事务ID，可见（已提交）
    if (row_trx_id < m_up_limit_id) {
        return true;
    }
    
    // 3. 如果数据版本的事务ID大于等于最大事务ID，不可见（未开始）
    if (row_trx_id >= m_low_limit_id) {
        return false;
    }
    
    // 4. 如果数据版本的事务ID在活跃事务列表中，不可见（未提交）
    if (inActiveTransactionList(row_trx_id)) {
        return false;
    }
    
    // 5. 否则，可见（已提交）
    return true;
}
```

**图解可见性判断：**
```
时间线：
──────┬──────────────┬──────────────┬──────────────┬──────────────┬──────>
      │              │              │              │              │
    trx=100        trx=200        trx=300        trx=400        trx=500
    (提交)         (活跃)          (活跃)         (提交)       (当前事务)

当前事务 trx=400 开始时的 ReadView：
┌─────────────────────────────────────────────────────────────────┐
│  m_up_limit_id = 200    （最小活跃事务）                          │
│  m_low_limit_id = 500   （最大事务ID+1）                          │
│  m_ids = [200, 300]     （活跃事务列表）                          │
│  m_creator_trx_id = 400 （当前事务）                              │
└─────────────────────────────────────────────────────────────────┘

数据版本可见性判断：
- trx=100 < 200 → 可见 ✅
- trx=200 ∈ [200,300] 且在 m_ids 中 → 不可见 ❌
- trx=300 ∈ [200,300] 且在 m_ids 中 → 不可见 ❌
- trx=400 = 400 → 可见 ✅（自己）
- trx=500 >= 500 → 不可见 ❌（未开始）
```

**不同隔离级别的 ReadView 创建时机：**

**1. 读已提交（READ COMMITTED）**
```sql
-- 每次读取都创建新的 ReadView
SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;

-- 每次 SELECT 都会：
-- 1. 获取当前活跃事务列表
-- 2. 创建新的 ReadView
-- 3. 进行可见性判断
-- 4. 返回结果后，ReadView 释放

BEGIN;
SELECT * FROM user WHERE id = 1;  -- 创建 ReadView A
-- 看到的数据版本基于 ReadView A

-- 其他事务修改并提交了数据

SELECT * FROM user WHERE id = 1;  -- 创建 ReadView B（新的）
-- 可能看到不同的数据版本（因为 ReadView 变了）
COMMIT;
```

**2. 可重复读（REPEATABLE READ）**
```sql
-- 事务开始时创建 ReadView，整个事务复用
SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;

BEGIN;
-- ReadView 在这里创建（事务第一条 SELECT 时）
SELECT * FROM user WHERE id = 1;  -- 创建 ReadView A

-- 其他事务修改并提交了数据

SELECT * FROM user WHERE id = 1;  -- 复用 ReadView A
-- 看到的数据版本和第一次 SELECT 相同（因为 ReadView 没变）
COMMIT;
-- ReadView 释放
```

**ReadView 创建源码流程：**
```c
// InnoDB 源码流程（简化）

// 1. 读操作入口
int row_search_for_mysql(
    buf_block_t* block,    // 数据块
    dict_index_t* index,   // 索引
    ulint mode,            // 模式
    ...) {
    
    // 2. 创建 ReadView（如果是第一次读）
    ReadView* view = thr_get_read_view(thr);
    if (view == nullptr) {
        view = read_view_open_now(trx_id);
        thr_set_read_view(thr, view);
    }
    
    // 3. 判断数据是否可见
    if (!read_view_is_visible(view, block, index, entry)) {
        // 不可见，需要查找历史版本
        return row_sel_build_committed_vers(block, index, entry, view, ...);
    }
    
    // 4. 返回可见数据
    return DB_SUCCESS;
}

// 5. 可重复读模式下，ReadView 复用
void trx_commit(Transaction* tx) {
    if (tx->isolation_level == TRX_ISO_REPEATABLE_READ) {
        // 不释放 ReadView，事务结束才释放
        read_view_close_for_trx(tx->read_view);
    }
}
```

**MVCC 读取流程：**
```
┌─────────────────────────────────────────────────────────────────┐
│                    MVCC 读取流程                                 │
│                                                                  │
│  ┌─────────────┐                                                │
│  │  SELECT     │  开始读操作                                     │
│  └──────┬──────┘                                                │
│         ↓                                                       │
│  ┌─────────────┐                                                │
│  │ 创建/复用   │  ReadView                                      │
│  │ ReadView    │                                                │
│  └──────┬──────┘                                                │
│         ↓                                                       │
│  ┌─────────────┐                                                │
│  │ 读取数据页   │  从聚簇索引读取数据                             │
│  └──────┬──────┘                                                │
│         ↓                                                       │
│  ┌─────────────┐                                                │
│  │ 判断可见性   │  trx_id vs ReadView                            │
│  └──────┬──────┘                                                │
│         ↓                                                       │
│  ┌─────────────┐      ┌─────────────┐                          │
│  │ 可见 ✅     │      │ 不可见 ❌    │                          │
│  └──────┬──────┘      └──────┬──────┘                          │
│         ↓                    ↓                                  │
│  ┌─────────────┐      ┌─────────────┐                          │
│  │ 返回数据     │      │ 沿着版本链  │                          │
│  └─────────────┘      │ 查找历史版本 │                          │
│                       └──────┬──────┘                          │
│                              ↓                                  │
│                       ┌─────────────┐                          │
│                       │ 找到可见版本 │                          │
│                       └──────┬──────┘                          │
│                              ↓                                  │
│                       ┌─────────────┐                          │
│                       │ 返回历史数据  │                          │
│                       └─────────────┘                          │
└─────────────────────────────────────────────────────────────────┘
```

**ReadView 与快照的关系：**
```java
// 快照 = ReadView 的状态

// 读已提交
// 每次读都是不同的快照（ReadView 每次都新建）

// 可重复读
// 整个事务是同一个快照（ReadView 复用）
```

**实验验证：**
```sql
-- 验证可重复读
-- 终端 1：
BEGIN;
SELECT * FROM user WHERE id = 1;  -- 假设看到 age=20

-- 终端 2：
BEGIN;
UPDATE user SET age = 30 WHERE id = 1;
COMMIT;  -- 提交

-- 终端 1：
SELECT * FROM user WHERE id = 1;  -- 仍然是 age=20（可重复读）
COMMIT;  -- 提交后 ReadView 释放

-- 终端 1（重新开始）：
SELECT * FROM user WHERE id = 1;  -- 现在看到 age=30
```

**常见问题：**
```sql
-- 1. 为什么可重复读还有幻读？
--    Next-Key Lock 解决的是写操作带来的幻读
--    读操作通过 MVCC 解决

-- 2. ReadView 何时创建？
--    读已提交：每次 SELECT
--    可重复读：事务第一条 SELECT

-- 3. ReadView 何时释放？
--    读已提交：SELECT 完成后
--    可重复读：事务提交或回滚后
```

---

## 4. InnoDB 崩溃恢复流程？

**题目：**
请说明 InnoDB 崩溃恢复的完整流程。

**答案：**
**崩溃恢复触发时机：**
```c
// MySQL 启动时检测到上次异常关闭
// 检查 redo log 的状态
// 如果有未完成的提交或回滚，执行恢复流程
```

**崩溃恢复流程：**
```
┌─────────────────────────────────────────────────────────────────┐
│                    InnoDB 崩溃恢复流程                           │
│                                                                  │
│  1. 初始化                                                       │
│     ├── 读取 redo log 文件                                       │
│     ├── 找到最近的 checkpoint                                    │
│     └── 确定恢复的起始点                                          │
│                                                                  │
│  2. 分析阶段（Analysis）                                         │
│     ├── 扫描 redo log                                           │
│     ├── 收集所有未完成的事务                                     │
│     └── 收集所有已提交但未刷盘的事务                              │
│                                                                  │
│  3. 重做阶段（Redo）                                             │
│     ├── 从 checkpoint 开始重放 redo log                         │
│     ├── 恢复到崩溃前的状态                                       │
│     └── 注意：只重做，不回滚                                      │
│                                                                  │
│  4. 回滚阶段（Undo）                                             │
│     ├── 回滚未提交的事务                                         │
│     ├── 读取 undo log                                           │
│     └── 执行反向操作                                             │
│                                                                  │
│  5. 完成恢复                                                     │
│     ├── 清理 undo log                                           │
│     └── 启动 MySQL 服务                                          │
└─────────────────────────────────────────────────────────────────┘
```

**详细恢复步骤：**
```c
void innodb_recovery() {
    // 1. 找到最近的 checkpoint
    CheckpointInfo cp = findLatestCheckpoint();
    lsn_t start_lsn = cp.lsn;
    
    // 2. 读取 redo log 到内存
    LogBuffer* log_buffer = readRedoLog(start_lsn);
    
    // 3. 分析 redo log
    TransactionList active_txns = analyzeLog(log_buffer);
    TransactionList committed_txns = analyzeCommitted(log_buffer);
    
    // 4. 重做（Redo）阶段
    for (lsn = start_lsn; lsn < log_buffer.end; ) {
        LogRecord* record = parseLogRecord(lsn);
        
        if (record.type == UPDATE) {
            // 重做更新操作
            applyRedoRecord(record);
        }
        
        lsn = getNextRecordLsn(lsn);
    }
    
    // 5. 回滚（Undo）阶段
    for (Transaction* txn : active_txns) {
        // 获取该事务的 undo log
        UndoLog* undo = getUndoLog(txn.id);
        
        // 逆向执行 undo log
        while (undo != null) {
            applyUndoLog(undo);  // 执行反向操作
            undo = undo.prev;    // 沿着版本链
        }
    }
    
    // 6. 清理
    purgeUndoLogs();
    flushDirtyPages();
}
```

**崩溃恢复场景：**
```sql
-- 场景1：事务执行中崩溃（未提交）
-- 恢复：回滚该事务的所有修改

-- 场景2：事务提交中崩溃（redo prepare 完成，commit 未完成）
-- 恢复：该事务提交（redo log 已有记录）

-- 场景3：事务提交完成，但数据页未刷盘
-- 恢复：通过 redo log 恢复数据页

-- 场景4：数据页刷盘完成，redo log 未刷盘
-- 恢复：不需要处理（数据已在磁盘）
```

---

## 5. Binlog 与 Redo Log 的区别？

**题目：**
MySQL 的 Binlog 和 Redo Log 有什么区别？

**答案：**
**两种日志对比：**

| 特性 | Binlog | Redo Log |
|------|--------|----------|
| **所属层次** | MySQL Server 层 | InnoDB 存储引擎层 |
| **日志类型** | 逻辑日志（SQL 语句） | 物理日志（数据页修改） |
| **记录内容** | 数据变更的逻辑操作 | 数据页的物理变更 |
| **作用** | 主从复制、数据恢复 | 崩溃恢复 |
| **写入方式** | 顺序写入 | 循环写入 |
| **刷盘策略** | sync_binlog 参数 | innodb_flush_log_at_trx_commit |
| **空间** | 追加写入，需要手动清理 | 循环使用 |
| **格式** | STATEMENT/ROW/MIXED | 固定的物理格式 |

**两种日志的协作：**
```
┌─────────────────────────────────────────────────────────────────┐
│                    事务提交时的日志写入                           │
│                                                                  │
│  ┌─────────┐     ┌─────────┐     ┌─────────┐     ┌─────────┐   │
│  │ 事务    │────>│ Redo    │────>│ Binlog  │────>│ Redo    │   │
│  │ 开始    │     │ prepare │     │ write   │     │ commit  │   │
│  └─────────┘     └─────────┘     └─────────┘     └─────────┘   │
│                         ↓                      ↓                │
│                   记录到内存           记录到内存          刷盘  │
└─────────────────────────────────────────────────────────────────┘

两阶段提交的目的：
保证 Binlog 和 Redo Log 的一致性
```

**为什么需要两种日志：**
```java
// 1. 职责不同
//    Binlog：用于复制和外部恢复（mysqldump、binlog恢复）
//    Redo Log：用于崩溃恢复

// 2. 层次不同
//    Binlog：Server 层，所有存储引擎都有
//    Redo Log：InnoDB 特有

// 3. 恢复能力不同
//    Binlog：可以恢复到任意时间点
//    Redo Log：只能恢复到最近一次 checkpoint
```

**数据恢复场景：**
```bash
# 使用 Binlog 恢复到某个时间点
mysqlbinlog --start-datetime="2025-01-01 10:00:00" \
            --stop-datetime="2025-01-01 11:00:00" \
            mysql-bin.000001 | mysql -u root -p

# 使用 Redo Log 崩溃恢复
# MySQL 自动完成，不需要手动操作
```

**删除策略：**
```sql
-- Binlog 手动清理
PURGE BINARY LOGS BEFORE '2025-01-01';
SHOW BINARY LOGS;

-- 设置过期时间
SHOW VARIABLES LIKE 'expire_logs_days';
SET GLOBAL expire_logs_days = 7;

-- Redo Log 自动循环
-- 当 redo log 空间不足时，自动触发 checkpoint
-- 覆盖旧的日志
```

## 答案

**题目：**
请详细说明 InnoDB Redo Log 的写入机制，包括 WAL 和两阶段提交。

**答案：**
**Redo Log 是什么：**
Redo Log 是 InnoDB 引擎的物理日志，记录数据页的物理修改，用于崩溃恢复。

**Redo Log 结构：**
```
┌─────────────────────────────────────────────────────┐
│                   Redo Log Buffer                    │
│  ┌─────────┬─────────┬─────────┬─────────┐          │
│  │ Log Seq │ Log Seq │ Log Seq │ Log Seq │          │
│  │ Number  │ Number  │ Number  │ Number  │          │
│  │   1000  │   1001  │   1002  │   1003  │          │← lsn
│  └─────────┴─────────┴─────────┴─────────┘          │
└─────────────────────────────────────────────────────┘
                    ↓ fsync
┌─────────────────────────────────────────────────────┐
│                   Redo Log File                      │
│  ┌─────────┬─────────┬─────────┬─────────┐          │
│  │ redo_01 │ redo_02 │ redo_03 │ redo_04 │  循环使用 │
│  └─────────┴─────────┴─────────┴─────────┘          │
│                      checkpoint                     │
└─────────────────────────────────────────────────────┘
```

**Write-Ahead Logging（WAL）：**
```c
// 核心原则：先写日志，再写数据
// 1. 修改数据页之前，先记录 redo log
// 2. redo log 写入成功后，才修改内存数据页
// 3. 数据页的修改可以延迟，但日志不能延迟
```

**写入流程：**
```java
// 事务执行流程
void executeTransaction(Transaction tx) {
    // 1. 事务开始
    tx.begin();
    
    // 2. 执行 SQL，修改数据
    update user set age = 25 where id = 1;
    
    // 3. 记录 redo log（prepare 阶段）
    redoLog.write({
        type: 'update',
        tableId: 1,
        pageNo: 100,
        offset: 200,
        before: { age: 20 },
        after: { age: 25 },
        trxId: tx.id,
        lsn: currentLsn  // 比如 1000
    });
    
    // 4. 写 binlog（两阶段提交）
    binlog.write(tx.sql);
    
    // 5. redo log 标记为 commit
    redoLog.markCommit(currentLsn);
    
    // 6. 事务提交完成
    tx.commit();
}
```

**LSN（Log Sequence Number）：**
```c
// LSN 递增序列
// 1. redo log buffer 中的 LSN
// 2. 写入磁盘后的 LSN（flushed_to_disk_lsn）
// 3. checkpoint LSN

// 关系：
// checkpoint_lsn ≤ flushed_to_disk_lsn ≤ current_lsn
```

**Redo Log 刷盘策略：**
```sql
-- innodb_flush_log_at_trx_commit 参数
-- 0：每秒刷盘（可能丢失1秒数据）
-- 1：每次提交刷盘（最安全，默认）
-- 2：每次提交写操作系统缓存，由操作系统刷盘

SET GLOBAL innodb_flush_log_at_trx_commit = 1;  -- 生产环境用这个
```

**两阶段提交：**
```
┌──────────────────────────────────────────────────────────────────┐
│                     两阶段提交                                    │
│                                                                  │
│  ┌─────────┐     ┌─────────┐     ┌─────────┐     ┌─────────┐   │
│  │ 事务    │────>│ Redo    │────>│ Binlog  │────>│ Redo    │   │
│  │ 开始    │     │ prepare │     │ write   │     │ commit  │   │
│  └─────────┘     └─────────┘     └─────────┘     └─────────┘   │
│                         ↓                      ↓                │
│                   崩溃恢复点            提交完成                │
└──────────────────────────────────────────────────────────────────┘

崩溃恢复场景：
1. 如果 redo prepare 之前崩溃 → 事务回滚
2. 如果 redo prepare 之后、binlog 之前崩溃 → 事务回滚
3. 如果 binlog 之后、redo commit 之前崩溃 → 事务恢复
```

**Redo Log 循环：**
```
┌────────────────────────────────────────────────────┐
│                    Redo Log 循环                    │
│                                                    │
│  ┌──────────────────────────────────────────────┐ │
│  │              已写入磁盘区域                    │ │
│  │    ┌────────────────────────────┐            │ │
│  │    │   checkpoint LSN ──────────┼── 可覆盖   │ │
│  │    └────────────────────────────┘            │ │
│  │              活跃日志区域                      │ │
│  │    ┌────────────────────────────┐            │ │
│  │    │   current LSN ─────────────┼── 正在写入 │    └──────────────────────── │
│  │────┘            │ │
│  └──────────────────────────────────────────────┘ │
└────────────────────────────────────────────────────┘

当活跃日志区域满时：
1. 触发 checkpoint
2. 刷新脏页到磁盘
3. 更新 checkpoint LSN
4. 释放空间继续使用
```

---

## 2. Undo Log 写入机制？

**题目：**
请详细说明 InnoDB Undo Log 的写入机制，包括回滚段和版本链。

**答案：**
**Undo Log 是什么：**
Undo Log 是逻辑日志，记录数据的旧版本，用于事务回滚和 MVCC。

**Undo Log 作用：**
```java
// 1. 事务回滚
//    事务失败时，恢复到事务开始前的状态

// 2. MVCC 读
//    读取事务开始时的快照版本

// 3. 崩溃恢复
//    回滚未提交的事务
```

**Undo Log 结构：**
```
┌─────────────────────────────────────────────────────────────┐
│                    Undo Log 结构                            │
│                                                              │
│  ┌─────────────────────────────────────────────────────┐   │
│  │                  回滚段（Rollback Segment）          │   │
│  │  ┌───────────────────────────────────────────────┐  │   │
│  │  │  Undo Segment 0  (系统表空间)                  │  │   │
│  │  │  Undo Segment 1  (用户表空间)                  │  │   │
│  │  │  Undo Segment 2                               │  │   │
│  │  │  ...                                           │  │   │
│  │  │  Undo Segment 127                             │  │   │
│  │  └───────────────────────────────────────────────┘  │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                              │
│  ┌─────────────────────────────────────────────────────┐   │
│  │                  Undo Log 链表                       │   │
│  │                                                              │
│  │  ┌─────────┐    ┌─────────┐    ┌─────────┐         │   │
│  │  │  Update │───>│  Update │───>│  Insert │         │   │
│  │  │  Undo   │    │  Undo   │    │  Undo   │         │   │
│  │  │  Log    │    │  Log    │    │  Log    │         │   │
│  │  └─────────┘    └─────────┘    └─────────┘         │   │
│  │     ↑                                            │   │
│  │     │                                            │   │
│  │  DB_ROLL_PTR                                     │   │
│  │  (回滚指针)                                       │   │
└─────────────────────────────────────────────────────────────┘
```

**Undo Log 类型：**
```sql
-- 1. Insert Undo Log
--    插入操作产生的 undo log
--    事务提交后可以直接删除

-- 2. Update Undo Log
--    更新/删除操作产生的 undo log
--    需要支持 MVCC，其他事务可能正在使用
--    事务提交后进入 history list，等待purge
```

**写入流程：**
```java
void executeUpdate(Transaction tx, String sql) {
    // 1. 分配 undo segment
    UndoSegment segment = tx.getUndoSegment();
    
    // 2. 创建 undo log header
    UndoLogHeader header = segment.allocUndoLogHeader();
    header.trxId = tx.id;
    header.trxSeq = tx.sequence;
    header.trxRollPtr = 0;
    
    // 3. 记录修改前的数据（old version）
    Row oldRow = getCurrentRow();
    UndoLogRecord record = new UndoLogRecord();
    record.type = UPDATE;  // 或 INSERT
    record.oldData = oldRow.serialize();
    record.tableId = oldRow.tableId;
    record.pageId = oldRow.pageId;
    
    // 4. 将 undo log 写入 undo tablespace
    undoSpace.write(header, record);
    
    // 5. 更新数据行的 roll_ptr，指向新创建的 undo log
    Row newRow = getRowForUpdate();
    newRow.rollPtr = header.startLsn;
    
    // 6. 执行实际的数据修改
    updateRowInMemory(newRow);
    
    // 7. 记录 redo log（为了崩溃恢复 undo log 本身）
    redoLog.write({
        type: 'undo_log',
        undoLog: record,
        lsn: getNextLsn()
    });
}
```

**版本链形成：**
```
初始数据行（trx_id=100）：
┌────────────────────────────────────────────────────┐
│  id: 1, name: '张三', age: 20                       │
│  trx_id: 100, roll_ptr: null                       │
└────────────────────────────────────────────────────┘
                         ↑
                    (update age=25)
                         │
                         ↓
修改后（trx_id=200）：
┌────────────────────────────────────────────────────┐
│  id: 1, name: '张三', age: 25                       │
│  trx_id: 200, roll_ptr: ───────────────────────────┐
└────────────────────────────────────────────────────┘
                                                        │
                                                        ↓
                                              ┌─────────────────────────────────────┐
                                              │  Undo Log (trx_id=100 时的版本)      │
                                              │  age: 20                              │
                                              │  roll_ptr: null                       │
                                              └─────────────────────────────────────┘
                                                        ↑
                                                 (update age=30)
                                                        │
                                                        ↓
修改后（trx_id=300）：
┌────────────────────────────────────────────────────┐
│  id: 1, name: '张三', age: 30                       │
│  trx_id: 300, roll_ptr: ───────────────────────────┐
└────────────────────────────────────────────────────┘
                                                        │
                                                        ↓
                                              ┌─────────────────────────────────────┐
                                              │  Undo Log (trx_id=200 时的版本)      │
                                              │  age: 25                              │
                                              │  roll_ptr: ─────────────────────────┐ │
                                              └─────────────────────────────────────┘ │
                                                                        │
                                                                        ↓
                                                              ┌───────────────────────────┐
                                                              │ Undo Log (trx_id=100)     │
                                                              │ age: 20                    │
                                                              │ roll_ptr: null             │
                                                              └───────────────────────────┘
```

**Undo Log 空间管理：**
```sql
-- 查看 undo tablespace
SHOW VARIABLES LIKE 'innodb_undo_tablespaces';

-- 默认为 2 个 undo tablespace
-- 每个 tablespace 包含多个回滚段

-- Purge 线程
-- 定期清理不再需要的 undo log
-- 条件：没有活跃事务需要该版本 + undo log 所在的事务已提交

SELECT * FROM information_schema.INNODB_TRX;  -- 查看活跃事务
SELECT * FROM information_schema.INNODB_ROLLBACK;  -- 查看回滚段
```

**Undo Log 与事务隔离：**
```java
// 读已提交（READ COMMITTED）
// 每次读都创建新的 ReadView

// 可重复读（REPEATABLE READ）
// 事务开始时创建 ReadView，整个事务复用
```

---

## 3. MVCC 视图创建时机？

**题目：**
请详细说明 MVCC 中 ReadView 的创建时机，以及不同隔离级别下的差异。

**答案：**
**ReadView 是什么：**
ReadView（读视图）是 MVCC 的核心组件，用于判断某个数据版本对当前事务是否可见。

**ReadView 结构：**
```c
struct ReadView {
    trx_id_t m_low_limit_id;      // 最大事务ID + 1，所有 >= 这个的都不可见
    trx_id_t m_up_limit_id;       // 最小活跃事务ID，所有 < 这个的都可见
    trx_id_t m_creator_trx_id;    // 当前事务ID
    std::vector<trx_id_t> m_ids;  // 活跃事务列表（>= m_up_limit_id 且 < m_low_limit_id）
    bool m_low_limit_no_trx;      // 是否没有活跃事务
};
```

**可见性判断算法：**
```c
bool isVisible(trx_id_t trx_id, trx_id_t row_trx_id) {
    // 1. 如果数据版本的事务ID等于当前事务ID，可见（自己的修改）
    if (row_trx_id == m_creator_trx_id) {
        return true;
    }
    
    // 2. 如果数据版本的事务ID小于最小活跃事务ID，可见（已提交）
    if (row_trx_id < m_up_limit_id) {
        return true;
    }
    
    // 3. 如果数据版本的事务ID大于等于最大事务ID，不可见（未开始）
    if (row_trx_id >= m_low_limit_id) {
        return false;
    }
    
    // 4. 如果数据版本的事务ID在活跃事务列表中，不可见（未提交）
    if (inActiveTransactionList(row_trx_id)) {
        return false;
    }
    
    // 5. 否则，可见（已提交）
    return true;
}
```

**图解可见性判断：**
```
时间线：
──────┬──────────────┬──────────────┬──────────────┬──────────────┬──────>
      │              │              │              │              │
    trx=100        trx=200        trx=300        trx=400        trx=500
    (提交)         (活跃)          (活跃)         (提交)       (当前事务)

当前事务 trx=400 开始时的 ReadView：
┌─────────────────────────────────────────────────────────────────┐
│  m_up_limit_id = 200    （最小活跃事务）                          │
│  m_low_limit_id = 500   （最大事务ID+1）                          │
│  m_ids = [200, 300]     （活跃事务列表）                          │
│  m_creator_trx_id = 400 （当前事务）                              │
└─────────────────────────────────────────────────────────────────┘

数据版本可见性判断：
- trx=100 < 200 → 可见 ✅
- trx=200 ∈ [200,300] 且在 m_ids 中 → 不可见 ❌
- trx=300 ∈ [200,300] 且在 m_ids 中 → 不可见 ❌
- trx=400 = 400 → 可见 ✅（自己）
- trx=500 >= 500 → 不可见 ❌（未开始）
```

**不同隔离级别的 ReadView 创建时机：**

**1. 读已提交（READ COMMITTED）**
```sql
-- 每次读取都创建新的 ReadView
SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;

-- 每次 SELECT 都会：
-- 1. 获取当前活跃事务列表
-- 2. 创建新的 ReadView
-- 3. 进行可见性判断
-- 4. 返回结果后，ReadView 释放

BEGIN;
SELECT * FROM user WHERE id = 1;  -- 创建 ReadView A
-- 看到的数据版本基于 ReadView A

-- 其他事务修改并提交了数据

SELECT * FROM user WHERE id = 1;  -- 创建 ReadView B（新的）
-- 可能看到不同的数据版本（因为 ReadView 变了）
COMMIT;
```

**2. 可重复读（REPEATABLE READ）**
```sql
-- 事务开始时创建 ReadView，整个事务复用
SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;

BEGIN;
-- ReadView 在这里创建（事务第一条 SELECT 时）
SELECT * FROM user WHERE id = 1;  -- 创建 ReadView A

-- 其他事务修改并提交了数据

SELECT * FROM user WHERE id = 1;  -- 复用 ReadView A
-- 看到的数据版本和第一次 SELECT 相同（因为 ReadView 没变）
COMMIT;
-- ReadView 释放
```

**ReadView 创建源码流程：**
```c
// InnoDB 源码流程（简化）

// 1. 读操作入口
int row_search_for_mysql(
    buf_block_t* block,    // 数据块
    dict_index_t* index,   // 索引
    ulint mode,            // 模式
    ...) {
    
    // 2. 创建 ReadView（如果是第一次读）
    ReadView* view = thr_get_read_view(thr);
    if (view == nullptr) {
        view = read_view_open_now(trx_id);
        thr_set_read_view(thr, view);
    }
    
    // 3. 判断数据是否可见
    if (!read_view_is_visible(view, block, index, entry)) {
        // 不可见，需要查找历史版本
        return row_sel_build_committed_vers(block, index, entry, view, ...);
    }
    
    // 4. 返回可见数据
    return DB_SUCCESS;
}

// 5. 可重复读模式下，ReadView 复用
void trx_commit(Transaction* tx) {
    if (tx->isolation_level == TRX_ISO_REPEATABLE_READ) {
        // 不释放 ReadView，事务结束才释放
        read_view_close_for_trx(tx->read_view);
    }
}
```

**MVCC 读取流程：**
```
┌─────────────────────────────────────────────────────────────────┐
│                    MVCC 读取流程                                 │
│                                                                  │
│  ┌─────────────┐                                                │
│  │  SELECT     │  开始读操作                                     │
│  └──────┬──────┘                                                │
│         ↓                                                       │
│  ┌─────────────┐                                                │
│  │ 创建/复用   │  ReadView                                      │
│  │ ReadView    │                                                │
│  └──────┬──────┘                                                │
│         ↓                                                       │
│  ┌─────────────┐                                                │
│  │ 读取数据页   │  从聚簇索引读取数据                             │
│  └──────┬──────┘                                                │
│         ↓                                                       │
│  ┌─────────────┐                                                │
│  │ 判断可见性   │  trx_id vs ReadView                            │
│  └──────┬──────┘                                                │
│         ↓                                                       │
│  ┌─────────────┐      ┌─────────────┐                          │
│  │ 可见 ✅     │      │ 不可见 ❌    │                          │
│  └──────┬──────┘      └──────┬──────┘                          │
│         ↓                    ↓                                  │
│  ┌─────────────┐      ┌─────────────┐                          │
│  │ 返回数据     │      │ 沿着版本链  │                          │
│  └─────────────┘      │ 查找历史版本 │                          │
│                       └──────┬──────┘                          │
│                              ↓                                  │
│                       ┌─────────────┐                          │
│                       │ 找到可见版本 │                          │
│                       └──────┬──────┘                          │
│                              ↓                                  │
│                       ┌─────────────┐                          │
│                       │ 返回历史数据  │                          │
│                       └─────────────┘                          │
└─────────────────────────────────────────────────────────────────┘
```

**ReadView 与快照的关系：**
```java
// 快照 = ReadView 的状态

// 读已提交
// 每次读都是不同的快照（ReadView 每次都新建）

// 可重复读
// 整个事务是同一个快照（ReadView 复用）
```

**实验验证：**
```sql
-- 验证可重复读
-- 终端 1：
BEGIN;
SELECT * FROM user WHERE id = 1;  -- 假设看到 age=20

-- 终端 2：
BEGIN;
UPDATE user SET age = 30 WHERE id = 1;
COMMIT;  -- 提交

-- 终端 1：
SELECT * FROM user WHERE id = 1;  -- 仍然是 age=20（可重复读）
COMMIT;  -- 提交后 ReadView 释放

-- 终端 1（重新开始）：
SELECT * FROM user WHERE id = 1;  -- 现在看到 age=30
```

**常见问题：**
```sql
-- 1. 为什么可重复读还有幻读？
--    Next-Key Lock 解决的是写操作带来的幻读
--    读操作通过 MVCC 解决

-- 2. ReadView 何时创建？
--    读已提交：每次 SELECT
--    可重复读：事务第一条 SELECT

-- 3. ReadView 何时释放？
--    读已提交：SELECT 完成后
--    可重复读：事务提交或回滚后
```

---

## 4. InnoDB 崩溃恢复流程？

**题目：**
请说明 InnoDB 崩溃恢复的完整流程。

**答案：**
**崩溃恢复触发时机：**
```c
// MySQL 启动时检测到上次异常关闭
// 检查 redo log 的状态
// 如果有未完成的提交或回滚，执行恢复流程
```

**崩溃恢复流程：**
```
┌─────────────────────────────────────────────────────────────────┐
│                    InnoDB 崩溃恢复流程                           │
│                                                                  │
│  1. 初始化                                                       │
│     ├── 读取 redo log 文件                                       │
│     ├── 找到最近的 checkpoint                                    │
│     └── 确定恢复的起始点                                          │
│                                                                  │
│  2. 分析阶段（Analysis）                                         │
│     ├── 扫描 redo log                                           │
│     ├── 收集所有未完成的事务                                     │
│     └── 收集所有已提交但未刷盘的事务                              │
│                                                                  │
│  3. 重做阶段（Redo）                                             │
│     ├── 从 checkpoint 开始重放 redo log                         │
│     ├── 恢复到崩溃前的状态                                       │
│     └── 注意：只重做，不回滚                                      │
│                                                                  │
│  4. 回滚阶段（Undo）                                             │
│     ├── 回滚未提交的事务                                         │
│     ├── 读取 undo log                                           │
│     └── 执行反向操作                                             │
│                                                                  │
│  5. 完成恢复                                                     │
│     ├── 清理 undo log                                           │
│     └── 启动 MySQL 服务                                          │
└─────────────────────────────────────────────────────────────────┘
```

**详细恢复步骤：**
```c
void innodb_recovery() {
    // 1. 找到最近的 checkpoint
    CheckpointInfo cp = findLatestCheckpoint();
    lsn_t start_lsn = cp.lsn;
    
    // 2. 读取 redo log 到内存
    LogBuffer* log_buffer = readRedoLog(start_lsn);
    
    // 3. 分析 redo log
    TransactionList active_txns = analyzeLog(log_buffer);
    TransactionList committed_txns = analyzeCommitted(log_buffer);
    
    // 4. 重做（Redo）阶段
    for (lsn = start_lsn; lsn < log_buffer.end; ) {
        LogRecord* record = parseLogRecord(lsn);
        
        if (record.type == UPDATE) {
            // 重做更新操作
            applyRedoRecord(record);
        }
        
        lsn = getNextRecordLsn(lsn);
    }
    
    // 5. 回滚（Undo）阶段
    for (Transaction* txn : active_txns) {
        // 获取该事务的 undo log
        UndoLog* undo = getUndoLog(txn.id);
        
        // 逆向执行 undo log
        while (undo != null) {
            applyUndoLog(undo);  // 执行反向操作
            undo = undo.prev;    // 沿着版本链
        }
    }
    
    // 6. 清理
    purgeUndoLogs();
    flushDirtyPages();
}
```

**崩溃恢复场景：**
```sql
-- 场景1：事务执行中崩溃（未提交）
-- 恢复：回滚该事务的所有修改

-- 场景2：事务提交中崩溃（redo prepare 完成，commit 未完成）
-- 恢复：该事务提交（redo log 已有记录）

-- 场景3：事务提交完成，但数据页未刷盘
-- 恢复：通过 redo log 恢复数据页

-- 场景4：数据页刷盘完成，redo log 未刷盘
-- 恢复：不需要处理（数据已在磁盘）
```

---

## 5. Binlog 与 Redo Log 的区别？

**题目：**
MySQL 的 Binlog 和 Redo Log 有什么区别？

**答案：**
**两种日志对比：**

| 特性 | Binlog | Redo Log |
|------|--------|----------|
| **所属层次** | MySQL Server 层 | InnoDB 存储引擎层 |
| **日志类型** | 逻辑日志（SQL 语句） | 物理日志（数据页修改） |
| **记录内容** | 数据变更的逻辑操作 | 数据页的物理变更 |
| **作用** | 主从复制、数据恢复 | 崩溃恢复 |
| **写入方式** | 顺序写入 | 循环写入 |
| **刷盘策略** | sync_binlog 参数 | innodb_flush_log_at_trx_commit |
| **空间** | 追加写入，需要手动清理 | 循环使用 |
| **格式** | STATEMENT/ROW/MIXED | 固定的物理格式 |

**两种日志的协作：**
```
┌─────────────────────────────────────────────────────────────────┐
│                    事务提交时的日志写入                           │
│                                                                  │
│  ┌─────────┐     ┌─────────┐     ┌─────────┐     ┌─────────┐   │
│  │ 事务    │────>│ Redo    │────>│ Binlog  │────>│ Redo    │   │
│  │ 开始    │     │ prepare │     │ write   │     │ commit  │   │
│  └─────────┘     └─────────┘     └─────────┘     └─────────┘   │
│                         ↓                      ↓                │
│                   记录到内存           记录到内存          刷盘  │
└─────────────────────────────────────────────────────────────────┘

两阶段提交的目的：
保证 Binlog 和 Redo Log 的一致性
```

**为什么需要两种日志：**
```java
// 1. 职责不同
//    Binlog：用于复制和外部恢复（mysqldump、binlog恢复）
//    Redo Log：用于崩溃恢复

// 2. 层次不同
//    Binlog：Server 层，所有存储引擎都有
//    Redo Log：InnoDB 特有

// 3. 恢复能力不同
//    Binlog：可以恢复到任意时间点
//    Redo Log：只能恢复到最近一次 checkpoint
```

**数据恢复场景：**
```bash
# 使用 Binlog 恢复到某个时间点
mysqlbinlog --start-datetime="2025-01-01 10:00:00" \
            --stop-datetime="2025-01-01 11:00:00" \
            mysql-bin.000001 | mysql -u root -p

# 使用 Redo Log 崩溃恢复
# MySQL 自动完成，不需要手动操作
```

**删除策略：**
```sql
-- Binlog 手动清理
PURGE BINARY LOGS BEFORE '2025-01-01';
SHOW BINARY LOGS;

-- 设置过期时间
SHOW VARIABLES LIKE 'expire_logs_days';
SET GLOBAL expire_logs_days = 7;

-- Redo Log 自动循环
-- 当 redo log 空间不足时，自动触发 checkpoint
-- 覆盖旧的日志
```

---
## MySQL 高级面试题
# MySQL 高级面试题

## 题目

**题目：**
请详细说明 InnoDB Redo Log 的写入机制，包括 WAL 和两阶段提交。

**答案：**
**Redo Log 是什么：**
Redo Log 是 InnoDB 引擎的物理日志，记录数据页的物理修改，用于崩溃恢复。

**Redo Log 结构：**
```
┌─────────────────────────────────────────────────────┐
│                   Redo Log Buffer                    │
│  ┌─────────┬─────────┬─────────┬─────────┐          │
│  │ Log Seq │ Log Seq │ Log Seq │ Log Seq │          │
│  │ Number  │ Number  │ Number  │ Number  │          │
│  │   1000  │   1001  │   1002  │   1003  │          │← lsn
│  └─────────┴─────────┴─────────┴─────────┘          │
└─────────────────────────────────────────────────────┘
                    ↓ fsync
┌─────────────────────────────────────────────────────┐
│                   Redo Log File                      │
│  ┌─────────┬─────────┬─────────┬─────────┐          │
│  │ redo_01 │ redo_02 │ redo_03 │ redo_04 │  循环使用 │
│  └─────────┴─────────┴─────────┴─────────┘          │
│                      checkpoint                     │
└─────────────────────────────────────────────────────┘
```

**Write-Ahead Logging（WAL）：**
```c
// 核心原则：先写日志，再写数据
// 1. 修改数据页之前，先记录 redo log
// 2. redo log 写入成功后，才修改内存数据页
// 3. 数据页的修改可以延迟，但日志不能延迟
```

**写入流程：**
```java
// 事务执行流程
void executeTransaction(Transaction tx) {
    // 1. 事务开始
    tx.begin();
    
    // 2. 执行 SQL，修改数据
    update user set age = 25 where id = 1;
    
    // 3. 记录 redo log（prepare 阶段）
    redoLog.write({
        type: 'update',
        tableId: 1,
        pageNo: 100,
        offset: 200,
        before: { age: 20 },
        after: { age: 25 },
        trxId: tx.id,
        lsn: currentLsn  // 比如 1000
    });
    
    // 4. 写 binlog（两阶段提交）
    binlog.write(tx.sql);
    
    // 5. redo log 标记为 commit
    redoLog.markCommit(currentLsn);
    
    // 6. 事务提交完成
    tx.commit();
}
```

**LSN（Log Sequence Number）：**
```c
// LSN 递增序列
// 1. redo log buffer 中的 LSN
// 2. 写入磁盘后的 LSN（flushed_to_disk_lsn）
// 3. checkpoint LSN

// 关系：
// checkpoint_lsn ≤ flushed_to_disk_lsn ≤ current_lsn
```

**Redo Log 刷盘策略：**
```sql
-- innodb_flush_log_at_trx_commit 参数
-- 0：每秒刷盘（可能丢失1秒数据）
-- 1：每次提交刷盘（最安全，默认）
-- 2：每次提交写操作系统缓存，由操作系统刷盘

SET GLOBAL innodb_flush_log_at_trx_commit = 1;  -- 生产环境用这个
```

**两阶段提交：**
```
┌──────────────────────────────────────────────────────────────────┐
│                     两阶段提交                                    │
│                                                                  │
│  ┌─────────┐     ┌─────────┐     ┌─────────┐     ┌─────────┐   │
│  │ 事务    │────>│ Redo    │────>│ Binlog  │────>│ Redo    │   │
│  │ 开始    │     │ prepare │     │ write   │     │ commit  │   │
│  └─────────┘     └─────────┘     └─────────┘     └─────────┘   │
│                         ↓                      ↓                │
│                   崩溃恢复点            提交完成                │
└──────────────────────────────────────────────────────────────────┘

崩溃恢复场景：
1. 如果 redo prepare 之前崩溃 → 事务回滚
2. 如果 redo prepare 之后、binlog 之前崩溃 → 事务回滚
3. 如果 binlog 之后、redo commit 之前崩溃 → 事务恢复
```

**Redo Log 循环：**
```
┌────────────────────────────────────────────────────┐
│                    Redo Log 循环                    │
│                                                    │
│  ┌──────────────────────────────────────────────┐ │
│  │              已写入磁盘区域                    │ │
│  │    ┌────────────────────────────┐            │ │
│  │    │   checkpoint LSN ←─────────┼── 可覆盖   │ │
│  │    └────────────────────────────┘            │ │
│  │              活跃日志区域                      │ │
│  │    ┌────────────────────────────┐            │ │
│  │    │   current LSN ─────────────┼── 正在写入 │    └──────────────────────── │
│  │────┘            │ │
│  └──────────────────────────────────────────────┘ │
└────────────────────────────────────────────────────┘

当活跃日志区域满时：
1. 触发 checkpoint
2. 刷新脏页到磁盘
3. 更新 checkpoint LSN
4. 释放空间继续使用
```

---

## 2. Undo Log 写入机制？

**题目：**
请详细说明 InnoDB Undo Log 的写入机制，包括回滚段和版本链。

**答案：**
**Undo Log 是什么：**
Undo Log 是逻辑日志，记录数据的旧版本，用于事务回滚和 MVCC。

**Undo Log 作用：**
```java
// 1. 事务回滚
//    事务失败时，恢复到事务开始前的状态

// 2. MVCC 读
//    读取事务开始时的快照版本

// 3. 崩溃恢复
//    回滚未提交的事务
```

**Undo Log 结构：**
```
┌─────────────────────────────────────────────────────────────┐
│                    Undo Log 结构                            │
│                                                              │
│  ┌─────────────────────────────────────────────────────┐   │
│  │                  回滚段（Rollback Segment）          │   │
│  │  ┌───────────────────────────────────────────────┐  │   │
│  │  │  Undo Segment 0  (系统表空间)                  │  │   │
│  │  │  Undo Segment 1  (用户表空间)                  │  │   │
│  │  │  Undo Segment 2                               │  │   │
│  │  │  ...                                           │  │   │
│  │  │  Undo Segment 127                             │  │   │
│  │  └───────────────────────────────────────────────┘  │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                              │
│  ┌─────────────────────────────────────────────────────┐   │
│  │                  Undo Log 链表                       │   │
│  │                                                              │
│  │  ┌─────────┐    ┌─────────┐    ┌─────────┐         │   │
│  │  │  Update │───>│  Update │───>│  Insert │         │   │
│  │  │  Undo   │    │  Undo   │    │  Undo   │         │   │
│  │  │  Log    │    │  Log    │    │  Log    │         │   │
│  │  └─────────┘    └─────────┘    └─────────┘         │   │
│  │     ↑                                            │   │
│  │     │                                            │   │
│  │  DB_ROLL_PTR                                     │   │
│  │  (回滚指针)                                       │   │
└─────────────────────────────────────────────────────────────┘
```

**Undo Log 类型：**
```sql
-- 1. Insert Undo Log
--    插入操作产生的 undo log
--    事务提交后可以直接删除

-- 2. Update Undo Log
--    更新/删除操作产生的 undo log
--    需要支持 MVCC，其他事务可能正在使用
--    事务提交后进入 history list，等待purge
```

**写入流程：**
```java
void executeUpdate(Transaction tx, String sql) {
    // 1. 分配 undo segment
    UndoSegment segment = tx.getUndoSegment();
    
    // 2. 创建 undo log header
    UndoLogHeader header = segment.allocUndoLogHeader();
    header.trxId = tx.id;
    header.trxSeq = tx.sequence;
    header.trxRollPtr = 0;
    
    // 3. 记录修改前的数据（old version）
    Row oldRow = getCurrentRow();
    UndoLogRecord record = new UndoLogRecord();
    record.type = UPDATE;  // 或 INSERT
    record.oldData = oldRow.serialize();
    record.tableId = oldRow.tableId;
    record.pageId = oldRow.pageId;
    
    // 4. 将 undo log 写入 undo tablespace
    undoSpace.write(header, record);
    
    // 5. 更新数据行的 roll_ptr，指向新创建的 undo log
    Row newRow = getRowForUpdate();
    newRow.rollPtr = header.startLsn;
    
    // 6. 执行实际的数据修改
    updateRowInMemory(newRow);
    
    // 7. 记录 redo log（为了崩溃恢复 undo log 本身）
    redoLog.write({
        type: 'undo_log',
        undoLog: record,
        lsn: getNextLsn()
    });
}
```

**版本链形成：**
```
初始数据行（trx_id=100）：
┌────────────────────────────────────────────────────┐
│  id: 1, name: '张三', age: 20                       │
│  trx_id: 100, roll_ptr: null                       │
└────────────────────────────────────────────────────┘
                         ↑
                    (update age=25)
                         │
                         ↓
修改后（trx_id=200）：
┌────────────────────────────────────────────────────┐
│  id: 1, name: '张三', age: 25                       │
│  trx_id: 200, roll_ptr: ───────────────────────────┐
└────────────────────────────────────────────────────┘
                                                        │
                                                        ↓
                                              ┌─────────────────────────────────────┐
                                              │  Undo Log (trx_id=100 时的版本)      │
                                              │  age: 20                              │
                                              │  roll_ptr: null                       │
                                              └─────────────────────────────────────┘
                                                        ↑
                                                 (update age=30)
                                                        │
                                                        ↓
修改后（trx_id=300）：
┌────────────────────────────────────────────────────┐
│  id: 1, name: '张三', age: 30                       │
│  trx_id: 300, roll_ptr: ───────────────────────────┐
└────────────────────────────────────────────────────┘
                                                        │
                                                        ↓
                                              ┌─────────────────────────────────────┐
                                              │  Undo Log (trx_id=200 时的版本)      │
                                              │  age: 25                              │
                                              │  roll_ptr: ─────────────────────────┐ │
                                              └─────────────────────────────────────┘ │
                                                                        │
                                                                        ↓
                                                              ┌───────────────────────────┐
                                                              │ Undo Log (trx_id=100)     │
                                                              │ age: 20                    │
                                                              │ roll_ptr: null             │
                                                              └───────────────────────────┘
```

**Undo Log 空间管理：**
```sql
-- 查看 undo tablespace
SHOW VARIABLES LIKE 'innodb_undo_tablespaces';

-- 默认为 2 个 undo tablespace
-- 每个 tablespace 包含多个回滚段

-- Purge 线程
-- 定期清理不再需要的 undo log
-- 条件：没有活跃事务需要该版本 + undo log 所在的事务已提交

SELECT * FROM information_schema.INNODB_TRX;  -- 查看活跃事务
SELECT * FROM information_schema.INNODB_ROLLBACK;  -- 查看回滚段
```

**Undo Log 与事务隔离：**
```java
// 读已提交（READ COMMITTED）
// 每次读都创建新的 ReadView

// 可重复读（REPEATABLE READ）
// 事务开始时创建 ReadView，整个事务复用
```

---

## 3. MVCC 视图创建时机？

**题目：**
请详细说明 MVCC 中 ReadView 的创建时机，以及不同隔离级别下的差异。

**答案：**
**ReadView 是什么：**
ReadView（读视图）是 MVCC 的核心组件，用于判断某个数据版本对当前事务是否可见。

**ReadView 结构：**
```c
struct ReadView {
    trx_id_t m_low_limit_id;      // 最大事务ID + 1，所有 >= 这个的都不可见
    trx_id_t m_up_limit_id;       // 最小活跃事务ID，所有 < 这个的都可见
    trx_id_t m_creator_trx_id;    // 当前事务ID
    std::vector<trx_id_t> m_ids;  // 活跃事务列表（>= m_up_limit_id 且 < m_low_limit_id）
    bool m_low_limit_no_trx;      // 是否没有活跃事务
};
```

**可见性判断算法：**
```c
bool isVisible(trx_id_t trx_id, trx_id_t row_trx_id) {
    // 1. 如果数据版本的事务ID等于当前事务ID，可见（自己的修改）
    if (row_trx_id == m_creator_trx_id) {
        return true;
    }
    
    // 2. 如果数据版本的事务ID小于最小活跃事务ID，可见（已提交）
    if (row_trx_id < m_up_limit_id) {
        return true;
    }
    
    // 3. 如果数据版本的事务ID大于等于最大事务ID，不可见（未开始）
    if (row_trx_id >= m_low_limit_id) {
        return false;
    }
    
    // 4. 如果数据版本的事务ID在活跃事务列表中，不可见（未提交）
    if (inActiveTransactionList(row_trx_id)) {
        return false;
    }
    
    // 5. 否则，可见（已提交）
    return true;
}
```

**图解可见性判断：**
```
时间线：
──────┬──────────────┬──────────────┬──────────────┬──────────────┬──────>
      │              │              │              │              │
    trx=100        trx=200        trx=300        trx=400        trx=500
    (提交)         (活跃)          (活跃)         (提交)       (当前事务)

当前事务 trx=400 开始时的 ReadView：
┌─────────────────────────────────────────────────────────────────┐
│  m_up_limit_id = 200    （最小活跃事务）                          │
│  m_low_limit_id = 500   （最大事务ID+1）                          │
│  m_ids = [200, 300]     （活跃事务列表）                          │
│  m_creator_trx_id = 400 （当前事务）                              │
└─────────────────────────────────────────────────────────────────┘

数据版本可见性判断：
- trx=100 < 200 → 可见 ✅
- trx=200 ∈ [200,300] 且在 m_ids 中 → 不可见 ❌
- trx=300 ∈ [200,300] 且在 m_ids 中 → 不可见 ❌
- trx=400 = 400 → 可见 ✅（自己）
- trx=500 >= 500 → 不可见 ❌（未开始）
```

**不同隔离级别的 ReadView 创建时机：**

**1. 读已提交（READ COMMITTED）**
```sql
-- 每次读取都创建新的 ReadView
SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;

-- 每次 SELECT 都会：
-- 1. 获取当前活跃事务列表
-- 2. 创建新的 ReadView
-- 3. 进行可见性判断
-- 4. 返回结果后，ReadView 释放

BEGIN;
SELECT * FROM user WHERE id = 1;  -- 创建 ReadView A
-- 看到的数据版本基于 ReadView A

-- 其他事务修改并提交了数据

SELECT * FROM user WHERE id = 1;  -- 创建 ReadView B（新的）
-- 可能看到不同的数据版本（因为 ReadView 变了）
COMMIT;
```

**2. 可重复读（REPEATABLE READ）**
```sql
-- 事务开始时创建 ReadView，整个事务复用
SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;

BEGIN;
-- ReadView 在这里创建（事务第一条 SELECT 时）
SELECT * FROM user WHERE id = 1;  -- 创建 ReadView A

-- 其他事务修改并提交了数据

SELECT * FROM user WHERE id = 1;  -- 复用 ReadView A
-- 看到的数据版本和第一次 SELECT 相同（因为 ReadView 没变）
COMMIT;
-- ReadView 释放
```

**ReadView 创建源码流程：**
```c
// InnoDB 源码流程（简化）

// 1. 读操作入口
int row_search_for_mysql(
    buf_block_t* block,    // 数据块
    dict_index_t* index,   // 索引
    ulint mode,            // 模式
    ...) {
    
    // 2. 创建 ReadView（如果是第一次读）
    ReadView* view = thr_get_read_view(thr);
    if (view == nullptr) {
        view = read_view_open_now(trx_id);
        thr_set_read_view(thr, view);
    }
    
    // 3. 判断数据是否可见
    if (!read_view_is_visible(view, block, index, entry)) {
        // 不可见，需要查找历史版本
        return row_sel_build_committed_vers(block, index, entry, view, ...);
    }
    
    // 4. 返回可见数据
    return DB_SUCCESS;
}

// 5. 可重复读模式下，ReadView 复用
void trx_commit(Transaction* tx) {
    if (tx->isolation_level == TRX_ISO_REPEATABLE_READ) {
        // 不释放 ReadView，事务结束才释放
        read_view_close_for_trx(tx->read_view);
    }
}
```

**MVCC 读取流程：**
```
┌─────────────────────────────────────────────────────────────────┐
│                    MVCC 读取流程                                 │
│                                                                  │
│  ┌─────────────┐                                                │
│  │  SELECT     │  开始读操作                                     │
│  └──────┬──────┘                                                │
│         ↓                                                       │
│  ┌─────────────┐                                                │
│  │ 创建/复用   │  ReadView                                      │
│  │ ReadView    │                                                │
│  └──────┬──────┘                                                │
│         ↓                                                       │
│  ┌─────────────┐                                                │
│  │ 读取数据页   │  从聚簇索引读取数据                             │
│  └──────┬──────┘                                                │
│         ↓                                                       │
│  ┌─────────────┐                                                │
│  │ 判断可见性   │  trx_id vs ReadView                            │
│  └──────┬──────┘                                                │
│         ↓                                                       │
│  ┌─────────────┐      ┌─────────────┐                          │
│  │ 可见 ✅     │      │ 不可见 ❌    │                          │
│  └──────┬──────┘      └──────┬──────┘                          │
│         ↓                    ↓                                  │
│  ┌─────────────┐      ┌─────────────┐                          │
│  │ 返回数据     │      │ 沿着版本链  │                          │
│  └─────────────┘      │ 查找历史版本 │                          │
│                       └──────┬──────┘                          │
│                              ↓                                  │
│                       ┌─────────────┐                          │
│                       │ 找到可见版本 │                          │
│                       └──────┬──────┘                          │
│                              ↓                                  │
│                       ┌─────────────┐                          │
│                       │ 返回历史数据  │                          │
│                       └─────────────┘                          │
└─────────────────────────────────────────────────────────────────┘
```

**ReadView 与快照的关系：**
```java
// 快照 = ReadView 的状态

// 读已提交
// 每次读都是不同的快照（ReadView 每次都新建）

// 可重复读
// 整个事务是同一个快照（ReadView 复用）
```

**实验验证：**
```sql
-- 验证可重复读
-- 终端 1：
BEGIN;
SELECT * FROM user WHERE id = 1;  -- 假设看到 age=20

-- 终端 2：
BEGIN;
UPDATE user SET age = 30 WHERE id = 1;
COMMIT;  -- 提交

-- 终端 1：
SELECT * FROM user WHERE id = 1;  -- 仍然是 age=20（可重复读）
COMMIT;  -- 提交后 ReadView 释放

-- 终端 1（重新开始）：
SELECT * FROM user WHERE id = 1;  -- 现在看到 age=30
```

**常见问题：**
```sql
-- 1. 为什么可重复读还有幻读？
--    Next-Key Lock 解决的是写操作带来的幻读
--    读操作通过 MVCC 解决

-- 2. ReadView 何时创建？
--    读已提交：每次 SELECT
--    可重复读：事务第一条 SELECT

-- 3. ReadView 何时释放？
--    读已提交：SELECT 完成后
--    可重复读：事务提交或回滚后
```

---

## 4. InnoDB 崩溃恢复流程？

**题目：**
请说明 InnoDB 崩溃恢复的完整流程。

**答案：**
**崩溃恢复触发时机：**
```c
// MySQL 启动时检测到上次异常关闭
// 检查 redo log 的状态
// 如果有未完成的提交或回滚，执行恢复流程
```

**崩溃恢复流程：**
```
┌─────────────────────────────────────────────────────────────────┐
│                    InnoDB 崩溃恢复流程                           │
│                                                                  │
│  1. 初始化                                                       │
│     ├── 读取 redo log 文件                                       │
│     ├── 找到最近的 checkpoint                                    │
│     └── 确定恢复的起始点                                          │
│                                                                  │
│  2. 分析阶段（Analysis）                                         │
│     ├── 扫描 redo log                                           │
│     ├── 收集所有未完成的事务                                     │
│     └── 收集所有已提交但未刷盘的事务                              │
│                                                                  │
│  3. 重做阶段（Redo）                                             │
│     ├── 从 checkpoint 开始重放 redo log                         │
│     ├── 恢复到崩溃前的状态                                       │
│     └── 注意：只重做，不回滚                                      │
│                                                                  │
│  4. 回滚阶段（Undo）                                             │
│     ├── 回滚未提交的事务                                         │
│     ├── 读取 undo log                                           │
│     └── 执行反向操作                                             │
│                                                                  │
│  5. 完成恢复                                                     │
│     ├── 清理 undo log                                           │
│     └── 启动 MySQL 服务                                          │
└─────────────────────────────────────────────────────────────────┘
```

**详细恢复步骤：**
```c
void innodb_recovery() {
    // 1. 找到最近的 checkpoint
    CheckpointInfo cp = findLatestCheckpoint();
    lsn_t start_lsn = cp.lsn;
    
    // 2. 读取 redo log 到内存
    LogBuffer* log_buffer = readRedoLog(start_lsn);
    
    // 3. 分析 redo log
    TransactionList active_txns = analyzeLog(log_buffer);
    TransactionList committed_txns = analyzeCommitted(log_buffer);
    
    // 4. 重做（Redo）阶段
    for (lsn = start_lsn; lsn < log_buffer.end; ) {
        LogRecord* record = parseLogRecord(lsn);
        
        if (record.type == UPDATE) {
            // 重做更新操作
            applyRedoRecord(record);
        }
        
        lsn = getNextRecordLsn(lsn);
    }
    
    // 5. 回滚（Undo）阶段
    for (Transaction* txn : active_txns) {
        // 获取该事务的 undo log
        UndoLog* undo = getUndoLog(txn.id);
        
        // 逆向执行 undo log
        while (undo != null) {
            applyUndoLog(undo);  // 执行反向操作
            undo = undo.prev;    // 沿着版本链
        }
    }
    
    // 6. 清理
    purgeUndoLogs();
    flushDirtyPages();
}
```

**崩溃恢复场景：**
```sql
-- 场景1：事务执行中崩溃（未提交）
-- 恢复：回滚该事务的所有修改

-- 场景2：事务提交中崩溃（redo prepare 完成，commit 未完成）
-- 恢复：该事务提交（redo log 已有记录）

-- 场景3：事务提交完成，但数据页未刷盘
-- 恢复：通过 redo log 恢复数据页

-- 场景4：数据页刷盘完成，redo log 未刷盘
-- 恢复：不需要处理（数据已在磁盘）
```

---

## 5. Binlog 与 Redo Log 的区别？

**题目：**
MySQL 的 Binlog 和 Redo Log 有什么区别？

**答案：**
**两种日志对比：**

| 特性 | Binlog | Redo Log |
|------|--------|----------|
| **所属层次** | MySQL Server 层 | InnoDB 存储引擎层 |
| **日志类型** | 逻辑日志（SQL 语句） | 物理日志（数据页修改） |
| **记录内容** | 数据变更的逻辑操作 | 数据页的物理变更 |
| **作用** | 主从复制、数据恢复 | 崩溃恢复 |
| **写入方式** | 顺序写入 | 循环写入 |
| **刷盘策略** | sync_binlog 参数 | innodb_flush_log_at_trx_commit |
| **空间** | 追加写入，需要手动清理 | 循环使用 |
| **格式** | STATEMENT/ROW/MIXED | 固定的物理格式 |

**两种日志的协作：**
```
┌─────────────────────────────────────────────────────────────────┐
│                    事务提交时的日志写入                           │
│                                                                  │
│  ┌─────────┐     ┌─────────┐     ┌─────────┐     ┌─────────┐   │
│  │ 事务    │────>│ Redo    │────>│ Binlog  │────>│ Redo    │   │
│  │ 开始    │     │ prepare │     │ write   │     │ commit  │   │
│  └─────────┘     └─────────┘     └─────────┘     └─────────┘   │
│                         ↓                      ↓                │
│                   记录到内存           记录到内存          刷盘  │
└─────────────────────────────────────────────────────────────────┘

两阶段提交的目的：
保证 Binlog 和 Redo Log 的一致性
```

**为什么需要两种日志：**
```java
// 1. 职责不同
//    Binlog：用于复制和外部恢复（mysqldump、binlog恢复）
//    Redo Log：用于崩溃恢复

// 2. 层次不同
//    Binlog：Server 层，所有存储引擎都有
//    Redo Log：InnoDB 特有

// 3. 恢复能力不同
//    Binlog：可以恢复到任意时间点
//    Redo Log：只能恢复到最近一次 checkpoint
```

**数据恢复场景：**
```bash
# 使用 Binlog 恢复到某个时间点
mysqlbinlog --start-datetime="2025-01-01 10:00:00" \
            --stop-datetime="2025-01-01 11:00:00" \
            mysql-bin.000001 | mysql -u root -p

# 使用 Redo Log 崩溃恢复
# MySQL 自动完成，不需要手动操作
```

**删除策略：**
```sql
-- Binlog 手动清理
PURGE BINARY LOGS BEFORE '2025-01-01';
SHOW BINARY LOGS;

-- 设置过期时间
SHOW VARIABLES LIKE 'expire_logs_days';
SET GLOBAL expire_logs_days = 7;

-- Redo Log 自动循环
-- 当 redo log 空间不足时，自动触发 checkpoint
-- 覆盖旧的日志
```

## 答案

**题目：**
请详细说明 InnoDB Redo Log 的写入机制，包括 WAL 和两阶段提交。

**答案：**
**Redo Log 是什么：**
Redo Log 是 InnoDB 引擎的物理日志，记录数据页的物理修改，用于崩溃恢复。

**Redo Log 结构：**
```
┌─────────────────────────────────────────────────────┐
│                   Redo Log Buffer                    │
│  ┌─────────┬─────────┬─────────┬─────────┐          │
│  │ Log Seq │ Log Seq │ Log Seq │ Log Seq │          │
│  │ Number  │ Number  │ Number  │ Number  │          │
│  │   1000  │   1001  │   1002  │   1003  │          │← lsn
│  └─────────┴─────────┴─────────┴─────────┘          │
└─────────────────────────────────────────────────────┘
                    ↓ fsync
┌─────────────────────────────────────────────────────┐
│                   Redo Log File                      │
│  ┌─────────┬─────────┬─────────┬─────────┐          │
│  │ redo_01 │ redo_02 │ redo_03 │ redo_04 │  循环使用 │
│  └─────────┴─────────┴─────────┴─────────┘          │
│                      checkpoint                     │
└─────────────────────────────────────────────────────┘
```

**Write-Ahead Logging（WAL）：**
```c
// 核心原则：先写日志，再写数据
// 1. 修改数据页之前，先记录 redo log
// 2. redo log 写入成功后，才修改内存数据页
// 3. 数据页的修改可以延迟，但日志不能延迟
```

**写入流程：**
```java
// 事务执行流程
void executeTransaction(Transaction tx) {
    // 1. 事务开始
    tx.begin();
    
    // 2. 执行 SQL，修改数据
    update user set age = 25 where id = 1;
    
    // 3. 记录 redo log（prepare 阶段）
    redoLog.write({
        type: 'update',
        tableId: 1,
        pageNo: 100,
        offset: 200,
        before: { age: 20 },
        after: { age: 25 },
        trxId: tx.id,
        lsn: currentLsn  // 比如 1000
    });
    
    // 4. 写 binlog（两阶段提交）
    binlog.write(tx.sql);
    
    // 5. redo log 标记为 commit
    redoLog.markCommit(currentLsn);
    
    // 6. 事务提交完成
    tx.commit();
}
```

**LSN（Log Sequence Number）：**
```c
// LSN 递增序列
// 1. redo log buffer 中的 LSN
// 2. 写入磁盘后的 LSN（flushed_to_disk_lsn）
// 3. checkpoint LSN

// 关系：
// checkpoint_lsn ≤ flushed_to_disk_lsn ≤ current_lsn
```

**Redo Log 刷盘策略：**
```sql
-- innodb_flush_log_at_trx_commit 参数
-- 0：每秒刷盘（可能丢失1秒数据）
-- 1：每次提交刷盘（最安全，默认）
-- 2：每次提交写操作系统缓存，由操作系统刷盘

SET GLOBAL innodb_flush_log_at_trx_commit = 1;  -- 生产环境用这个
```

**两阶段提交：**
```
┌──────────────────────────────────────────────────────────────────┐
│                     两阶段提交                                    │
│                                                                  │
│  ┌─────────┐     ┌─────────┐     ┌─────────┐     ┌─────────┐   │
│  │ 事务    │────>│ Redo    │────>│ Binlog  │────>│ Redo    │   │
│  │ 开始    │     │ prepare │     │ write   │     │ commit  │   │
│  └─────────┘     └─────────┘     └─────────┘     └─────────┘   │
│                         ↓                      ↓                │
│                   崩溃恢复点            提交完成                │
└──────────────────────────────────────────────────────────────────┘

崩溃恢复场景：
1. 如果 redo prepare 之前崩溃 → 事务回滚
2. 如果 redo prepare 之后、binlog 之前崩溃 → 事务回滚
3. 如果 binlog 之后、redo commit 之前崩溃 → 事务恢复
```

**Redo Log 循环：**
```
┌────────────────────────────────────────────────────┐
│                    Redo Log 循环                    │
│                                                    │
│  ┌──────────────────────────────────────────────┐ │
│  │              已写入磁盘区域                    │ │
│  │    ┌────────────────────────────┐            │ │
│  │    │   checkpoint LSN ──────────┼── 可覆盖   │ │
│  │    └────────────────────────────┘            │ │
│  │              活跃日志区域                      │ │
│  │    ┌────────────────────────────┐            │ │
│  │    │   current LSN ─────────────┼── 正在写入 │    └──────────────────────── │
│  │────┘            │ │
│  └──────────────────────────────────────────────┘ │
└────────────────────────────────────────────────────┘

当活跃日志区域满时：
1. 触发 checkpoint
2. 刷新脏页到磁盘
3. 更新 checkpoint LSN
4. 释放空间继续使用
```

---

## 2. Undo Log 写入机制？

**题目：**
请详细说明 InnoDB Undo Log 的写入机制，包括回滚段和版本链。

**答案：**
**Undo Log 是什么：**
Undo Log 是逻辑日志，记录数据的旧版本，用于事务回滚和 MVCC。

**Undo Log 作用：**
```java
// 1. 事务回滚
//    事务失败时，恢复到事务开始前的状态

// 2. MVCC 读
//    读取事务开始时的快照版本

// 3. 崩溃恢复
//    回滚未提交的事务
```

**Undo Log 结构：**
```
┌─────────────────────────────────────────────────────────────┐
│                    Undo Log 结构                            │
│                                                              │
│  ┌─────────────────────────────────────────────────────┐   │
│  │                  回滚段（Rollback Segment）          │   │
│  │  ┌───────────────────────────────────────────────┐  │   │
│  │  │  Undo Segment 0  (系统表空间)                  │  │   │
│  │  │  Undo Segment 1  (用户表空间)                  │  │   │
│  │  │  Undo Segment 2                               │  │   │
│  │  │  ...                                           │  │   │
│  │  │  Undo Segment 127                             │  │   │
│  │  └───────────────────────────────────────────────┘  │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                              │
│  ┌─────────────────────────────────────────────────────┐   │
│  │                  Undo Log 链表                       │   │
│  │                                                              │
│  │  ┌─────────┐    ┌─────────┐    ┌─────────┐         │   │
│  │  │  Update │───>│  Update │───>│  Insert │         │   │
│  │  │  Undo   │    │  Undo   │    │  Undo   │         │   │
│  │  │  Log    │    │  Log    │    │  Log    │         │   │
│  │  └─────────┘    └─────────┘    └─────────┘         │   │
│  │     ↑                                            │   │
│  │     │                                            │   │
│  │  DB_ROLL_PTR                                     │   │
│  │  (回滚指针)                                       │   │
└─────────────────────────────────────────────────────────────┘
```

**Undo Log 类型：**
```sql
-- 1. Insert Undo Log
--    插入操作产生的 undo log
--    事务提交后可以直接删除

-- 2. Update Undo Log
--    更新/删除操作产生的 undo log
--    需要支持 MVCC，其他事务可能正在使用
--    事务提交后进入 history list，等待purge
```

**写入流程：**
```java
void executeUpdate(Transaction tx, String sql) {
    // 1. 分配 undo segment
    UndoSegment segment = tx.getUndoSegment();
    
    // 2. 创建 undo log header
    UndoLogHeader header = segment.allocUndoLogHeader();
    header.trxId = tx.id;
    header.trxSeq = tx.sequence;
    header.trxRollPtr = 0;
    
    // 3. 记录修改前的数据（old version）
    Row oldRow = getCurrentRow();
    UndoLogRecord record = new UndoLogRecord();
    record.type = UPDATE;  // 或 INSERT
    record.oldData = oldRow.serialize();
    record.tableId = oldRow.tableId;
    record.pageId = oldRow.pageId;
    
    // 4. 将 undo log 写入 undo tablespace
    undoSpace.write(header, record);
    
    // 5. 更新数据行的 roll_ptr，指向新创建的 undo log
    Row newRow = getRowForUpdate();
    newRow.rollPtr = header.startLsn;
    
    // 6. 执行实际的数据修改
    updateRowInMemory(newRow);
    
    // 7. 记录 redo log（为了崩溃恢复 undo log 本身）
    redoLog.write({
        type: 'undo_log',
        undoLog: record,
        lsn: getNextLsn()
    });
}
```

**版本链形成：**
```
初始数据行（trx_id=100）：
┌────────────────────────────────────────────────────┐
│  id: 1, name: '张三', age: 20                       │
│  trx_id: 100, roll_ptr: null                       │
└────────────────────────────────────────────────────┘
                         ↑
                    (update age=25)
                         │
                         ↓
修改后（trx_id=200）：
┌────────────────────────────────────────────────────┐
│  id: 1, name: '张三', age: 25                       │
│  trx_id: 200, roll_ptr: ───────────────────────────┐
└────────────────────────────────────────────────────┘
                                                        │
                                                        ↓
                                              ┌─────────────────────────────────────┐
                                              │  Undo Log (trx_id=100 时的版本)      │
                                              │  age: 20                              │
                                              │  roll_ptr: null                       │
                                              └─────────────────────────────────────┘
                                                        ↑
                                                 (update age=30)
                                                        │
                                                        ↓
修改后（trx_id=300）：
┌────────────────────────────────────────────────────┐
│  id: 1, name: '张三', age: 30                       │
│  trx_id: 300, roll_ptr: ───────────────────────────┐
└────────────────────────────────────────────────────┘
                                                        │
                                                        ↓
                                              ┌─────────────────────────────────────┐
                                              │  Undo Log (trx_id=200 时的版本)      │
                                              │  age: 25                              │
                                              │  roll_ptr: ─────────────────────────┐ │
                                              └─────────────────────────────────────┘ │
                                                                        │
                                                                        ↓
                                                              ┌───────────────────────────┐
                                                              │ Undo Log (trx_id=100)     │
                                                              │ age: 20                    │
                                                              │ roll_ptr: null             │
                                                              └───────────────────────────┘
```

**Undo Log 空间管理：**
```sql
-- 查看 undo tablespace
SHOW VARIABLES LIKE 'innodb_undo_tablespaces';

-- 默认为 2 个 undo tablespace
-- 每个 tablespace 包含多个回滚段

-- Purge 线程
-- 定期清理不再需要的 undo log
-- 条件：没有活跃事务需要该版本 + undo log 所在的事务已提交

SELECT * FROM information_schema.INNODB_TRX;  -- 查看活跃事务
SELECT * FROM information_schema.INNODB_ROLLBACK;  -- 查看回滚段
```

**Undo Log 与事务隔离：**
```java
// 读已提交（READ COMMITTED）
// 每次读都创建新的 ReadView

// 可重复读（REPEATABLE READ）
// 事务开始时创建 ReadView，整个事务复用
```

---

## 3. MVCC 视图创建时机？

**题目：**
请详细说明 MVCC 中 ReadView 的创建时机，以及不同隔离级别下的差异。

**答案：**
**ReadView 是什么：**
ReadView（读视图）是 MVCC 的核心组件，用于判断某个数据版本对当前事务是否可见。

**ReadView 结构：**
```c
struct ReadView {
    trx_id_t m_low_limit_id;      // 最大事务ID + 1，所有 >= 这个的都不可见
    trx_id_t m_up_limit_id;       // 最小活跃事务ID，所有 < 这个的都可见
    trx_id_t m_creator_trx_id;    // 当前事务ID
    std::vector<trx_id_t> m_ids;  // 活跃事务列表（>= m_up_limit_id 且 < m_low_limit_id）
    bool m_low_limit_no_trx;      // 是否没有活跃事务
};
```

**可见性判断算法：**
```c
bool isVisible(trx_id_t trx_id, trx_id_t row_trx_id) {
    // 1. 如果数据版本的事务ID等于当前事务ID，可见（自己的修改）
    if (row_trx_id == m_creator_trx_id) {
        return true;
    }
    
    // 2. 如果数据版本的事务ID小于最小活跃事务ID，可见（已提交）
    if (row_trx_id < m_up_limit_id) {
        return true;
    }
    
    // 3. 如果数据版本的事务ID大于等于最大事务ID，不可见（未开始）
    if (row_trx_id >= m_low_limit_id) {
        return false;
    }
    
    // 4. 如果数据版本的事务ID在活跃事务列表中，不可见（未提交）
    if (inActiveTransactionList(row_trx_id)) {
        return false;
    }
    
    // 5. 否则，可见（已提交）
    return true;
}
```

**图解可见性判断：**
```
时间线：
──────┬──────────────┬──────────────┬──────────────┬──────────────┬──────>
      │              │              │              │              │
    trx=100        trx=200        trx=300        trx=400        trx=500
    (提交)         (活跃)          (活跃)         (提交)       (当前事务)

当前事务 trx=400 开始时的 ReadView：
┌─────────────────────────────────────────────────────────────────┐
│  m_up_limit_id = 200    （最小活跃事务）                          │
│  m_low_limit_id = 500   （最大事务ID+1）                          │
│  m_ids = [200, 300]     （活跃事务列表）                          │
│  m_creator_trx_id = 400 （当前事务）                              │
└─────────────────────────────────────────────────────────────────┘

数据版本可见性判断：
- trx=100 < 200 → 可见 ✅
- trx=200 ∈ [200,300] 且在 m_ids 中 → 不可见 ❌
- trx=300 ∈ [200,300] 且在 m_ids 中 → 不可见 ❌
- trx=400 = 400 → 可见 ✅（自己）
- trx=500 >= 500 → 不可见 ❌（未开始）
```

**不同隔离级别的 ReadView 创建时机：**

**1. 读已提交（READ COMMITTED）**
```sql
-- 每次读取都创建新的 ReadView
SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;

-- 每次 SELECT 都会：
-- 1. 获取当前活跃事务列表
-- 2. 创建新的 ReadView
-- 3. 进行可见性判断
-- 4. 返回结果后，ReadView 释放

BEGIN;
SELECT * FROM user WHERE id = 1;  -- 创建 ReadView A
-- 看到的数据版本基于 ReadView A

-- 其他事务修改并提交了数据

SELECT * FROM user WHERE id = 1;  -- 创建 ReadView B（新的）
-- 可能看到不同的数据版本（因为 ReadView 变了）
COMMIT;
```

**2. 可重复读（REPEATABLE READ）**
```sql
-- 事务开始时创建 ReadView，整个事务复用
SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;

BEGIN;
-- ReadView 在这里创建（事务第一条 SELECT 时）
SELECT * FROM user WHERE id = 1;  -- 创建 ReadView A

-- 其他事务修改并提交了数据

SELECT * FROM user WHERE id = 1;  -- 复用 ReadView A
-- 看到的数据版本和第一次 SELECT 相同（因为 ReadView 没变）
COMMIT;
-- ReadView 释放
```

**ReadView 创建源码流程：**
```c
// InnoDB 源码流程（简化）

// 1. 读操作入口
int row_search_for_mysql(
    buf_block_t* block,    // 数据块
    dict_index_t* index,   // 索引
    ulint mode,            // 模式
    ...) {
    
    // 2. 创建 ReadView（如果是第一次读）
    ReadView* view = thr_get_read_view(thr);
    if (view == nullptr) {
        view = read_view_open_now(trx_id);
        thr_set_read_view(thr, view);
    }
    
    // 3. 判断数据是否可见
    if (!read_view_is_visible(view, block, index, entry)) {
        // 不可见，需要查找历史版本
        return row_sel_build_committed_vers(block, index, entry, view, ...);
    }
    
    // 4. 返回可见数据
    return DB_SUCCESS;
}

// 5. 可重复读模式下，ReadView 复用
void trx_commit(Transaction* tx) {
    if (tx->isolation_level == TRX_ISO_REPEATABLE_READ) {
        // 不释放 ReadView，事务结束才释放
        read_view_close_for_trx(tx->read_view);
    }
}
```

**MVCC 读取流程：**
```
┌─────────────────────────────────────────────────────────────────┐
│                    MVCC 读取流程                                 │
│                                                                  │
│  ┌─────────────┐                                                │
│  │  SELECT     │  开始读操作                                     │
│  └──────┬──────┘                                                │
│         ↓                                                       │
│  ┌─────────────┐                                                │
│  │ 创建/复用   │  ReadView                                      │
│  │ ReadView    │                                                │
│  └──────┬──────┘                                                │
│         ↓                                                       │
│  ┌─────────────┐                                                │
│  │ 读取数据页   │  从聚簇索引读取数据                             │
│  └──────┬──────┘                                                │
│         ↓                                                       │
│  ┌─────────────┐                                                │
│  │ 判断可见性   │  trx_id vs ReadView                            │
│  └──────┬──────┘                                                │
│         ↓                                                       │
│  ┌─────────────┐      ┌─────────────┐                          │
│  │ 可见 ✅     │      │ 不可见 ❌    │                          │
│  └──────┬──────┘      └──────┬──────┘                          │
│         ↓                    ↓                                  │
│  ┌─────────────┐      ┌─────────────┐                          │
│  │ 返回数据     │      │ 沿着版本链  │                          │
│  └─────────────┘      │ 查找历史版本 │                          │
│                       └──────┬──────┘                          │
│                              ↓                                  │
│                       ┌─────────────┐                          │
│                       │ 找到可见版本 │                          │
│                       └──────┬──────┘                          │
│                              ↓                                  │
│                       ┌─────────────┐                          │
│                       │ 返回历史数据  │                          │
│                       └─────────────┘                          │
└─────────────────────────────────────────────────────────────────┘
```

**ReadView 与快照的关系：**
```java
// 快照 = ReadView 的状态

// 读已提交
// 每次读都是不同的快照（ReadView 每次都新建）

// 可重复读
// 整个事务是同一个快照（ReadView 复用）
```

**实验验证：**
```sql
-- 验证可重复读
-- 终端 1：
BEGIN;
SELECT * FROM user WHERE id = 1;  -- 假设看到 age=20

-- 终端 2：
BEGIN;
UPDATE user SET age = 30 WHERE id = 1;
COMMIT;  -- 提交

-- 终端 1：
SELECT * FROM user WHERE id = 1;  -- 仍然是 age=20（可重复读）
COMMIT;  -- 提交后 ReadView 释放

-- 终端 1（重新开始）：
SELECT * FROM user WHERE id = 1;  -- 现在看到 age=30
```

**常见问题：**
```sql
-- 1. 为什么可重复读还有幻读？
--    Next-Key Lock 解决的是写操作带来的幻读
--    读操作通过 MVCC 解决

-- 2. ReadView 何时创建？
--    读已提交：每次 SELECT
--    可重复读：事务第一条 SELECT

-- 3. ReadView 何时释放？
--    读已提交：SELECT 完成后
--    可重复读：事务提交或回滚后
```

---

## 4. InnoDB 崩溃恢复流程？

**题目：**
请说明 InnoDB 崩溃恢复的完整流程。

**答案：**
**崩溃恢复触发时机：**
```c
// MySQL 启动时检测到上次异常关闭
// 检查 redo log 的状态
// 如果有未完成的提交或回滚，执行恢复流程
```

**崩溃恢复流程：**
```
┌─────────────────────────────────────────────────────────────────┐
│                    InnoDB 崩溃恢复流程                           │
│                                                                  │
│  1. 初始化                                                       │
│     ├── 读取 redo log 文件                                       │
│     ├── 找到最近的 checkpoint                                    │
│     └── 确定恢复的起始点                                          │
│                                                                  │
│  2. 分析阶段（Analysis）                                         │
│     ├── 扫描 redo log                                           │
│     ├── 收集所有未完成的事务                                     │
│     └── 收集所有已提交但未刷盘的事务                              │
│                                                                  │
│  3. 重做阶段（Redo）                                             │
│     ├── 从 checkpoint 开始重放 redo log                         │
│     ├── 恢复到崩溃前的状态                                       │
│     └── 注意：只重做，不回滚                                      │
│                                                                  │
│  4. 回滚阶段（Undo）                                             │
│     ├── 回滚未提交的事务                                         │
│     ├── 读取 undo log                                           │
│     └── 执行反向操作                                             │
│                                                                  │
│  5. 完成恢复                                                     │
│     ├── 清理 undo log                                           │
│     └── 启动 MySQL 服务                                          │
└─────────────────────────────────────────────────────────────────┘
```

**详细恢复步骤：**
```c
void innodb_recovery() {
    // 1. 找到最近的 checkpoint
    CheckpointInfo cp = findLatestCheckpoint();
    lsn_t start_lsn = cp.lsn;
    
    // 2. 读取 redo log 到内存
    LogBuffer* log_buffer = readRedoLog(start_lsn);
    
    // 3. 分析 redo log
    TransactionList active_txns = analyzeLog(log_buffer);
    TransactionList committed_txns = analyzeCommitted(log_buffer);
    
    // 4. 重做（Redo）阶段
    for (lsn = start_lsn; lsn < log_buffer.end; ) {
        LogRecord* record = parseLogRecord(lsn);
        
        if (record.type == UPDATE) {
            // 重做更新操作
            applyRedoRecord(record);
        }
        
        lsn = getNextRecordLsn(lsn);
    }
    
    // 5. 回滚（Undo）阶段
    for (Transaction* txn : active_txns) {
        // 获取该事务的 undo log
        UndoLog* undo = getUndoLog(txn.id);
        
        // 逆向执行 undo log
        while (undo != null) {
            applyUndoLog(undo);  // 执行反向操作
            undo = undo.prev;    // 沿着版本链
        }
    }
    
    // 6. 清理
    purgeUndoLogs();
    flushDirtyPages();
}
```

**崩溃恢复场景：**
```sql
-- 场景1：事务执行中崩溃（未提交）
-- 恢复：回滚该事务的所有修改

-- 场景2：事务提交中崩溃（redo prepare 完成，commit 未完成）
-- 恢复：该事务提交（redo log 已有记录）

-- 场景3：事务提交完成，但数据页未刷盘
-- 恢复：通过 redo log 恢复数据页

-- 场景4：数据页刷盘完成，redo log 未刷盘
-- 恢复：不需要处理（数据已在磁盘）
```

---

## 5. Binlog 与 Redo Log 的区别？

**题目：**
MySQL 的 Binlog 和 Redo Log 有什么区别？

**答案：**
**两种日志对比：**

| 特性 | Binlog | Redo Log |
|------|--------|----------|
| **所属层次** | MySQL Server 层 | InnoDB 存储引擎层 |
| **日志类型** | 逻辑日志（SQL 语句） | 物理日志（数据页修改） |
| **记录内容** | 数据变更的逻辑操作 | 数据页的物理变更 |
| **作用** | 主从复制、数据恢复 | 崩溃恢复 |
| **写入方式** | 顺序写入 | 循环写入 |
| **刷盘策略** | sync_binlog 参数 | innodb_flush_log_at_trx_commit |
| **空间** | 追加写入，需要手动清理 | 循环使用 |
| **格式** | STATEMENT/ROW/MIXED | 固定的物理格式 |

**两种日志的协作：**
```
┌─────────────────────────────────────────────────────────────────┐
│                    事务提交时的日志写入                           │
│                                                                  │
│  ┌─────────┐     ┌─────────┐     ┌─────────┐     ┌─────────┐   │
│  │ 事务    │────>│ Redo    │────>│ Binlog  │────>│ Redo    │   │
│  │ 开始    │     │ prepare │     │ write   │     │ commit  │   │
│  └─────────┘     └─────────┘     └─────────┘     └─────────┘   │
│                         ↓                      ↓                │
│                   记录到内存           记录到内存          刷盘  │
└─────────────────────────────────────────────────────────────────┘

两阶段提交的目的：
保证 Binlog 和 Redo Log 的一致性
```

**为什么需要两种日志：**
```java
// 1. 职责不同
//    Binlog：用于复制和外部恢复（mysqldump、binlog恢复）
//    Redo Log：用于崩溃恢复

// 2. 层次不同
//    Binlog：Server 层，所有存储引擎都有
//    Redo Log：InnoDB 特有

// 3. 恢复能力不同
//    Binlog：可以恢复到任意时间点
//    Redo Log：只能恢复到最近一次 checkpoint
```

**数据恢复场景：**
```bash
# 使用 Binlog 恢复到某个时间点
mysqlbinlog --start-datetime="2025-01-01 10:00:00" \
            --stop-datetime="2025-01-01 11:00:00" \
            mysql-bin.000001 | mysql -u root -p

# 使用 Redo Log 崩溃恢复
# MySQL 自动完成，不需要手动操作
```

**删除策略：**
```sql
-- Binlog 手动清理
PURGE BINARY LOGS BEFORE '2025-01-01';
SHOW BINARY LOGS;

-- 设置过期时间
SHOW VARIABLES LIKE 'expire_logs_days';
SET GLOBAL expire_logs_days = 7;

-- Redo Log 自动循环
-- 当 redo log 空间不足时，自动触发 checkpoint
-- 覆盖旧的日志
```

---

## P8 级 MySQL 原理题

### MySQL MVCC 机制详解

**题目：**
请详细解释 MySQL InnoDB 的 MVCC（多版本并发控制）机制，包括：
- 隐藏字段
- ReadView 结构
- 快照读与当前读
- 事务隔离级别的实现

**答案：**

**1. 隐藏字段**

每行数据包含三个隐藏字段：
- `DB_TRX_ID`：最近修改的事务 ID
- `DB_ROLL_PTR`：回滚指针，指向 undo log
- `DB_ROW_ID`：隐式主键（如果没有显式主键）

**2. Undo Log 版本链**
```
+-----+------+
| id  | name |
+-----+------+
| 1   | A    |  → [undo log] → version 2: (1, B)
+-----+------+
      |      → [undo log] → version 1: (1, A)
      ↓
  DB_ROLL_PTR
```

**3. ReadView 结构**
```c
struct ReadView {
    trx_ids;        // 活跃事务 ID 列表
    low_limit_id;   // 事务 ID 上限
    up_limit_id;    // 事务 ID 下限
    creator_trx_id; // 当前事务 ID
}
```

**4. 可见性判断**
```
if (trx_id < up_limit_id)      → 可见（已提交）
else if (trx_id >= low_limit_id) → 不可见（未开始）
else if (trx_id in trx_ids)     → 不可见（活跃中）
else                             → 可见（已提交）
```

**5. 隔离级别实现**

| 隔离级别 | ReadView 生成时机 | 可见性 |
|---------|-----------------|-------|
| READ UNCOMMITTED | 每次读取 | 所有版本 |
| READ COMMITTED | 每次 SELECT | 已提交 |
| REPEATABLE READ | 事务开始时 | 事务开始时已提交 |
| SERIALIZABLE | - | 锁表 |

**6. 快照读 vs 当前读**
- **快照读**：SELECT 语句，读取历史版本（MVCC）
- **当前读**：SELECT ... LOCK IN SHARE MODE / FOR UPDATE，读取最新版本
