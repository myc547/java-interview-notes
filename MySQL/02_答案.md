# MySQL面试题答案

## 1. MySQL索引类型？

**题目：**
MySQL有哪些索引类型？

**答案：**
**按数据结构分类：**
- **B+Tree索引**：InnoDB、MyISAM默认
- **Hash索引**：Memory引擎
- **Full-Text索引**：倒排索引
- **R-Tree索引**：空间索引

**按物理存储分类：**
- **聚簇索引**：数据行和索引在一起
- **非聚簇索引**：数据行和索引分开

**按功能分类：**
- **主键索引**：PRIMARY KEY
- **唯一索引**：UNIQUE
- **普通索引**：INDEX
- **复合索引**：多列组合
- **前缀索引**：前缀字符

**使用场景：**
```
WHERE条件：单列索引、复合索引
排序：复合索引
JOIN：关联字段索引
唯一性：唯一索引
```

---

## 2. InnoDB和MyISAM的区别？

**题目：**
InnoDB和MyISAM有什么区别？

**答案：**
| 特性 | InnoDB | MyISAM |
|------|--------|--------|
| **事务** | 支持 | 不支持 |
| **外键** | 支持 | 不支持 |
| **锁粒度** | 行锁 | 表锁 |
| **索引** | 聚簇索引 | 非聚簇索引 |
| **数据存储** | .ibd文件 | .MYD + .MYI |
| **缓存** | 缓存数据+索引 | 只缓存索引 |
| **MVCC** | 支持 | 不支持 |
| **崩溃恢复** | 好 | 一般 |
| **适用场景** | 事务应用 | 读多写少 |

**选择建议：**
- **InnoDB**：大多数场景，特别是事务需求
- **MyISAM**：只读报表、日志分析

---

## 3. 聚簇索引和非聚簇索引的区别？

**题目：**
聚簇索引和非聚簇索引有什么区别？

**答案：**
**聚簇索引：**
- 数据行和索引叶子节点存储在一起
- 每张表只能有一个聚簇索引
- 主键索引就是聚簇索引
- 查找顺序：B+Tree → 叶子节点（数据）

**非聚簇索引：**
- 数据行和索引分开存储
- 每张表可以有多个非聚簇索引
- 查找顺序：B+Tree → 叶子节点（主键值）→ 回表查数据

**示例：**
```
InnoDB表：
┌─────────────────────────────────────────┐
│ 聚簇索引（B+Tree）                       │
│  ┌─────┐                                │
│  │根節點│                                │
│  └──┬──┘                                │
│     ↓                                   │
│  ┌─────┐                                │
│  │葉節點│  → 存储完整数据行              │
│  └─────┘                                │
└─────────────────────────────────────────┘

非聚簇索引（B+Tree）                     │
┌─────────────────────────────────────────┐
│  ┌─────┐                                │
│  │根節點│                                │
│  └──┬──┘                                │
│     ↓                                   │
│  ┌─────┐                                │
│  │葉節點│  → 存储主键值                  │
│  └─────┘                                │
└─────────────────────────────────────────┘
```

---

## 4. 什么是回表查询？

**题目：**
什么是回表查询？

**答案：**
**回表定义：**
先通过非聚簇索引找到主键值，再通过主键值到聚簇索引查找完整数据行的过程。

**回表演示：**
```sql
-- 创建表
CREATE TABLE user (
    id INT PRIMARY KEY,
    name VARCHAR(20),
    age INT,
    INDEX idx_name (name)
);

-- 查询
SELECT * FROM user WHERE name = '张三';
```

**查询流程：**
```
1. 在idx_name索引中查找name='张三' → 得到主键id=100
2. 回到聚簇索引中查找id=100 → 获取完整数据行
```

**减少回表：**
```sql
-- 覆盖索引查询（不回表）
SELECT id, name FROM user WHERE name = '张三';

-- 使用覆盖索引
CREATE INDEX idx_name_age ON user(name, age);
SELECT name, age FROM user WHERE name = '张三';
```

**覆盖索引：**
- 查询的所有列都在索引中
- 不需要回表，性能更好

---

## 5. 索引失效场景有哪些？

**题目：**
哪些情况会导致索引失效？

**答案：**
**索引失效场景：**

**1. 条件中使用函数**
```sql
-- 失效
SELECT * FROM user WHERE YEAR(create_time) = 2025;

-- 生效
SELECT * FROM user WHERE create_time >= '2025-01-01';
```

**2. 隐式类型转换**
```sql
-- phone是varchar类型
-- 失效：数字比较
SELECT * FROM user WHERE phone = 13800138000;

-- 生效
SELECT * FROM user WHERE phone = '13800138000';
```

**3. LIKE前缀模糊查询**
```sql
-- 失效
SELECT * FROM user WHERE name LIKE '%张';

-- 生效
SELECT * FROM user WHERE name LIKE '张%';
```

**4. OR连接不同索引**
```sql
-- 失效
SELECT * FROM user WHERE name = '张' OR age = 20;

-- 生效（使用复合索引）
CREATE INDEX idx_name_age ON user(name, age);
```

**5. NOT IN / NOT EXISTS**
```sql
-- 失效
SELECT * FROM user WHERE id NOT IN (1, 2, 3);

-- 可用
SELECT * FROM user WHERE id NOT EXISTS (SELECT 1 FROM ...);
```

**6. 复合索引不满足最左前缀**
```sql
-- 复合索引：(name, age, city)
-- 生效：name
-- 生效：name + age
-- 失效：age（跳过name）
-- 失效：city（跳过name, age）
```

**7. 优化器认为全表更快**
```sql
-- 数据量小，优化器选择全表扫描
SELECT * FROM user WHERE age > 10;
```

---

## 6. MySQL事务特性（ACID）？

**题目：**
MySQL事务的ACID特性是什么？

**答案：**
**ACID四大特性：**

**1. Atomicity（原子性）**
- 事务是最小执行单位
- 要么全部成功，要么全部失败
- 通过Undo Log实现

**2. Consistency（一致性）**
- 事务执行前后数据一致
- 符合约束、完整性
- 业务逻辑保证

**3. Isolation（隔离性）**
- 并发事务相互隔离
- 通过锁和MVCC实现
- 可配置隔离级别

**4. Durability（持久性）**
- 事务提交后数据永久保存
- 通过Redo Log实现
- 崩溃后可恢复

**实现原理：**
```
Undo Log：回滚日志，原子性
Redo Log：重做日志，持久性
Binlog：归档日志，主从复制
锁：隔离性
```

---

## 7. 事务隔离级别？

**题目：**
MySQL有哪些事务隔离级别？

**答案：**
**四种隔离级别：**

| 隔离级别 | 脏读 | 不可重复读 | 幻读 | 实现方式 |
|----------|------|------------|------|----------|
| **读未提交** | ❌ | ❌ | ❌ | 无 |
| **读已提交** | ✅ | ❌ | ❌ | MVCC |
| **可重复读** | ✅ | ✅ | ❌（InnoDB） | MVCC |
| **串行化** | ✅ | ✅ | ✅ | 锁 |

**默认隔离级别：**
```sql
-- MySQL InnoDB默认：可重复读（REPEATABLE READ）
```

**各级别说明：**

**读未提交（READ UNCOMMITTED）：**
- 读取其他事务未提交的数据
- 可能脏读

**读已提交（READ COMMITTED）：**
- 只读取已提交的数据
- 不可重复读

**可重复读（REPEATABLE READ）：**
- 同一事务内多次读取一致
- InnoDB通过MVCC实现
- 解决幻读（Next-Key Lock）

**串行化（SERIALIZABLE）：**
- 事务串行执行
- 性能最差

**设置隔离级别：**
```sql
SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;
```

---

## 8. 什么是MVCC？

**题目：**
什么是MVCC？

**答案：**
**MVCC定义：**
Multi-Version Concurrency Control，多版本并发控制。

**核心思想：**
- 每行数据有多个版本
- 读操作不加锁，通过版本号判断
- 实现读写并发

**InnoDB MVCC实现：**
```
每行数据包含：
- DB_TRX_ID：最近事务ID
- DB_ROLL_PTR：回滚指针
- 隐藏列：row_id（无主键时）

Undo Log形成版本链：
┌─────────────┐
│  初始数据    │  ← Transaction 1
└──────┬──────┘
       │ (update)
       ↓
┌─────────────┐
│  更新后数据  │  ← Transaction 2
└──────┬──────┘
       │ (update)
       ↓
┌─────────────┐
│  更新后数据  │  ← Transaction 3
└─────────────┘
```

**ReadView（读视图）：**
```sql
-- READ COMMITTED：每次读创建新ReadView
-- REPEATABLE READ：事务内复用同一个ReadView
```

**ReadView包含：**
- m_ids：活跃事务列表
- min_trx_id：最小活跃事务ID
- max_trx_id：最大事务ID+1
- creator_trx_id：当前事务ID

**可见性判断：**
```
1. trx_id == creator_trx_id → 可见（自己的）
2. trx_id < min_trx_id → 可见（已提交）
3. trx_id > max_trx_id → 不可见（未开始）
4. trx_id在m_ids中 → 不可见（未提交）
5. 否则 → 可见（已提交）
```

---

## 9. 锁的类型有哪些？

**题目：**
MySQL有哪些锁类型？

**答案：**
**按粒度分类：**
- **表锁**：锁定整张表
- **行锁**：锁定行记录
- **页锁**：锁定数据页

**按模式分类：**
- **共享锁（S锁）**：读锁
- **排他锁（X锁）**：写锁
- **意向锁（IX/IS）**：表级锁

**InnoDB行锁类型：**
- **Record Lock**：记录锁
- **Gap Lock**：间隙锁
- **Next-Key Lock**：记录锁+间隙锁

**锁兼容矩阵：**
|      | IS | IX | S | X |
|------|----|----|----|---|
| **IS** | ✅ | ✅ | ✅ | ❌ |
| **IX** | ✅ | ✅ | ❌ | ❌ |
| **S**  | ✅ | ❌ | ✅ | ❌ |
| **X**  | ❌ | ❌ | ❌ | ❌ |

**死锁示例：**
```sql
-- 事务1
UPDATE user SET age = 20 WHERE id = 1;  -- 锁住id=1
UPDATE user SET age = 21 WHERE id = 2;  -- 等待

-- 事务2
UPDATE user SET age = 22 WHERE id = 2;  -- 锁住id=2
UPDATE user SET age = 23 WHERE id = 1;  -- 死锁
```

**解决死锁：**
- 设置锁超时
- 统一锁获取顺序
- 监控和分析

---

## 10. 慢查询优化步骤？

**题目：**
如何优化慢查询？

**答案：**
**优化步骤：**

**1. 开启慢查询日志**
```sql
-- 查看是否开启
SHOW VARIABLES LIKE 'slow_query_log';

-- 开启
SET GLOBAL slow_query_log = ON;

-- 设置阈值
SET GLOBAL long_query_time = 1;

-- 查看日志
SHOW GLOBAL STATUS LIKE 'Slow_queries';
```

**2. 分析执行计划**
```sql
EXPLAIN SELECT * FROM user WHERE age > 20;

-- 关键指标
-- type: ALL（全表）→ index → range → ref → const
-- key: 实际使用的索引
-- rows: 扫描行数
-- Extra: Using filesort, Using temporary
```

**3. 常见优化方法**
```sql
-- 添加索引
CREATE INDEX idx_age ON user(age);

-- 优化SQL
-- ❌ 避免
SELECT * FROM user WHERE age > 20 AND name LIKE '%张%';

-- ✅ 使用
SELECT id, name, age FROM user WHERE age > 20;

-- 分页优化
-- ❌ 慢
SELECT * FROM user LIMIT 1000000, 10;

-- ✅ 快
SELECT * FROM user WHERE id > 1000000 LIMIT 10;
```

**4. 使用覆盖索引**
```sql
-- 创建复合索引
CREATE INDEX idx_age_name ON user(age, name);

-- 查询只用索引
SELECT age, name FROM user WHERE age > 20;
```

**5. 分库分表**
```sql
-- 水平拆分
SELECT * FROM user_2025 WHERE create_time > '2025-01-01';
```

---

## 11. 分库分表策略？

**题目：**
MySQL分库分表有哪些策略？

**答案：**
**分库分表类型：**

**1. 垂直拆分**
```
按业务拆分
用户库、订单库、商品库
```

**2. 水平拆分**
```
按数据量拆分
user_0, user_1, user_2
```

**分片策略：**
```java
// 哈希分片
shardingKey = userId % 4

// 范围分片
shardingKey = userId / 1000000

// 地理分片
shardingKey = regionCode

// 时间分片
shardingKey = date_format(create_time, '%Y%m')
```

**中间件：**
- **ShardingSphere**
- **MyCat**
- **TDDL**

**分库分表问题：**
| 问题 | 解决方案 |
|------|----------|
| 跨库查询 | 应用层聚合 |
| 跨库Join | 冗余数据、ES |
| 分页查询 | 二次查询 |
| 分布式事务 | Seata |
| 全局ID | 雪花算法 |

**数据迁移：**
```sql
-- 双写方案
1. 写入旧库和新库
2. 同步历史数据
3. 切换读新库
```

---

## 12. 主从复制原理？

**题目：**
MySQL主从复制原理是什么？

**答案：**
**主从复制架构：**
```
┌──────────┐         ┌──────────┐
│  Master  │ ──────> │  Slave   │
│  (主库)  │ binlog  │  (从库)  │
└──────────┘         └──────────┘
```

**复制流程：**
```
1. Master执行SQL，更新数据
2. Master记录binlog
3. Slave IO线程连接Master
4. Master发送binlog到Slave
5. Slave IO线程接收，写入relay log
6. Slave SQL线程读取relay log，执行SQL
```

**三种复制方式：**

| 方式 | 原理 | 优点 | 缺点 |
|------|------|------|------|
| **异步复制** | Master不等待Slave | 性能好 | 数据可能延迟 |
| **半同步复制** | Master等待至少1个Slave | 数据更安全 | 有延迟 |
| **GTID复制** | 基于事务ID | 自动定位 | 复杂 |

**配置主从：**
```sql
-- Master配置
[mysqld]
server-id=1
log_bin=mysql-bin
binlog_format=ROW

-- Slave配置
[mysqld]
server-id=2
relay_log=relay-bin

-- Slave连接Master
CHANGE MASTER TO 
    MASTER_HOST='master_host',
    MASTER_USER='repl',
    MASTER_PASSWORD='password',
    MASTER_AUTO_POSITION=1;

START SLAVE;
```

**主从延迟优化：**
- 减少大事务
- 并行复制
- 调整网络
- 读写分离

---

## 13. 什么是_binlog？

**题目：**
MySQL binlog是什么？

**答案：**
**binlog定义：**
Binary Log，记录所有数据库表结构变更和数据修改。

**作用：**
- 主从复制
- 数据恢复
- 审计追踪

**三种格式：**

| 格式 | 说明 | 优点 | 缺点 |
|------|------|------|------|
| **STATEMENT** | 记录SQL语句 | 日志量小 | 某些情况不可用 |
| **ROW** | 记录行变化 | 精确 | 日志量大 |
| **MIXED** | 自动选择 | 灵活 | 混合模式 |

**查看binlog：**
```bash
# 查看binlog列表
mysql> SHOW BINARY LOGS;

# 查看当前binlog
mysql> SHOW MASTER STATUS;

# 查看binlog内容
mysqlbinlog mysql-bin.000001
```

**数据恢复：**
```bash
# 基于时间点恢复
mysqlbinlog --start-datetime="2025-01-01 00:00:00" \
            --stop-datetime="2025-01-02 00:00:00" \
            mysql-bin.000001 | mysql -u root -p
```

**binlog与redo log：**
```
binlog：归档日志，主从复制
redo log：重做日志，崩溃恢复

WAL（Write-Ahead Logging）：
1. 写redo log（prepare状态）
2. 写binlog
3. 提交事务
4. redo log（commit状态）
```

---

## 14. 什么是死锁？如何避免？

**题目：**
MySQL死锁是什么？如何避免？

**答案：**
**死锁定义：**
两个或多个事务相互等待对方持有的锁。

**死锁示例：**
```sql
-- 事务1
UPDATE user SET age = 20 WHERE id = 1;  -- 锁住id=1
UPDATE user SET age = 21 WHERE id = 2;  -- 等待id=2

-- 事务2
UPDATE user SET age = 22 WHERE id = 2;  -- 锁住id=2
UPDATE user SET age = 23 WHERE id = 1;  -- 死锁
```

**检测死锁：**
```sql
-- 查看死锁
SHOW ENGINE INNODB STATUS;

-- 信息包含：
-- LATEST DETECTED DEADLOCK
-- 死锁SQL
-- 事务列表
-- 等待锁信息
```

**避免死锁：**

**1. 统一锁顺序**
```sql
-- 按主键顺序访问
UPDATE user SET age = 20 WHERE id < 10;
UPDATE user SET age = 21 WHERE id >= 10;
```

**2. 减少事务大小**
```sql
-- ❌ 大事务
BEGIN;
UPDATE user SET age = 20 WHERE id < 10000;
... 其他操作
COMMIT;

-- ✅ 小事务
BEGIN;
UPDATE user SET age = 20 WHERE id < 1000;
COMMIT;
```

**3. 使用索引**
```sql
-- 走索引，行锁
-- 不走索引，表锁
```

**4. 设置锁超时**
```sql
-- InnoDB锁等待超时
SET GLOBAL innodb_lock_wait_timeout = 50;
```

**处理死锁：**
- 自动检测，终止其中一个事务
- 应用层重试
- 分析日志，优化SQL

---

## 15. SQL执行计划怎么看？

**题目：**
如何分析SQL执行计划？

**答案：**
**EXPLAIN使用：**
```sql
EXPLAIN SELECT * FROM user WHERE age > 20;
```

**执行计划字段：**

| 字段 | 说明 | 关注点 |
|------|------|--------|
| **id** | 执行顺序 | 越大越先执行 |
| **select_type** | 查询类型 | SIMPLE, SUBQUERY, UNION |
| **table** | 表名 | 关联的表 |
| **type** | 访问类型 | ALL < index < range < ref < const |
| **possible_keys** | 可能使用的索引 | |
| **key** | 实际使用的索引 | NULL表示未用索引 |
| **key_len** | 索引长度 | |
| **rows** | 扫描行数 | 越小越好 |
| **Extra** | 额外信息 | Using filesort, Using temporary |

**type详解：**
```
const：主键/唯一索引等值查询
ref：非唯一索引等值查询
range：范围查询
index：全索引扫描
ALL：全表扫描（最差）
```

**优化建议：**
```
1. type 应该是 range 以上
2. key 不应该是 NULL
3. rows 应该尽量小
4. Extra 不应该有 Using filesort
```

**使用ANALYZE：**
```sql
-- MySQL 8.0+ 查看实际执行信息
EXPLAIN ANALYZE 
SELECT * FROM user WHERE age > 20;
```

---

*更多MySQL面试题答案*
