# 操作系统面试题

## 1. 进程和线程的区别？

**题目：**
进程和线程有什么区别？

**答案：**
**进程 vs 线程：**
```
┌────────────────┬─────────────────┬─────────────────┐
│      特性      │      进程       │      线程       │
├────────────────┼─────────────────┼─────────────────┤
│  资源分配     │     独立资源     │   共享进程资源   │
│  开销         │      大         │       小        │
│  通信         │      复杂       │       简单      │
│  切换         │      慢         │       快        │
│  独立性       │     独立        │    非独立       │
│  安全性       │      高         │       低        │
└────────────────┴─────────────────┴─────────────────┘
```

**进程：**
```c
// 进程包含：
// 1. 进程控制块（PCB）
// 2. 代码段
// 3. 数据段
// 4. 堆
// 5. 栈

struct process {
    int pid;                    // 进程 ID
    ProcessState state;        // 进程状态
    int priority;              // 优先级
    long counter;              // 程序计数器
    long stack_pointer;        // 栈指针
    MMUContext mmu;           // 内存管理信息
    OpenFileTable ofiles;     // 打开文件表
    // ...
};
```

**线程：**
```c
// 线程包含：
// 1. 线程控制块（TCB）
// 2. 程序计数器
// 3. 栈
// 4. 寄存器状态

struct thread {
    int tid;                   // 线程 ID
    int pid;                   // 所属进程
    ThreadState state;        // 线程状态
    long counter;              // 程序计数器
    long stack_pointer;       // 栈指针
    // 与进程共享：
    // - 代码段
    // - 数据段
    // - 打开文件表
    // - 信号处理
};
```

**多进程 vs 多线程：**
```java
// 多进程
// 优点：独立内存空间，互不干扰
// 缺点：通信复杂，资源开销大
Process process1 = new Process(task1);
Process process2 = new Process(task2);

// 多线程
// 优点：共享内存，通信简单，资源利用率高
// 缺点：同步复杂，调试困难
Thread thread1 = new Thread(task1);
Thread thread2 = new Thread(task2);

// 使用场景
// - 多进程：浏览器（插件崩溃不影响主进程）
// - 多线程：Web 服务器（并发处理请求）
```

---

## 2. 进程有哪些状态？状态转换图？

**题目：**
进程有哪些状态？状态之间如何转换？

**答案：**
**进程状态：**
```
┌─────────────────────────────────────────────────────────────────┐
│                    进程状态转换图                                 │
│                                                              │
│                    ┌──────────┐                                │
│                    │   就绪    │                                │
│                    │  (Ready) │                                │
│                    └────┬─────┘                                │
│                         │                                       │
│            ┌────────────┼────────────┐                        │
│            ▼            │            ▼                        │
│     ┌───────────┐      │      ┌───────────┐               │
│     │   运行    │      │      │   阻塞    │               │
│     │ (Running) │──────┼─────►│ (Blocked) │               │
│     └─────┬─────┘      │      └───────────┘               │
│           │             │                                       │
│           │ 完成/I/O    │  完成/I/O                           │
│           │             │                                       │
│           ▼             │                                       │
│     ┌───────────┐      │                                       │
│     │   终止    │◄─────┘                                       │
│     │ (Exit)    │                                              │
│     └───────────┘                                              │
│                                                              │
└─────────────────────────────────────────────────────────────────┘
```

**状态说明：**
```
1. 新建（New）：进程正在被创建
   - 分配 PCB
   - 分配资源

2. 就绪（Ready）：等待 CPU 时间片
   - 已具备运行条件
   - 等待调度

3. 运行（Running）：正在 CPU 上执行
   - 占用 CPU
   - 执行指令

4. 阻塞（Blocked）：等待 I/O 或事件
   - 不能执行
   - 等待信号量、I/O 完成等

5. 终止（Exit）：进程执行完毕
   - 释放资源
   - 通知父进程
```

**状态转换：**
```
New → Ready：进程被创建完成
Ready → Running：调度器选择该进程
Running → Ready：时间片用完或被抢占
Running → Blocked：等待 I/O 或事件
Blocked → Ready：I/O 完成或事件发生
Running → Exit：进程完成任务
```

---

## 3. 进程调度算法有哪些？

**题目：**
常见的进程调度算法有哪些？各有什么优缺点？

**答案：**
**调度算法分类：**
```
┌─────────────────────────────────────────────────────────────────┐
│                    调度算法分类                                   │
│                                                              │
│  ┌──────────────────┐  ┌──────────────────┐                │
│  │   非抢占式调度    │  │    抢占式调度     │                │
│  │  - FCFS         │  │  - RR           │                │
│  │  - SJF         │  │  - 优先级调度    │                │
│  │  - HRRN        │  │  - 多级反馈队列  │                │
│  └──────────────────┘  └──────────────────┘                │
│                                                              │
└─────────────────────────────────────────────────────────────────┘
```

**1. FCFS（先来先服务）：**
```c
// 按到达顺序调度
// 优点：简单、公平
// 缺点：短进程等待时间长

Process queue[] = {P1, P2, P3};  // 按到达顺序
// P1 → P2 → P3
```

**2. SJF（短作业优先）：**
```c
// 选择估计运行时间最短的进程
// 优点：平均等待时间最少
// 缺点：需要预估运行时间

Process queue[] = {P1(6), P2(3), P3(8), P4(4)};
scheduler.sortByBurstTime();  // P2(3) → P4(4) → P1(6) → P3(8)
```

**3. RR（时间片轮转）：**
```java
// 每个进程分配一个时间片
// 优点：公平、响应时间短
// 缺点：上下文切换开销

// 示例：时间片 = 4
// P1(8) → P2(4) → P3(8) → P4(5)
// P1(4) → P2(4) → P3(4) → P4(4) → P1(4) → P3(4) → P4(1)
```

**4. 优先级调度：**
```java
// 按优先级调度
// 静态优先级：创建时确定，不变
// 动态优先级：运行时调整

// 优先级继承：高优先级进程等待低优先级进程时
//             临时提升低优先级进程
```

**5. 多级反馈队列（MLFQ）：**
```java
// 多个队列，优先级递减
// 队列0：时间片=8（最高优先级）
// 队列1：时间片=16
// 队列2：时间片=32

// 规则：
// 1. 新进程放入队列0
// 2. 用完时间片未完成，降级
// 3. 阻塞后重新回到原队列
// 4. 上层队列为空才调度下层队列
```

**调度算法对比：**
```
┌───────────┬──────────┬──────────┬──────────┬──────────┐
│   算法     │  吞吐量  │  周转时间 │  响应时间 │  开销    │
├───────────┼──────────┼──────────┼──────────┼──────────┤
│   FCFS    │   低     │   高     │   低     │   低     │
│   SJF     │   高     │   低     │   中     │   中     │
│   RR      │   中     │   中     │   低     │   高     │
│  优先级   │   高     │   高     │   高     │   中     │
│   MLFQ    │   高     │   低     │   低     │   高     │
└───────────┴──────────┴──────────┴──────────┴──────────┘
```

---

## 4. 什么是死锁？产生死锁的条件？

**题目：**
什么是死锁？产生死锁的四个必要条件是什么？

**答案：**
**死锁定义：**
两个或多个进程无限期地等待一个资源，而该资源又被其他等待进程占有。

**死锁示例：**
```java
// 进程 P1 持有资源 A，等待资源 B
synchronized (resourceA) {
    Thread.sleep(100);
    synchronized (resourceB) {
        // 等待资源 B
    }
}

// 进程 P2 持有资源 B，等待资源 A
synchronized (resourceB) {
    Thread.sleep(100);
    synchronized (resourceA) {
        // 等待资源 A
    }
}
// P1 和 P2 相互等待，死锁
```

**四个必要条件：**
```
┌─────────────────────────────────────────────────────────────────┐
│                    死锁四个必要条件                               │
│                                                              │
│  1. 互斥条件（Mutual Exclusion）                               │
│     - 资源一次只能被一个进程使用                                 │
│     - 例如：打印机、互斥锁                                      │
│                                                              │
│  2. 持有并等待（Hold and Wait）                                │
│     - 进程持有至少一个资源，同时等待其他资源                      │
│                                                              │
│  3. 不可抢占（No Preemption）                                  │
│     - 资源不能被强制从进程中拿走                                 │
│     - 只能由进程自己释放                                        │
│                                                              │
│  4. 循环等待（Circular Wait）                                   │
│     - 进程等待链：P1 → P2 → ... → Pn → P1                   │
│                                                              │
└─────────────────────────────────────────────────────────────────┘
```

**死锁处理策略：**
```
1. 预防（Prevention）
   - 破坏四个必要条件之一

2. 避免（Avoidance）
   - 银行家算法
   - 安全状态检测

3. 检测（Detection）
   - 定期检测死锁
   - 资源分配图检测

4. 解除（Recovery）
   - 终止进程
   - 资源抢占
```

---

## 5. 死锁预防和避免？

**题目：**
如何预防和避免死锁？

**答案：**
**死锁预防（破坏必要条件）：**

**1. 破坏互斥条件：**
```java
// 尽量使用可共享的资源
// 例如：使用读写锁，而不是互斥锁
ReadWriteLock lock = new ReentrantReadWriteLock();
```

**2. 破坏持有并等待：**
```java
// 方案1：一次性申请所有资源
synchronized (resourceA) {
    synchronized (resourceB) {
        // 使用资源
    }
}

// 方案2：先释放已持有资源，再申请新资源
if (tryLock(resourceA)) {
    try {
        unlock(resourceA);
        if (tryLock(resourceB)) {
            try {
                // 使用资源
            } finally {
                unlock(resourceB);
            }
        }
    } finally {
        unlock(resourceA);
    }
}
```

**3. 破坏不可抢占：**
```java
// 如果资源可抢占，则强制抢占
// 例如：数据库事务超时回滚

// Redis 分布式锁带过期时间
String result = jedis.set(lockKey, lockValue, 
    "NX", "PX", expireTime);
if ("OK".equals(result)) {
    // 获取锁成功
    try {
        // 使用资源
    } finally {
        jedis.del(lockKey);
    }
}
```

**4. 破坏循环等待：**
```java
// 统一资源申请顺序
// 所有进程按相同顺序申请资源

// 资源编号：资源A=1, 资源B=2, 资源C=3

// 进程必须按顺序申请：1 → 2 → 3
// 这样不会形成循环等待

// 反例：
// P1: A → B
// P2: B → A
// 正例：
// P1: A → B → C
// P2: A → B → C
```

**死锁避免（银行家算法）：**
```java
// 银行家算法
// - Need = Max - Allocation
// - Safety 算法：检查是否存在安全序列

public class BankerAlgorithm {
    
    // 判断系统是否处于安全状态
    public boolean isSafeState(int[] available, 
                              int[][] max,
                              int[][] allocation,
                              int[][] need) {
        
        int n = max.length;  // 进程数
        int m = max[0].length;  // 资源种类数
        
        int[] work = available.clone();
        boolean[] finish = new boolean[n];
        
        // 查找安全序列
        for (int i = 0; i < n; i++) {
            if (!finish[i]) {
                if (canSatisfy(work, need[i])) {
                    // 进程 i 可以完成
                    finish[i] = true;
                    // 释放资源
                    for (int j = 0; j < m; j++) {
                        work[j] += allocation[i][j];
                    }
                    i = -1;  // 重新开始查找
                }
            }
        }
        
        // 检查是否所有进程都能完成
        for (boolean f : finish) {
            if (!f) return false;
        }
        return true;
    }
    
    private boolean canSatisfy(int[] work, int[] need) {
        for (int i = 0; i < work.length; i++) {
            if (need[i] > work[i]) {
                return false;
            }
        }
        return true;
    }
}
```

---

## 6. 什么是虚拟内存？实现原理？

**题目：**
什么是虚拟内存？它的实现原理是什么？

**答案：**
**虚拟内存概念：**
```
┌─────────────────────────────────────────────────────────────────┐
│                    虚拟内存概念                                   │
│                                                              │
│  虚拟内存 = 物理内存 + 磁盘上的交换空间                          │
│                                                              │
│  优点：                                                        │
│  - 程序可以使用比物理内存更大的地址空间                          │
│  - 进程地址空间隔离，提高安全性                                  │
│  - 物理内存共享，提高利用率                                       │
│                                                              │
└─────────────────────────────────────────────────────────────────┘
```

**实现原理：**
```
┌─────────────────────────────────────────────────────────────────┐
│                    虚拟地址 → 物理地址                           │
│                                                              │
│   虚拟地址空间                    物理内存                       │
│  ┌─────────────┐              ┌─────────────┐                 │
│  │  虚拟页 0   │              │  物理页 A   │                 │
│  │  虚拟页 1   │              │  物理页 B   │                 │
│  │  虚拟页 2   │   ───────►  │  物理页 C   │                 │
│  │  虚拟页 3   │   页表查询   │  物理页 D   │                 │
│  │  虚拟页 4   │              └─────────────┘                 │
│  │    ...      │                                                 │
│  └─────────────┘                                                 │
│         │                                                        │
│         ▼                                                        │
│  ┌───────────────┐                                              │
│  │   页表（Page Table）                                          │
│  │  ┌─────────┐  │                                              │
│  │  │VPN│PFN│状态│  │                                              │
│  │  ├─────────┤  │                                              │
│  │  │ 0 │ A │有效│  │                                              │
│  │  │ 1 │ B │有效│  │                                              │
│  │  │ 2 │ - │无效│  │  ← 页错误（缺页）                       │
│  │  │ 3 │ C │有效│  │                                              │
│  │  └─────────┘  │                                              │
│  └───────────────┘                                              │
│                                                              │
└─────────────────────────────────────────────────────────────────┘
```

**页表结构：**
```c
// 页表项（PTE）
struct PageTableEntry {
    unsigned int present : 1;    // 是否在内存
    unsigned int frame : 20;      // 物理页帧号
    unsigned int protection : 3;  // 保护位（r/w/x）
    unsigned int dirty : 1;       // 是否被修改
    unsigned int accessed : 1;    // 是否被访问
    unsigned int : 5;             // 保留
    unsigned int : 32 - 32;      // 填充
};

// 多级页表
// 页目录 → 页表 → 页帧
struct PageDirectory {
    PageTableEntry entries[1024];
};

struct PageTable {
    PageTableEntry entries[1024];
};
```

**页面置换算法：**
```java
// 1. FIFO（先进先出）
// 淘汰最早进入的页面
Queue<Page> queue = new LinkedList<>();
queue.offer(page);  // 入队
Page victim = queue.poll();  // 淘汰队首

// 2. LRU（最近最少使用）
// 淘汰最长时间未使用的页面
LinkedHashMap<Page, Integer> lru = new LinkedHashMap<>(16, 0.75f, true);
lru.get(page);  // 访问后移到尾部
lru.entrySet().iterator().next();  // 淘汰头部

// 3. LFU（最不经常使用）
// 淘汰访问次数最少的页面
Map<Page, Integer> lfu = new HashMap<>();
lfu.put(page, count++);
```

---

## 7. 什么是分页和分段？

**题目：**
分页和分段的区别是什么？

**答案：**
**分页 vs 分段：**
```
┌────────────────┬─────────────────┬─────────────────┐
│      特性      │      分页       │      分段       │
├────────────────┼─────────────────┼─────────────────┤
│  划分单位     │     固定大小     │    可变大小     │
│  地址结构     │   页号 + 页内偏移 │  段号 + 段内偏移 │
│  目的         │   物理内存管理   │   用户视图      │
│  共享         │     困难         │      容易       │
│  保护         │     页级保护     │     段级保护     │
│  碎片         │    内部碎片      │    外部碎片      │
│  大小         │    4KB 固定      │   几 KB~几 MB   │
└────────────────┴─────────────────┴─────────────────┘
```

**分页（Paging）：**
```c
// 虚拟地址 = 页号 + 页内偏移
// 物理地址 = 物理页帧号 + 页内偏移

// 示例：4KB 页大小
// 虚拟地址：0x12345678
//      页号：0x12345 (高 20 位)
//    页内偏移：0x678 (低 12 位)

// 页表查找
page_table[0x12345] → 物理页帧号 0xABCDE
物理地址 = 0xABCDE000 + 0x678 = 0xABCDE678
```

**分段（Segmentation）：**
```c
// 虚拟地址 = 段号 + 段内偏移
// 段表：段号 → 段基址 + 段界限

// 段表项
struct SegmentTableEntry {
    unsigned int base : 24;      // 段基址
    unsigned int limit : 16;      // 段大小
    unsigned int protection : 3;   // 保护位
    // ...
};

// 段式管理示例
// 段 0：代码段（0x00000000 ~ 0x0000FFFF）
// 段 1：数据段（0x00010000 ~ 0x0001FFFF）
// 段 2：堆段（0x00020000 ~ ...）
```

**段页式（Segment + Paging）：**
```c
// 先分段，再分页
// 虚拟地址 = 段号 + 页号 + 页内偏移

// 地址转换：
// 1. 段表查找 → 页表基址
// 2. 页表查找 → 物理页帧号
// 3. 物理地址 = 物理页帧号 + 页内偏移

// 结合两者优点
// - 外部碎片：段式分页解决
// - 共享困难：段式便于共享
```

---

## 8. 什么是缓冲区溢出？如何防止？

**题目：**
什么是缓冲区溢出？如何防止？

**答案：**
**缓冲区溢出：**
```c
// 缓冲区溢出示例
void vulnerableFunction(char* input) {
    char buffer[64];  // 64 字节缓冲区
    
    // 没有检查输入长度
    strcpy(buffer, input);  // 如果 input > 64，会溢出
}

// 溢出后可能覆盖：
// - 返回地址 → 控制程序执行流程
// - 函数指针 → 调用任意函数
// - 栈帧数据 → 破坏局部变量
```

**攻击类型：**
```
1. 栈溢出（Stack Overflow）
   - 覆盖返回地址
   - 跳转到恶意代码
   
2. 堆溢出（Heap Overflow）
   - 覆盖堆管理结构
   - 任意地址写
   
3. 格式化字符串攻击
   - 利用 printf %x、%n 等
   - 读取/写入任意内存

4. 整数溢出
   - 整数溢出导致缓冲区过小
```

**防止方法：**
```c
// 1. 边界检查
void safeFunction(char* input) {
    char buffer[64];
    size_t len = strlen(input);
    
    // 检查长度
    if (len >= sizeof(buffer)) {
        // 处理错误
        return;
    }
    
    memcpy(buffer, input, len);
    buffer[len] = '\0';
}

// 2. 使用安全函数
// ❌ 不安全
strcpy(dest, src);
strcat(dest, src);
sprintf(dest, fmt, ...);

// ✅ 安全
strncpy(dest, src, sizeof(dest) - 1);
strncat(dest, src, sizeof(dest) - strlen(dest) - 1);
snprintf(dest, sizeof(dest), fmt, ...);
```

**操作系统级防护：**
```bash
# 1. 栈保护（Stack Canary）
gcc -fstack-protector function.c
# 在返回地址前插入随机值，返回前检查

# 2. 地址空间布局随机化（ASLR）
echo 2 > /proc/sys/kernel/randomize_va_space
# 每次运行时随机化栈、堆、库地址

# 3. 数据执行保护（DEP/NX）
# 标记内存页为不可执行
gcc -z noexecstack program.c

# 4. 堆栈不可执行
# /proc/sys/vm/execstack = 0
```

**现代防护技术：**
```
1. ASLR（地址空间布局随机化）
   - 随机化栈、堆、库、代码地址
   - 攻击者无法预测地址

2. DEP（数据执行保护）
   - 标记数据页不可执行
   - 防止代码注入

3. Stack Canary（栈保护）
   - 检测栈溢出
   - GCC: -fstack-protector

4. CFI（控制流完整性）
   - 验证函数调用图
   - 防止控制流劫持

5. SafeStack（安全栈）
   - 将返回地址放到安全区域
   - 与主栈分离
```

---

## 9. 什么是上下文切换？开销有多大？

**题目：**
什么是上下文切换？它有什么开销？

**答案：**
**上下文切换：**
```
┌─────────────────────────────────────────────────────────────────┐
│                    上下文切换过程                                 │
│                                                              │
│  时间线：                                                      │
│                                                              │
│  ┌─────────────┐                                      ┌─────────┐│
│  │  进程 P1    │ ────── 切换 ──────► │   进程 P2    │        │
│  │  运行中     │         │         │   等待 CPU    │        │
│  └─────────────┘         │         └───────────────┘        │
│                           ▼                                    │
│                  ┌──────────────────┐                         │
│                  │   保存 P1 上下文   │                         │
│                  │   加载 P2 上下文   │                         │
│                  └──────────────────┘                         │
│                                                              │
└─────────────────────────────────────────────────────────────────┘
```

**上下文内容：**
```c
// 需要保存的上下文
struct context {
    // 1. 通用寄存器
    long rax, rbx, rcx, rdx;
    long rsi, rdi, rbp;
    long r8, r9, r10, r11;
    long r12, r13, r14, r15;
    
    // 2. 程序计数器
    long rip;  // 下一条要执行的指令地址
    
    // 3. 栈指针
    long rsp;   // 栈顶地址
    
    // 4. 状态寄存器
    long rflags;  // 标志位（ZF、CF、IF 等）
    
    // 5. 浮点寄存器（如果使用）
    struct fpu_context fpu;
    
    // 6. 内存管理信息
    long cr3;  // 页表基址
    
    // 7. 信号掩码
    sigset_t blocked;
    
    // 8. 线程局部存储
    void* tls;
};
```

**切换开销：**
```c
// 上下文切换时间组成：
// 1. 保存寄存器上下文
// 2. 更新内存管理单元（MMU）缓存
// 3. 刷新 CPU 缓存
// 4. 恢复新进程上下文
// 5. TLB 失效

// 典型时间：
// Linux 上下文切换：约 1-10 微秒
// Windows 上下文切换：约 5-20 微秒

// 性能影响示例
// 10000 次切换/秒，每次 5 微秒
// CPU 时间 = 10000 × 5μs = 50ms/秒
// 占用 CPU 5%
```

**减少切换开销：**
```
1. 减少线程数量
   - 线程不是越多越好
   - 一般 2-4 倍 CPU 核心数

2. 使用 NIO 或异步 I/O
   - 减少阻塞时的上下文切换

3. 协程（Coroutine）
   - 用户态线程
   - 切换开销极小（约几百纳秒）
   - Go、Goroutine
   - Kotlin、Coroutine
```

**用户态 vs 内核态切换：**
```
系统调用时的切换：
用户态 → 内核态 → 用户态

开销：
- 用户态切换：几乎没有开销
- 内核态切换：约 100-1000 周期

优化：
- 批量系统调用：减少切换次数
- vDSO：虚拟动态共享对象
- io_uring：Linux 异步 I/O
```

---

## 10. 什么是中断？中断和异常的区别？

**题目：**
什么是中断？中断和异常有什么区别？

**答案：**
**中断类型：**
```
┌─────────────────────────────────────────────────────────────────┐
│                    中断分类                                       │
│                                                              │
│  ┌──────────────────┐  ┌──────────────────┐                │
│  │    外部中断      │  │    内部中断      │                │
│  │  (Interrupt)    │  │   (Exception)   │                │
│  └──────────────────┘  └──────────────────┘                │
│                                                              │
│  外部中断：                                                    │
│  - I/O 中断：键盘、鼠标、磁盘                                  │
│  - 时钟中断：系统定时器                                         │
│  - 硬件故障：电源故障、内存错误                                 │
│                                                              │
│  内部中断（异常）：                                             │
│  - 故障（Fault）：可恢复，如页错误                               │
│  - 陷阱（Trap）：有意触发，如系统调用                           │
│  - 中止（Abort）：不可恢复，如硬件错误                          │
│                                                              │
└─────────────────────────────────────────────────────────────────┘
```

**中断处理流程：**
```
┌─────────────────────────────────────────────────────────────────┐
│                    中断处理流程                                   │
│                                                              │
│  1. 中断请求（IRQ）                                            │
│     设备发出中断信号                                            │
│           │                                                     │
│           ▼                                                     │
│  2. 中断向量表查找                                             │
│     根据中断号查找处理函数                                       │
│           │                                                     │
│           ▼                                                     │
│  3. 保存上下文                                                  │
│     保存当前进程状态                                             │
│           │                                                     │
│           ▼                                                     │
│  4. 执行中断处理程序（ISR）                                     │
│     调用具体的中断处理函数                                       │
│           │                                                     │
│           ▼                                                     │
│  5. 恢复上下文                                                  │
│     恢复进程状态                                                │
│           │                                                     │
│           ▼                                                     │
│  6. 返回被中断的进程                                            │
│     继续执行或调度新进程                                         │
│                                                              │
└─────────────────────────────────────────────────────────────────┘
```

**中断 vs 异常：**
```
┌────────────────┬─────────────────┬─────────────────┐
│      特性      │      中断       │      异常       │
├────────────────┼─────────────────┼─────────────────┤
│  异步/同步    │     异步        │      同步       │
│  发生时机     │    任意时刻     │    指令执行时   │
│  产生者       │     外设        │      CPU        │
│  处理方式     │   立即响应      │   当前指令后    │
│  可恢复       │     可恢复      │   可能不可恢复  │
│  例子         │  时钟、I/O     │  页错误、除零   │
└────────────────┴─────────────────┴─────────────────┘
```

**系统调用：**
```c
// 系统调用是特殊的"软中断"
// 用户态 → 内核态的方式之一

// 示例：read() 系统调用
ssize_t read(int fd, void* buf, size_t count) {
    // 1. 将参数放入寄存器
    // eax = __NR_read
    // ebx = fd
    // ecx = buf
    // edx = count
    
    // 2. 触发软中断
    asm volatile("int $0x80" : : : "memory");
    
    // 3. 内核处理 read
    // 4. 返回结果
    return result;
}

// 现代替代：syscall 指令
asm volatile("syscall" 
    : "=a"(result)
    : "a"(__NR_read), "D"(fd), "S"(buf), "d"(count)
    : "rcx", "r11", "memory");
```
