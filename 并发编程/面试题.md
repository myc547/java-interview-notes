# 并发编程 面试题

## 题目
## 2. 线程池工作流程？
## 3. synchronized和Lock的区别？
## 4. volatile的作用？
## 5. CAS的原理？
## 6. AQS的理解？
## 7. ThreadLocal的作用与内存泄漏？
## 8. 线程状态转换？
## 9. 死锁产生条件？
## 10. ConcurrentHashMap原理？

## 答案

**题目：**
线程池有哪些核心参数？

**答案：**
**线程池7大核心参数：**
```java
public ThreadPoolExecutor(
    int corePoolSize,           // 核心线程数
    int maximumPoolSize,        // 最大线程数
    long keepAliveTime,         // 空闲线程存活时间
    TimeUnit unit,              // 时间单位
    BlockingQueue<Runnable> workQueue,  // 任务队列
    ThreadFactory threadFactory,        // 线程工厂
    RejectedExecutionHandler handler    // 拒绝策略
)
```

**参数说明：**
- **corePoolSize**：核心线程数，即使空闲也不销毁
- **maximumPoolSize**：最大线程数，核心+临时
- **keepAliveTime**：临时线程空闲存活时间
- **workQueue**：任务等待队列
- **threadFactory**：创建线程的工厂
- **handler**：拒绝策略

---

## 2. 线程池工作流程？

**题目：**
线程池的工作流程是什么？

**答案：**
**线程池执行流程：**
```
┌─────────────────────────────────────────────────────────┐
│                   任务提交                              │
└─────────────────────────┬───────────────────────────────┘
                          ↓
              ┌───────────┴───────────┐
              │  核心线程数 < corePoolSize?  │
              └───────────┬───────────┘
                     ↓是         ↓否
              ┌───────────┴───────────┐
              │  队列已满?             │
              └───────────┬───────────┘
                   否         ↓是
              ┌───────────┴───────────┐
              │  最大线程数 < maxPoolSize?  │
              └───────────┬───────────┘
                     ↓是         ↓否
         ┌───────────┴───────────┐
         │  执行拒绝策略          │
         └───────────────────────┘
```

**示例：**
```java
// 核心2，最大4，队列容量10
ThreadPoolExecutor pool = new ThreadPoolExecutor(
    2, 4, 60, TimeUnit.SECONDS,
    new ArrayBlockingQueue<>(10),
    Executors.defaultThreadFactory(),
    new ThreadPoolExecutor.AbortPolicy()
);

// 任务1-2：核心线程执行
// 任务3-12：队列等待（2+10=12）
// 任务13-16：临时线程执行
// 任务17+：拒绝执行
```

---

## 3. synchronized和Lock的区别？

**题目：**
synchronized和Lock有什么区别？

**答案：**
| 特性 | synchronized | Lock |
|------|--------------|------|
| **来源** | Java关键字 | 接口（JUC） |
| **锁的释放** | 自动释放（异常也释放） | 需手动unlock() |
| **等待可中断** | 不可中断 | 可中断 |
| **公平锁** | 非公平 | 可公平可非公平 |
| **锁的状态** | 无法判断 | tryLock()可判断 |
| **锁的粒度** | 粗粒度（类、方法、代码块） | 细粒度（代码块） |
| **condition** | 无 | 可多个Condition |

**使用示例：**
```java
// synchronized
synchronized (obj) {
    // 临界区
}

// Lock
Lock lock = new ReentrantLock();
lock.lock();
try {
    // 临界区
} finally {
    lock.unlock();
}

// 可中断
lock.lockInterruptibly();
```

---

## 4. volatile的作用？

**题目：**
volatile关键字有什么作用？

**答案：**
**volatile三大特性：**
1. **可见性** - 线程间立即可见
2. **有序性** - 禁止指令重排序
3. **不保证原子性**

**示例：**
```java
// 不使用volatile - 可能死循环
private boolean flag = true;

// 使用volatile - 立即可见
private volatile boolean flag = true;

// 场景：状态标记、双重检查锁
```

**与synchronized对比：**
| 特性 | volatile | synchronized |
|------|----------|--------------|
| 可见性 | ✅ | ✅ |
| 有序性 | ✅ | ✅ |
| 原子性 | ❌ | ✅ |
| 性能 | 快 | 慢 |

---

## 5. CAS的原理？

**题目：**
CAS是什么？原理是什么？

**答案：**
**CAS（Compare-And-Swap）：**
- 比较并交换，无锁并发算法
- CPU级别的原子指令

**CAS流程：**
```java
// CAS三个参数
// object：对象
// offset：内存偏移量
// expected：期望值
// newValue：新值

// 底层实现
while (true) {
    int current = getIntVolatile(object, offset);
    if (current == expected) {
        // 成功，设置新值，返回true
        setIntVolatile(object, offset, newValue);
        return true;
    }
    // 失败，更新expected，继续重试
    expected = current;
}
```

**CAS三大问题：**
1. **ABA问题** - 值被修改又改回
   - 解决：版本号（AtomicStampedReference）
2. **循环时间长** - 自旋开销大
3. **只能保证一个变量** - 多变量需用AtomicReference

---

## 6. AQS的理解？

**题目：**
什么是AQS？

**答案：**
**AQS（AbstractQueuedSynchronizer）：**
- 抽象队列同步器
- JUC并发工具的底层框架

**核心思想：**
- 同步状态（state）
- FIFO队列（CLH队列）
- 模板方法模式

**AQS原理：**
```
state = 0（无锁）
state = 1（有锁）

获取锁：
1. CAS尝试修改state
2. 失败则加入等待队列
3. 自旋等待

释放锁：
1. 修改state为0
2. 唤醒队列头部线程
```

**常见实现：**
- **ReentrantLock**：可重入锁
- **CountDownLatch**：倒计时
- **Semaphore**：信号量
- **CyclicBarrier**：栅栏

---

## 7. ThreadLocal的作用与内存泄漏？

**题目：**
ThreadLocal是什么？如何导致内存泄漏？

**答案：**
**ThreadLocal作用：**
- 线程本地变量
- 每个线程独立存储

**原理：**
```java
// ThreadLocalMap结构
class ThreadLocalMap {
    Entry[] table;
    
    static class Entry extends WeakReference<ThreadLocal<?>> {
        Object value;  // 实际存储的值
    }
}
```

**内存泄漏原因：**
```
ThreadLocal生命周期 = 线程生命周期
ThreadLocal对象 = 弱引用（可被GC）
value = 强引用（不可被GC）

当ThreadLocal对象被回收后：
Entry.key = null（弱引用）
Entry.value = 强引用（仍保留）
value无法被访问，也无法被回收
```

**解决方案：**
```java
// 使用完毕后remove
threadLocal.remove();

// 避免使用try-finally
try {
    threadLocal.set(value);
} finally {
    threadLocal.remove();
}
```

---

## 8. 线程状态转换？

**题目：**
线程有哪些状态？状态如何转换？

**答案：**
**线程6种状态：**
```
NEW → RUNNABLE → BLOCKED → WAITING → TIMED_WAITING → TERMINATED
```

**状态图：**
```
          ┌─────────────┐
          │    NEW      │  → 创建线程对象
          └──────┬──────┘
                 ↓
          ┌─────────────┐
          │  RUNNABLE   │  → start()
          └──────┬──────┘
                 ↓
    ┌────────────┼────────────┐
    ↓            ↓            ↓
┌───────┐  ┌──────────┐  ┌───────────┐
│BLOCKED│  │ WAITING  │  │TIMED_WAITING│
└───────┘  └──────────┘  └───────────┘
    ↑            ↑            ↑
  synchronized  wait()      sleep()
                 join()      wait(timeout)
                            notify()
    ↓            ↓            ↓
          ┌─────────────┐
          │ TERMINATED  │  → 线程执行完毕
          └─────────────┘
```

---

## 9. 死锁产生条件？

**题目：**
死锁产生的条件是什么？如何预防？

**答案：**
**死锁4大必要条件：**
1. **互斥** - 资源只能被一个线程持有
2. **持有并等待** - 持有资源并等待其他资源
3. **不可剥夺** - 资源不能被强制剥夺
4. **循环等待** - 形成资源等待环

**死锁示例：**
```java
// 线程1
synchronized (A) {
    Thread.sleep(100);
    synchronized (B) {
        // 操作
    }
}

// 线程2
synchronized (B) {
    Thread.sleep(100);
    synchronized (A) {
        // 操作
    }
}
```

**预防方法：**
- **破坏互斥**：无法破坏（锁的本质）
- **破坏持有并等待**：一次性获取所有资源
- **破坏不可剥夺**：设置超时
- **破坏循环等待**：按顺序获取锁

---

## 10. ConcurrentHashMap原理？

**题目：**
ConcurrentHashMap的原理是什么？

**答案：**
**JDK7 vs JDK8：**
- **JDK7**：Segment数组 + HashEntry数组
- **JDK8**：Node数组 + CAS + Synchronized

**JDK8原理：**
```java
// 数组结构
transient volatile Node<K,V>[] table;

// Node结构
class Node<K,V> {
    final int hash;
    final K key;
    volatile V value;
    final Node<K,V> next;
}

// 并发安全
// 读：无锁（volatile）
// 写：synchronized + CAS
```

**put流程：**
```
1. 计算hash
2. 检查数组是否为空
3. CAS尝试扩容
4. synchronized锁住头节点
5. 遍历链表/红黑树
6. 插入/更新
7. 判断是否转红黑树
```

**JDK7 vs JDK8：**
| 特性 | JDK7 | JDK8 |
|------|------|------|
| 结构 | Segment+HashEntry | Node+CAS |
| 锁粒度 | Segment级别 | 头节点级别 |
| 并发度 | 16 | 数组长度 |
| 链表转红黑树 | 不支持 | 支持 |

---

*更多并发编程面试题答案*

---

## P8 级高并发实战

### 高并发库存扣减系统设计

**题目：**
设计一个支持高并发的库存扣减系统，要求：
- 库存不超卖
- 高性能（支持 10 万 QPS）
- 数据一致性
- 支持分布式事务

**答案：**

**1. 核心挑战**

- **超卖问题**：多个请求同时读取库存
- **数据一致性**：库存扣减必须准确
- **热点数据**：热门商品库存是热点

**2. 方案一：数据库扣减**

```sql
-- 乐观锁
UPDATE inventory SET stock = stock - 1 
WHERE product_id = ? AND stock > 0;

-- 或悲观锁（不推荐）
SELECT stock FROM inventory WHERE product_id = ? FOR UPDATE;
```

**问题：** 数据库是瓶颈

**3. 方案二：Redis 缓存 + 异步落库**

```
用户请求 → Redis 扣减 → 消息队列 → MySQL 落库
```

**Redis 原子扣减脚本：**
```lua
local stock = redis.call('GET', KEYS[1])
if stock and tonumber(stock) > 0 then
    redis.call('DECR', KEYS[1])
    return 1
else
    return 0
end
```

**异步落库：**
- 使用 Kafka/RocketMQ 异步同步到数据库
- 定时对账：Redis 数据 vs 数据库

**4. 方案三：库存分桶**

```
库存 10000 → 分成 10 个桶，每个桶 1000
               ↓
       Bucket1 → Redis Key1
       Bucket2 → Redis Key2
               ↓
       请求随机分配到不同桶
```

**优点：** 分散热点，提升并发度

**5. 最终一致性方案**

1. Redis 扣减成功，返回"排队中"
2. 发送消息到 MQ
3. 消费者消费消息，扣减数据库
4. 定时任务对账，修复不一致数据

**6. 库存回滚**

```java
try {
    boolean success = redisService.decr(key);
    if (!success) throw new StockNotEnoughException();
    mqService.send(new InventoryMessage(orderId, productId, count));
} catch (Exception e) {
    redisService.incr(key);  // 回滚
}
```

**7. 限流与熔断**

- 使用 Sentinel/Hystrix 限流
- 库存耗尽后快速失败
- 熔断保护下游服务
