# P8 架构师级面试题

## 系统设计类

### 1. 请设计一个支持每秒 100 万 QPS 的短链接系统

**题目：**
请设计一个支持每秒 100 万 QPS 的短链接生成系统，要求：
- 短链接长度为 6-8 位
- 支持高并发写入和读取
- 保证 99.99% 的可用性
- 支持缓存预热和热点数据处理
- 数据持久化和灾备方案

**答案：**

**整体架构：**

```
用户请求 → CDN → 负载均衡 → API 网关 → 业务服务集群 → Redis 集群 + MySQL 分库分表
```

**核心设计要点：**

1. **短链接生成算法**
   - 方案一：分布式 ID 生成器（雪花算法 + 62 进制编码）
   - 方案二：预生成号段 + 本地缓存
   - 容量：6 位 = 62^6 ≈ 568 亿，8 位 = 218 万亿

2. **高并发读取优化**
   - 多级缓存：本地缓存（Caffeine/Guava）→ Redis 集群 → MySQL
   - Redis 集群：采用 CRC16 分片，支持 1000 万 QPS
   - 数据预热：热点数据提前加载到缓存
   - 布隆过滤器：过滤不存在的短链接，减少 Redis 请求

3. **高并发写入优化**
   - 异步写入：先写 Redis → 批量同步到 MySQL
   - 消息队列：Kafka 处理写入请求，削峰填谷
   - 号段模式：每个节点预分配号段，减少锁竞争

4. **数据分片**
   - MySQL 分库分表：按短链接 hash 分片
   - 路由层：一致性哈希或范围分片
   - 读写分离：主库写入，从库读取

5. **高可用设计**
   - 多机房部署：主备机房
   - 容灾：数据多副本（3 副本）
   - 熔断降级：Hystrix/Sentinel
   - 健康检查：心跳检测，自动剔除故障节点

6. **监控与运维**
   - Prometheus + Grafana 监控
   - 日志：ELK 日志系统
   - 告警：异常 QPS、延迟告警

---

### 2. 设计一个分布式 ID 生成器

**题目：**
设计一个高性能、高可用的分布式 ID 生成器，支持每秒生成 100 万个 ID，要求：
- 全局唯一
- 趋势递增（方便索引）
- 可反解（包含时间戳、机器号等信息）
- 支持水平扩展

**答案：**

**方案一：雪花算法（Snowflake）**

```
64 位二进制结构：
| 符号位(1) | 时间戳(41) | 机器 ID(10) | 序列号(12) |
|-----------|-----------|-------------|------------|
| 0         | 41 位     | 10 位       | 12 位      |
```

**优点：**
- 高性能：单机每秒可生成约 400 万个 ID
- 趋势递增
- 可反解（时间戳、机器 ID、序列号）

**问题与解决：**
- **时钟回拨**：使用历史最大时间戳
- **机器 ID 分配**：ZooKeeper / etcd / 数据库分配

**方案二：号段模式**

```
+------------------+     +------------------+     +------------------+
|  ID 生成服务 A    |     |  ID 生成服务 B    |     |  ID 生成服务 C    |
+------------------+     +------------------+     +------------------+
|  当前号段:        |     |  当前号段:        |     |  当前号段:        |
|  [10001-20000]   |     |  [20001-30000]   |     |  [30001-40000]   |
+------------------+     +------------------+     +------------------+
         ↓                       ↓                       ↓
    [ 号段存储：Redis/MySQL ]
```

**优点：**
- 简单可靠
- 适合大数据量场景

---

### 3. 如何设计一个高可用的消息队列？

**题目：**
设计一个支持千万级 QPS 的高可用消息队列，要求：
- 消息不丢失（至少一次投递）
- 消息顺序性
- 消息积压处理
- 支持多机房容灾

**答案：**

**架构设计：**

```
Producer → Broker Cluster ← Consumer Group
            ↓
     元数据存储（ZooKeeper/etcd）
```

**核心设计要点：**

1. **消息持久化**
   - 顺序写入磁盘（Append Only）
   - 页缓存优化
   - 异步刷盘 + 同步刷盘可选

2. **高可用**
   - 多副本机制（Raft/Paxos）
   - Leader/Follower 切换
   - 消费者重试机制

3. **消息顺序性**
   - 全局顺序：单分区
   - 组内顺序：按 Key hash 到同一分区

4. **消息积压**
   - 动态扩容分区
   - 消费者并行消费
   - 流量控制

5. **数据迁移**
   - 分区重平衡
   - 迁移工具

---

## 深度原理类

### 4. 请详细解释 MySQL 的 MVCC 机制

**题目：**
请详细解释 MySQL InnoDB 的 MVCC（多版本并发控制）机制，包括：
- 隐藏字段
- ReadView 结构
- 快照读与当前读
- 事务隔离级别的实现

**答案：**

**1. 隐藏字段**

每行数据包含三个隐藏字段：
- `DB_TRX_ID`：最近修改的事务 ID
- `DB_ROLL_PTR`：回滚指针，指向 undo log
- `DB_ROW_ID`：隐式主键（如果没有显式主键）

**2. Undo Log 版本链**

```
+-----+------+
| id  | name |
+-----+------+
| 1   | A    |  → [undo log] → version 2: (1, B)
+-----+------+
      |      → [undo log] → version 1: (1, A)
      ↓
  DB_ROLL_PTR
```

**3. ReadView 结构**

```
struct ReadView {
    trx_ids;        // 活跃事务 ID 列表
    low_limit_id;   // 事务 ID 上限
    up_limit_id;    // 事务 ID 下限
    creator_trx_id; // 当前事务 ID
}
```

**4. 可见性判断**

```
if (trx_id < up_limit_id)      → 可见（已提交）
else if (trx_id >= low_limit_id) → 不可见（未开始）
else if (trx_id in trx_ids)     → 不可见（活跃中）
else                             → 可见（已提交）
```

**5. 隔离级别实现**

| 隔离级别 | ReadView 生成时机 | 可见性 |
|---------|-----------------|-------|
| READ UNCOMMITTED | 每次读取 | 所有版本 |
| READ COMMITTED | 每次 SELECT | 已提交 |
| REPEATABLE READ | 事务开始时 | 事务开始时已提交 |
| SERIALIZABLE | - | 锁表 |

**6. 快照读 vs 当前读**

- **快照读**：SELECT 语句，读取历史版本（MVCC）
- **当前读**：SELECT ... LOCK IN SHARE MODE / FOR UPDATE，读取最新版本

---

### 5. Redis 是如何实现高可用的？

**题目：**
请详细解释 Redis 的高可用方案，包括：
- 主从复制原理
- Sentinel 哨兵机制
- Cluster 集群模式
- 数据分片策略

**答案：**

**1. 主从复制（Replication）**

```
Master → Slave1
    ↓
  Slave2
```

**复制流程：**
1. Slave 连接 Master，发送 `PSYNC` 命令
2. Master 执行 `BGSAVE`，生成 RDB 文件
3. Master 将缓冲区（replication buffer）发送给 Slave
4. Master 后续的命令同步发送给 Slave

**全量复制 vs 增量复制：**
- 全量复制：首次同步，传输 RDB 文件
- 增量复制：断线重连，传输积压命令

**2. Sentinel 哨兵**

```
+----+      +----+
| S1 | ---- | S2 |  ← 哨兵集群（奇数个）
+----+      ++----+
   |          |
   v          v
+----+      +----+
| M  |      | S3 |
+----+      +----+
   |
+--+--+
|Slave1|
+--+--+
   |
+--+--+
|Slave2|
+--+--+
```

**Sentinel 职责：**
- 监控：检查 Master/Slave 健康状态
- 通知：推送故障转移通知
- 自动故障转移：选举新 Master
- 配置提供者：提供 Master 地址

**故障转移流程：**
1. Sentinel 1 检测到 Master 下线，标记为主观下线
2. 超过 quorum 个 Sentinel 确认，标记为客观下线
3. 选举领头 Sentinel（基于配置优先级、Raft 算法）
4. 领头 Sentinel 选择新 Master（优先级、偏移量、Run ID）
5. 领头 Sentinel 让其他 Slave 指向新 Master
6. 旧 Master 上线后变为新 Master 的 Slave

**3. Cluster 集群模式**

```
                    +------------------+
                    |  客户端（Smart）  |
                    +--------+---------+
                             |
              +--------------+--------------+
              |              |              |
        +-----v-----+  +-----v-----+  +-----v-----+
        | Node 1    |  | Node 2    |  | Node 3    |
        | (Master)  |  | (Master)  |  | (Master)  |
        +--+--+--+--+  +--+--+--+--+  +--+--+--+--+
           |  |  |        |  |  |        |  |  |
        +--+--+--+--+  +--+--+--+--+  +--+--+--+--+
        | Replica 1  |  | Replica 2  |  | Replica 3  |
        +------------+  +------------+  +------------+
```

**数据分片：**
- 哈希槽（Hash Slot）：16384 个槽
- `CRC16(key) % 16384` 计算槽号
- 槽号分配给不同节点

**故障转移：**
- Master 下线 → 对应 Slave 自动提升为 Master
- 手动 `CLUSTER FAILOVER` 手动切换

**4. 一致性保证**

- **最终一致性**：主从复制是异步的
- **强一致性**：使用 `WAIT` 命令或 `MULTI/EXEC` 事务
- **读写分离**：读操作可以分散到 Slave

---

### 6. Kafka 是如何保证消息顺序性的？

**题目：**
请详细解释 Kafka 的消息顺序性保证机制，包括：
- 分区内有序
- 全局有序的实现方式
- 乱序原因及解决方案

**答案：**

**1. 分区内有序**

```
Topic: MyTopic
Partition 0: [msg1, msg2, msg3, msg4, msg5]  ← 有序
Partition 1: [msg1, msg2, msg3, msg4, msg5]  ← 有序
```

Kafka 保证**单个分区内消息有序**，跨分区不保证。

**2. 全局有序的实现方式**

**方案一：单分区**
- 只有一个 Partition
- 缺点：吞吐量低

**方案二：按 Key hash**
- 相同 Key 的消息发送到同一 Partition
- 缺点：只能保证相同 Key 的消息有序

**3. 乱序原因**

- **原因 1：消费者并行消费**
  ```
  Partition: [msg1, msg2, msg3, msg4, msg5]
               ↓ ↓ ↓
             Consumer1 msg1 msg3 msg5
             Consumer2 msg2 msg4
  ```
  解决：单线程消费或按 Partition 分配消费者

- **原因 2：生产者批量发送**
  ```
  批量发送： [msg1, msg2] [msg3, msg4]
  网络传输： [msg3, msg4] 可能比 [msg1, msg2] 先到
  ```
  解决：按批次 ID 有序发送，或使用 `max.in.flight.requests.per.connection=1`

- **原因 3：ISR 动态变化**
  - Leader 切换时，可能丢失消息
  - 解决：设置 `min.insync.replicas`

**4. 生产者配置**

```java
Properties props = new Properties();
props.put("acks", "all");          // 等待所有副本确认
props.put("max.in.flight.requests.per.connection", 1); // 串行发送
props.put("enable.idempotence", true); // 幂等性
```

**5. 消费者配置**

```java
// 保证同一 Partition 内的消息被同一消费者消费
consumer.assign(Arrays.asList(topicPartition));
consumer.seek(topicPartition, offset); // 从指定位置消费
```

---

## 性能优化类

### 7. 如何进行 JVM 调优？

**题目：**
请说明 JVM 调优的核心思路和常用参数，包括：
- 内存模型调优
- GC 策略选择
- OOM 问题排查
- 常用诊断工具

**答案：**

**1. JVM 内存模型**

```
+-------------------+-------------------+-------------------+
|      Eden         |   Survivor S0     |   Survivor S1     |
|   (新生代 8/10)    |    (1/10)         |    (1/10)        |
+-------------------+-------------------+-------------------+
|                          Old Gen (老年代)                    |
+-----------------------------------------------------------+
|                        Metaspace                            |
+-----------------------------------------------------------+
|                   Code Cache (JIT 编译缓存)                |
+-----------------------------------------------------------+
```

**2. 常用调优参数**

**堆内存：**
```bash
-Xms4g                    # 初始堆大小
-Xmx4g                    # 最大堆大小
-Xmn2g                    # 新生代大小
-XX:SurvivorRatio=8       # Eden:S0:S1 = 8:1:1
-XX:NewRatio=2            # 老年代:新生代 = 2:1
```

**元空间：**
```bash
-XX:MetaspaceSize=256m    # 元空间初始大小
-XX:MaxMetaspaceSize=512m # 元空间最大大小
```

**GC 日志：**
```bash
-Xlog:gc*:file=gc.log:time # 详细 GC 日志
```

**3. GC 策略选择**

| 场景 | 推荐 GC | 原因 |
|-----|--------|-----|
| 吞吐量优先 | Parallel GC | 多线程并行收集 |
| 延迟优先 | G1 / ZGC | 可控暂停时间 |
| 大堆内存（>64G） | ZGC / Shenandoah | 低暂停时间 |
| 小应用 | Serial GC | 简单，资源占用少 |

**G1 调优：**
```bash
-XX:MaxGCPauseMillis=200    # 最大暂停时间目标
-XX:G1HeapRegionSize=16m    # Region 大小
-XX:InitiatingHeapOccupancyPercent=45 # 触发 Mixed GC 的阈值
```

**4. OOM 问题排查**

**OutOfMemoryError 类型：**
- `Java heap space`：堆内存不足
- `Metaspace`：元空间不足
- `GC overhead limit exceeded`：GC 耗时过长
- `Unable to create new native thread`：线程数限制

**排查步骤：**
```bash
# 1. 导出堆内存快照
jmap -dump:format=b,file=heap.hprof <pid>

# 2. 分析内存泄漏
jhat heap.hprof
# 或使用 MAT (Memory Analyzer Tool)

# 3. 查看对象占用
jmap -histo <pid> | head -20

# 4. 实时监控
jconsole
jvisualvm
```

**5. 常用诊断工具**

```bash
jps              # 查看 Java 进程
jinfo            # 查看 JVM 参数
jstat            # 查看 GC 统计信息
jstack           # 查看线程堆栈
jmap             # 导出内存快照
jcmd             # 执行 JVM 命令
```

---

### 8. 如何设计一个高并发的扣减库存系统？

**题目：**
设计一个支持高并发的库存扣减系统，要求：
- 库存不超卖
- 高性能（支持 10 万 QPS）
- 数据一致性
- 支持分布式事务

**答案：**

**1. 核心挑战**

- **超卖问题**：多个请求同时读取库存
- **数据一致性**：库存扣减必须准确
- **热点数据**：热门商品库存是热点

**2. 方案一：数据库扣减**

```sql
-- 乐观锁
UPDATE inventory SET stock = stock - 1 
WHERE product_id = ? AND stock > 0;

-- 或悲观锁（不推荐）
SELECT stock FROM inventory WHERE product_id = ? FOR UPDATE;
```

**问题：** 数据库是瓶颈

**3. 方案二：Redis 缓存 + 异步落库**

```
用户请求 → Redis 扣减 → 消息队列 → MySQL 落库
              ↓
         库存不足？
```

**Redis 扣减脚本：**
```lua
-- 原子扣减
local stock = redis.call('GET', KEYS[1])
if stock and tonumber(stock) > 0 then
    redis.call('DECR', KEYS[1])
    return 1
else
    return 0
end
```

**异步落库：**
- 使用 Kafka/RocketMQ 异步同步到数据库
- 定时对账：Redis 数据 vs 数据库

**4. 方案三：库存分桶**

```
库存 10000 → 分成 10 个桶，每个桶 1000
               ↓
       Bucket1 → Redis Key1
       Bucket2 → Redis Key2
               ↓
       请求随机分配到不同桶
```

**优点：**
- 分散热点
- 提升并发度

**5. 最终一致性方案**

```
1. Redis 扣减成功，返回"排队中"
2. 发送消息到 MQ
3. 消费者消费消息，扣减数据库
4. 定时任务对账，修复不一致数据
```

**6. 库存回滚**

```java
try {
    // 1. Redis 扣减
    boolean success = redisService.decr(key);
    if (!success) throw new StockNotEnoughException();
    
    // 2. 发送 MQ 消息
    mqService.send(new InventoryMessage(orderId, productId, count));
    
} catch (Exception e) {
    // 3. 回滚 Redis
    redisService.incr(key);
}
```

**7. 限流与熔断**

- 使用 Sentinel/Hystrix 限流
- 库存耗尽后快速失败
- 熔断保护下游服务

---

## 分布式事务类

### 9. 分布式事务的几种方案对比

**题目：**
请对比 2PC、3PC、TCC、Seata AT 等分布式事务方案的优缺点，并说明适用场景。

**答案：**

**1. 2PC（两阶段提交）**

```
Phase 1: 准备阶段
Coordinator → 所有 Participant：Can you commit?
Participant → Coordinator：YES/NO

Phase 2: 提交阶段
Coordinator → 所有 Participant：COMMIT/ROLLBACK
Participant → Coordinator：ACK
```

**优点：**
- 强一致性
- 实现简单

**缺点：**
- 同步阻塞
- 单点故障（Coordinator）
- 数据不一致（部分提交）

**2. 3PC（三阶段提交）**

```
Phase 1: CanCommit
Phase 2: PreCommit
Phase 3: DoCommit
```

**改进：**
- 减少阻塞时间
- 引入超时机制
- 但仍然有数据不一致风险

**3. TCC（Try-Confirm-Cancel）**

```
Try：预留资源
Confirm：确认执行
Cancel：取消预留
```

**优点：**
- 业务层面控制
- 性能较好
- 不阻塞

**缺点：**
- 侵入性强
- 需要实现三个接口
- 空回滚、幂等问题

**4. Seata AT 模式**

```
Phase 1: 解析 SQL，记录前后镜像
Phase 2: 提交事务，异步删除记录
```

**优点：**
- 无侵入
- 性能好
- 自动补偿

**缺点：**
- 依赖数据库事务
- 只支持 MySQL、Oracle 等

**5. 方案对比表**

| 方案 | 一致性 | 性能 | 复杂度 | 侵入性 | 适用场景 |
|-----|-------|-----|-------|-------|---------|
| 2PC | 强 | 低 | 低 | 低 | 单体数据库 |
| 3PC | 强 | 低 | 中 | 低 | 不常用 |
| TCC | 最终 | 中 | 高 | 高 | 金融、电商 |
| Seata AT | 最终 | 高 | 低 | 低 | 微服务 |
| 消息事务 | 最终 | 高 | 中 | 中 | 异步场景 |

**6. 选型建议**

- **强一致性**：2PC（低并发场景）
- **高性能**：Seata AT、TCC
- **异步解耦**：消息事务
- **简单场景**：本地消息表

---

### 10. 如何设计一个支持 100 万用户的即时通讯系统？

**题目：**
设计一个支持百万级用户的即时通讯系统（IM），要求：
- 实时性：消息延迟 < 100ms
- 高可用：99.99%
- 支持单聊、群聊
- 消息必达

**答案：**

**整体架构：**

```
Client → Gateway Server → Message Server → Redis（在线状态） + MQ + DB
                                     ↓
                              离线消息存储
```

**1. 单聊消息流程**

```
A 发送消息给 B：
1. A → Gateway1
2. Gateway1 → Message Server
3. Message Server → 检查 B 在线状态（Redis）
4. 如果 B 在线：推送到 B 连接的 Gateway2
5. 如果 B 离线：存储到离线消息库（MySQL/MongoDB）
6. B 上线后：拉取离线消息
```

**2. 消息 ID 设计**

```java
// 雪花算法 + 类型前缀
String msgId = "msg_" + snowflake.nextId();
// 或 UUID（性能稍差）
```

**3. 在线状态管理**

```
Redis 结构：
- Hash: user:{userId}:session → {gatewayId, deviceType, lastActiveTime}
- Set: online_users → [userId1, userId2, ...]
```

**4. 群聊消息**

```
A 发送群聊消息：
1. A → Gateway
2. Gateway → Message Server
3. Message Server → 查询群成员列表（Redis Group Cache）
4. 遍历成员，逐个推送（或批量推送）
5. 离线成员存储离线消息
```

**群成员存储：**
- Redis Sorted Set：member:{groupId} → {userId, joinTime}
- DB：群成员表

**5. 消息推送策略**

**在线推送：**
```java
// Gateway 本地推送
gatewayService.push(userId, message);

// 如果用户连接到其他 Gateway
// 使用 Redis Pub/Sub 或消息队列跨 Gateway 推送
```

**离线推送：**
- 存储到 MongoDB/MySQL
- 用户上线后拉取

**6. 心跳保活**

```java
// 客户端心跳
client.sendHeartbeat();

// 服务端检测
// 超过 2 分钟无心跳 → 标记离线
```

**7. 消息可靠性**

**消息 ID**：全局唯一
**消息确认**：客户端收到后 ACK
**重试机制**：未确认消息定时重试
**去重**：基于消息 ID 去重

**8. 消息漫游**

- 多端同步：消息存储到云端
- 拉取历史：按时间戳拉取

**9. 扩容方案**

**Gateway 层**：无状态，水平扩展
**Message Server**：按用户 ID hash 分片
**Redis 集群**：数据分片
**数据库分库**：按用户 ID 分库

---

## 业务架构类

### 11. 如何设计一个秒杀系统？

**题目：**
设计一个秒杀系统，要求：
- 高并发：10 万 QPS
- 库存超卖率为 0
- 99.99% 可用性
- 防刷防爬

**答案：**

**整体架构：**

```
用户 → CDN → 负载均衡 → 秒杀服务集群 → Redis 集群 + MQ + MySQL
                    ↓
              熔断限流（Sentinel）
```

**1. 前端优化**

- 静态化：商品详情页 CDN 缓存
- 秒杀按钮：倒计时结束才可点击
- 验证码：防止机器刷请求
- 请求合并：多次点击只发一次请求

**2. 流量削峰**

```java
// 方案一：令牌桶限流
RateLimiter limiter = RateLimiter.create(10000); // 每秒 1 万令牌

// 方案二：请求队列
BlockingQueue<Request> queue = new LinkedBlockingQueue<>(10000);

// 方案三：验证码
CaptchaService.generate(orderId);
```

**3. 库存扣减**

```java
// Redis 原子扣减
String stockKey = "seckill:product:" + productId;
Long stock = redisTemplate.opsForValue().decrement(stockKey);

if (stock < 0) {
    // 库存不足，返回秒杀结束
    return SeckillResult.OUT_OF_STOCK;
}

// 发送订单创建消息到 MQ
mqService.send(createOrderMessage);
```

**4. 异步下单**

```
Redis 扣减成功 → 发送 MQ → 消费者创建订单 → 订单入库 → 发送通知
```

**5. 库存超卖问题**

```lua
-- Redis 脚本原子扣减
local stock = redis.call('GET', KEYS[1])
if stock and tonumber(stock) > 0 then
    local newStock = redis.call('DECR', KEYS[1])
    if tonumber(newStock) >= 0 then
        return 1  -- 扣减成功
    else
        redis.call('INCR', KEYS[1])  -- 回滚
        return 0  -- 库存不足
    end
else
    return -1  -- 库存不足
end
```

**6. 防刷策略**

- 单用户限流：单个用户每秒只能请求 N 次
- 单 IP 限流：单个 IP 限制
- 设备指纹：识别机器请求
- 验证码：复杂验证码

```java
// 单用户限流
String userLimitKey = "seckill:limit:user:" + userId;
Long count = redisTemplate.opsForValue().increment(userLimitKey);
if (count > 10) {
    throw new RequestLimitException("请求过于频繁");
}
redisTemplate.expire(userLimitKey, 1, TimeUnit.SECONDS);
```

**7. 高可用设计**

- 多机房部署
- 熔断降级：库存耗尽后快速失败
- 降级：Redis 挂了使用本地缓存兜底
- 监控告警：QPS、成功率、延迟告警

**8. 订单超时处理**

```java
// 订单超时未支付，回滚库存
@Scheduled(cron = "0 */1 * * * ?")
public void cancelTimeoutOrder() {
    List<Order> timeoutOrders = orderService.findTimeoutOrders();
    for (Order order : timeoutOrders) {
        // 回滚库存
        redisTemplate.opsForValue().increment(
            "seckill:product:" + order.getProductId()
        );
        // 取消订单
        orderService.cancel(order.getId());
    }
}
```

---

## 总结

### P8 级别考察重点

1. **系统设计能力**：从 0 到 1 设计系统
2. **深度原理**：底层原理的理解
3. **性能优化**：调优思路和实战经验
4. **分布式系统**：CAP、分布式事务、一致性
5. **业务架构**：理解业务，设计合理架构
6. **技术选型**：权衡利弊，选择合适方案

### 学习建议

1. **深入源码**：阅读经典框架源码
2. **实战经验**：参与大流量项目
3. **总结沉淀**：写博客、做分享
4. **持续学习**：关注技术趋势
