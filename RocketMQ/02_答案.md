# RocketMQ面试题答案

## 1. RocketMQ架构和核心概念？

**题目：**
RocketMQ的架构是什么样的？

**答案：**
**RocketMQ架构：**
```
┌─────────────────────────────────────────────────────────────┐
│                      RocketMQ架构                           │
│                                                             │
│  ┌─────────────────────────────────────────────────────┐   │
│  │                      NameServer                      │   │
│  │   - 路由管理  - 元数据存储  - 心跳检测               │   │
│  └─────────────────────────────────────────────────────┘   │
│                          ↑                                 │
│  ┌─────────────────────────────────────────────────────┐   │
│  │                       Broker                         │   │
│  │   Master/Slave  - 消息存储  - 消费进度  - HA         │   │
│  └─────────────────────────────────────────────────────┘   │
│                          ↑                                 │
│  ┌─────────────────────────────────────────────────────┐   │
│  │                     Producer                         │   │
│  │   - 消息生产  - 路由选择  - 负载均衡                  │   │
│  └─────────────────────────────────────────────────────┘   │
│                          ↑                                 │
│  ┌─────────────────────────────────────────────────────┐   │
│  │                     Consumer                         │   │
│  │   - 消息消费  - 负载均衡  - 消费进度                  │   │
│  └─────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────┘
```

**核心概念：**

| 概念 | 说明 |
|------|------|
| **NameServer** | 路由注册中心 |
| **Broker** | 消息存储节点 |
| **Topic** | 消息主题 |
| **Message Queue** | 消息队列（物理概念） |
| **Producer** | 生产者 |
| **Consumer** | 消费者 |
| **Consumer Group** | 消费者组 |
| **Tag** | 消息标签（过滤） |

---

## 2. RocketMQ消息类型？

**题目：**
RocketMQ支持哪些消息类型？

**答案：**
**1. 普通消息（Normal Message）**
```java
// 发送
DefaultMQProducer producer = new DefaultMQProducer("group");
producer.send(new Message("Topic", "tag", "body".getBytes()));
```

**2. 顺序消息（Ordered Message）**
```java
// 按顺序发送
producer.send(new Message("Topic", "tag", "body".getBytes()),
    new MessageQueueSelector() {
        public MessageQueue select(List<MessageQueue> mqs, 
                                  Message msg, Object arg) {
            // 根据OrderId选择队列
            Integer id = (Integer) arg;
            return mqs.get(id % mqs.size());
        }
    }, orderId);
```

**3. 延时消息（Scheduled Message）**
```java
// 消息延迟Level
message.setDelayTimeLevel(3);  // 1s, 5s, 30s, 1m, 2m...

// Level: 1=1s, 2=5s, 3=30s, 4=1m, 5=2m, 6=10m, 7=30m, 8=1h, 9=2h
```

**4. 事务消息（Transaction Message）**
```java
// 半消息
Message msg = new Message("Topic", "body");

// 发送半消息
SendResult sendResult = producer.sendMessageInTransaction(msg, null);

// 本地事务执行
// 根据结果提交或回滚
```

**5. 批量消息（Batch Message）**
```java
List<Message> messages = Arrays.asList(
    new Message("Topic", "tag1", "body1".getBytes()),
    new Message("Topic", "tag2", "body2".getBytes())
);
producer.send(messages);
```

---

## 3. RocketMQ顺序消息实现？

**题目：**
RocketMQ如何实现顺序消息？

**答案：**
**顺序消息原理：**
```
同一订单的消息发送到同一队列
消费者按顺序消费
```

**实现方式：**
```java
// 生产者
public OrderResult processOrder(Order order) {
    // 1. 创建订单消息
    Message orderMsg = new Message(
        "OrderTopic", 
        "create_order", 
        order.toJSON().getBytes()
    );
    
    // 2. 支付消息
    Message payMsg = new Message(
        "OrderTopic", 
        "pay_order", 
        order.toJSON().getBytes()
    );
    
    // 3. 发货消息
    Message shipMsg = new Message(
        "OrderTopic", 
        "ship_order", 
        order.toJSON().getBytes()
    );
    
    // 发送时指定队列选择器
    producer.send(orderMsg, (mqs, msg, arg) -> {
        String orderId = (String) arg;
        int index = orderId.hashCode() % mqs.size();
        return mqs.get(Math.abs(index));
    }, order.getId());
    
    producer.send(payMsg, ..., order.getId());
    producer.send(shipMsg, ..., order.getId());
}

// 消费者
consumer.registerMessageListener(
    new MessageListenerOrderly() {
        public ConsumeOrderlyStatus consumeMessage(
            List<MessageExt> msgs, 
            ConsumeOrderlyContext context) {
            for (MessageExt msg : msgs) {
                // 按顺序处理
                process(msg);
            }
            return ConsumeOrderlyStatus.SUCCESS;
        }
    }
);
```

**注意事项：**
```
1. 同一订单的消息使用相同的orderId
2. 消费者使用MessageListenerOrderly
3. 消费失败会重试（最大16次）
```

---

## 4. RocketMQ事务消息原理？

**题目：**
RocketMQ事务消息原理是什么？

**答案：**
**事务消息流程：**
```
┌─────────────────────────────────────────────────────────────┐
│                  RocketMQ事务消息流程                        │
│                                                             │
│  Producer → 半消息 → 本地事务 → 提交/回滚 → 消息投递        │
└─────────────────────────────────────────────────────────────┘
```

**详细流程：**
```
1. Producer发送半消息（Half Message）
   - 消息状态：Prepared
   - 消费者不可见

2. 执行本地事务
   - 创建订单、扣减库存
   - 成功返回COMMIT
   - 失败返回ROLLBACK
   - 超时返回UNKNOWN（由事务回查决定）

3. 事务回查
   - Broker检查超时未决消息
   - 回调Producer询问事务状态
   - Producer检查本地事务状态
   - 返回COMMIT/ROLLBACK

4. 消息投递
   - COMMIT：消息变为可消费
   - ROLLBACK：消息删除
```

**代码实现：**
```java
// 1. 实现TransactionListener
public class OrderTransactionListener 
    implements TransactionListener {
    
    public LocalTransactionState executeLocalTransaction(
        Message msg, Object arg) {
        
        String orderId = msg.getUserProperty("orderId");
        
        try {
            // 1. 创建订单
            orderService.createOrder(orderId);
            // 2. 扣减库存
            stockService.decrease(orderId);
            
            return LocalTransactionState.COMMIT_MESSAGE;
        } catch (Exception e) {
            return LocalTransactionState.ROLLBACK_MESSAGE;
        }
    }
    
    public LocalTransactionState checkLocalTransaction(
        MessageExt msg) {
        
        String orderId = msg.getUserProperty("orderId");
        
        if (orderService.checkOrder(orderId)) {
            return LocalTransactionState.COMMIT_MESSAGE;
        }
        return LocalTransactionState.ROLLBACK_MESSAGE;
    }
}

// 2. 使用事务生产者
TransactionMQProducer producer = new TransactionMQProducer();
producer.setTransactionListener(
    new OrderTransactionListener());

producer.send(new Message("OrderTopic", "body".getBytes()));
```

---

## 5. RocketMQ消息积压处理？

**题目：**
RocketMQ消息积压怎么办？

**答案：**
**积压原因：**
- 消费者处理能力不足
- 消费者实例不足
- 消息发送过快

**解决方案：**

**1. 增加消费者实例**
```java
// 扩容消费者
// 最多等于队列数
```

**2. 并行消费**
```java
consumer.registerMessageListener(
    new MessageListenerConcurrently() {
        public ConsumeConcurrentlyStatus consumeMessage(
            List<MessageExt> msgs,
            ConsumeConcurrentlyContext context) {
            
            // 并行处理
            msgs.parallelStream().forEach(msg -> {
                process(msg);
            });
            
            return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;
        }
    }
);
```

**3. 批量消费**
```java
// 配置
props.put("ConsumeMessageBatchMaxSize", 32);
```

**4. 扩容队列**
```bash
mqadmin updateTopic -n localhost:9876 -t TopicName -c DefaultCluster -q 16
```

**5. 临时扩容方案：消息丢弃**
```java
// 紧急情况，丢弃消息
if (isUrgent) {
    return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;
}
```

**6. 监控积压**
```bash
# 查看消费积压
mqadmin consumerProgress -n localhost:9876 -g groupName
```

---

## 6. RocketMQ高可用架构？

**题目：**
RocketMQ如何保证高可用？

**答案：**
**高可用架构：**
```
Master/Slave架构：
同一Broker组：
- Master：读写
- Slave：只读（HA同步）

NameServer集群：
- 去中心化
- 任何节点都可注册
```

**主从同步：**
```bash
# Master配置
brokerRole=SYNC_MASTER
flushDiskType=ASYNC_FLUSH

# Slave配置
brokerRole=SLAVE
```

**故障切换：**
```
1. Master故障
2. NameServer感知
3. 消费者切换到Slave
4. 生产者切换到Slave
5. Master恢复后变为Slave
```

**部署架构：**
```
┌─────────────────────────────────────────────────────────┐
│                    NameServer集群                        │
│         Node1 ←→ Node2 ←→ Node3（去中心化）             │
└─────────────────────────────────────────────────────────┘
                         ↑
┌─────────────────────────────────────────────────────────┐
│                 Broker集群（多主多从）                    │
│                                                         │
│  BrokerGroup-1          BrokerGroup-2                   │
│  ├── Master-A           ├── Master-B                   │
│  └── Slave-A            └── Slave-B                    │
│                                                         │
│  Group之间相互独立                                        │
└─────────────────────────────────────────────────────────┘
```

---

*更多RocketMQ面试题答案*
