# 系统设计 面试题

## 题目
## 2. 如何设计一个短链接系统？
## 3. 如何设计一个分布式ID生成器？
## 4. 如何设计一个消息推送系统？
## 5. 如何设计一个评论系统？
## 6. 如何设计一个搜索建议系统？
## 7. 如何设计一个日志收集系统？
## 8. 分库分表后如何查询分页？
## 9. 如何保证缓存与数据库一致性？
## 10. 如何设计高并发架构？

更多题目请查看答案文件

## 答案

**题目：**
请设计一个秒杀系统？

**答案：**
**秒杀系统架构：**
```
┌─────────────────────────────────────────────────────────────────┐
│                        用户请求                                  │
└─────────────────────────────┬───────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────────┐
│                      Nginx（负载均衡）                           │
│                    限流 + 静态资源                                │
└─────────────────────────────┬───────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────────┐
│                     Gateway（API网关）                           │
│                 限流 + 认证 + 路由                                │
└─────────────────────────────┬───────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────────┐
│                    秒杀服务（多实例部署）                         │
│    ┌─────────┐  ┌─────────┐  ┌─────────┐  ┌─────────┐          │
│    │ 实例1   │  │ 实例2   │  │ 实例3   │  │ 实例4   │          │
│    └────┬────┘  └────┬────┘  └────┬────┘  └────┬────┘          │
└─────────┼────────────┼────────────┼────────────┼────────────────┘
          │            │            │            │
          └────────────┴─────┬──────┴────────────┘
                             ↓
┌─────────────────────────────────────────────────────────────────┐
│                      Redis集群（限流+库存）                       │
└─────────────────────────────┬───────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────────┐
│                     Kafka（异步下单）                            │
└─────────────────────────────┬───────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────────┐
│                      订单服务（入库）                             │
└─────────────────────────────────────────────────────────────────┘
```

**核心功能：**

**1. 库存预扣减（Redis）：**
```java
public boolean preDeductStock(Long productId, Integer count) {
    String key = "stock:" + productId;
    Long result = redisTemplate.opsForValue().decrement(key, count);
    return result != null && result >= 0;
}
```

**2. 限流：**
```java
// 令牌桶
RateLimiter rateLimiter = RateLimiter.create(100);

if (!rateLimiter.tryAcquire()) {
    return Result.error("系统繁忙");
}
```

**3. 幂等性：**
```java
String lockKey = "seckill:lock:" + userId + "_" + productId;
boolean locked = redisTemplate.opsForValue()
    .setIfAbsent(lockKey, "1", 10, TimeUnit.SECONDS);

if (!locked) {
    return Result.error("请勿重复提交");
}
```

**4. 库存超卖：**
```java
// 正确写法
int rows = stockMapper.decreaseStock(productId, 1);
if (rows == 0) {
    throw new BusinessException("库存不足");
}
```

**5. 数据一致性：**
```
Cache Aside模式：
- 读取：先缓存 → 缓存没有查DB → 写缓存
- 更新：先删缓存 → 再更新DB
```

---

## 2. 如何设计一个短链接系统？

**题目：**
请设计一个短链接系统？

**答案：**
**短链接系统架构：**
```
┌─────────────────────────────────────────────────────────┐
│                    短链接系统                            │
├─────────────────────────────────────────────────────────┤
│  生成短码 → 存储映射 → 302跳转                          │
└─────────────────────────────────────────────────────────┘
```

**短码生成：**
```java
// 62进制编码
private static final String CHARS = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

public String encode(long id) {
    StringBuilder sb = new StringBuilder();
    while (id > 0) {
        int index = (int) (id % 62);
        sb.append(CHARS.charAt(index));
        id /= 62;
    }
    return sb.reverse().toString();
}

public long decode(String shortCode) {
    long id = 0;
    for (char c : shortCode.toCharArray()) {
        id = id * 62 + CHARS.indexOf(c);
    }
    return id;
}
```

**存储设计：**
```
短链接表：
- id (bigint, PK)
- short_code (varchar(10), unique)
- original_url (text)
- expire_time (datetime)
- created_at (datetime)
```

**跳转流程：**
```
1. 接收短链接请求
2. 查询短码对应的长链接
3. 302重定向到长链接
4. 记录访问日志
```

**高可用：**
- Redis缓存热点数据
- 数据库主从复制
- 短码预生成（避免ID竞争）

---

## 3. 如何设计一个分布式ID生成器？

**题目：**
如何设计一个分布式ID生成器？

**答案：**
**方案对比：**

| 方案 | 优点 | 缺点 | 适用场景 |
|------|------|------|----------|
| UUID | 本地生成，无网络开销 | 无序，长度大 | 日志追踪 |
| 数据库自增 | 简单，有序 | 单点瓶颈 | 小规模系统 |
| 雪花算法 | 有序，性能高 | 时钟依赖 | 通用场景 |
| 号段模式 | 高性能 | 可能跳号 | 高并发系统 |

**雪花算法实现：**
```java
public class SnowflakeIdWorker {
    private long sequence = 0L;
    private long lastTimestamp = -1L;
    private final long workerId;
    private final long datacenterId;
    
    public SnowflakeIdWorker(long workerId, long datacenterId) {
        this.workerId = workerId;
        this.datacenterId = datacenterId;
    }
    
    public synchronized long nextId() {
        long timestamp = System.currentTimeMillis();
        
        if (timestamp < lastTimestamp) {
            throw new RuntimeException("时钟回拨");
        }
        
        if (timestamp == lastTimestamp) {
            sequence = (sequence + 1) & 4095;
            if (sequence == 0) {
                // 等待下一毫秒
                while (timestamp == lastTimestamp) {
                    timestamp = System.currentTimeMillis();
                }
            }
        } else {
            sequence = 0L;
        }
        
        lastTimestamp = timestamp;
        
        return (timestamp - 1288834974657L) << 22
             | (datacenterId & 31) << 17
             | (workerId & 31) << 12
             | sequence;
    }
}
```

**号段模式：**
```java
// 获取号段
Segment segment = segmentService.nextSegment("order");
long start = segment.getStart();
long end = segment.getEnd();

// 本地缓存号段
AtomicLong current = new AtomicLong(start);
while (current.incrementAndGet() <= end) {
    // 生成ID
}
```

---

## 4. 如何设计一个消息推送系统？

**题目：**
如何设计一个消息推送系统？

**答案：**
**消息推送架构：**
```
┌─────────────────────────────────────────────────────────┐
│                   消息推送系统                           │
├─────────────────────────────────────────────────────────┤
│  ┌──────────┐  ┌──────────┐  ┌──────────┐             │
│  │ 消息网关  │  │ 推送服务  │  │ 离线存储  │             │
│  └────┬─────┘  └────┬─────┘  └────┬─────┘             │
│       │             │             │                     │
│       └─────────────┼─────────────┘                     │
│                     ↓                                    │
│              ┌──────────────┐                           │
│              │  长连接通道   │                           │
│              │ (WebSocket)  │                           │
│              └──────────────┘                           │
└─────────────────────────────────────────────────────────┘
```

**核心组件：**

**1. 长连接管理：**
```java
// WebSocket连接
@ServerEndpoint("/ws/push/{userId}")
public class PushEndpoint {
    
    private static Map<String, Session> connections = 
        new ConcurrentHashMap<>();
    
    @OnOpen
    public void onOpen(@PathParam("userId") String userId) {
        connections.put(userId, session);
    }
    
    @OnMessage
    public void onMessage(String message) {
        // 接收消息
    }
    
    @OnClose
    public void onClose(@PathParam("userId") String userId) {
        connections.remove(userId);
    }
}
```

**2. 消息推送：**
```java
public void push(String userId, Message message) {
    Session session = connections.get(userId);
    if (session != null && session.isOpen()) {
        session.getAsyncRemote().sendText(JSON.toJSONString(message));
    } else {
        // 离线存储
        offlineStorage.save(userId, message);
    }
}
```

**3. 消息路由：**
```java
// 基于Topic
topic: user_123
topic: broadcast

// 基于标签
userTags: ["vip", "online"]
```

**离线消息：**
```
存储：Redis Sorted Set
按时间排序
用户上线后拉取未读消息
```

---

## 5. 如何设计一个评论系统？

**题目：**
如何设计一个评论系统？

**答案：**
**评论系统架构：**
```
┌─────────────────────────────────────────────────────────┐
│                   评论系统                               │
├─────────────────────────────────────────────────────────┤
│  评论模型：主评论 + 子评论（回复）                        │
│                                                         │
│  Table: comment                                         │
│  - id (bigint)                                          │
│  - article_id (bigint)      // 关联文章                  │
│  - parent_id (bigint)       // 父评论ID                 │
│  - user_id (bigint)         // 评论用户                 │
│  - content (text)           // 评论内容                 │
│  - like_count (int)         // 点赞数                   │
│  - created_at (datetime)    // 创建时间                 │
└─────────────────────────────────────────────────────────┘
```

**查询优化：**

**1. 评论列表：**
```sql
-- 分页查询主评论
SELECT * FROM comment 
WHERE article_id = ? AND parent_id = 0 
ORDER BY created_at DESC 
LIMIT ?, ?

-- 查询子评论
SELECT * FROM comment 
WHERE parent_id = ? 
ORDER BY created_at ASC
```

**2. 点赞：**
```java
// Redis缓存点赞
String key = "comment:like:" + commentId;
redisTemplate.opsForSet().add(key, userId);
redisTemplate.opsForValue().increment("comment:like:count:" + commentId);
```

**3. 排序策略：**
```
按时间排序：时间倒序
按热度排序：like_count + 回复数
```

**性能优化：**
```
1. 评论分页加载（懒加载）
2. 点赞异步化
3. CDN缓存静态评论
4. ES支持搜索
```

---

## 6. 如何设计一个搜索建议系统？

**题目：**
如何设计一个搜索建议系统？

**答案：**
**搜索建议架构：**
```
┌─────────────────────────────────────────────────────────┐
│                   搜索建议系统                           │
├─────────────────────────────────────────────────────────┤
│  数据源 → 预处理 → 索引 → 查询服务                       │
│                                                         │
│  1. 热门搜索                                             │
│  2. 补全建议                                             │
│  3. 相关搜索                                             │
└─────────────────────────────────────────────────────────┘
```

**实现方案：**

**1. Trie树（前缀树）：**
```java
class TrieNode {
    Map<Character, TrieNode> children = new HashMap<>();
    boolean isEnd;
    List<String> hotWords = new ArrayList<>();
}

class Trie {
    private TrieNode root = new TrieNode();
    
    public void insert(String word) {
        // 插入词条，统计热度
    }
    
    public List<String> search(String prefix) {
        // 前缀匹配，返回建议
    }
}
```

**2. Elasticsearch：**
```json
{
  "suggest": {
    "word_suggest": {
      "prefix": "java",
      "completion": {
        "field": "suggest",
        "size": 10,
        "skip_duplicates": true
      }
    }
  }
}
```

**3. Redis缓存：**
```
热门搜索：ZSet（按热度排序）
前缀建议：Hash（key: prefix, value: suggestions）
```

**实时性处理：**
```
1. 用户搜索后，更新热门度
2. 新词自动加入索引
3. 定期重建索引
```

---

## 7. 如何设计一个日志收集系统？

**题目：**
如何设计一个日志收集系统？

**答案：**
**日志收集架构：**
```
┌─────────────────────────────────────────────────────────┐
│                   日志收集系统                           │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  应用日志 → Filebeat → Kafka → Logstash → ES → Kibana  │
│                                                         │
│  或者：                                                  │
│  应用日志 → Flume → Kafka → Flink → ES → Kibana        │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

**组件说明：**

**1. 日志采集（Filebeat）：**
```yaml
filebeat.inputs:
  - type: log
    enabled: true
    paths:
      - /var/log/*.log
    multiline:
      pattern: '^\d{4}-\d{2}-\d{2}'
      negate: true
      match: after

output.kafka:
  hosts: ["kafka:9092"]
  topic: "app-logs"
```

**2. 消息缓冲（Kafka）：**
```
Topic设计：
- app-logs（原始日志）
- app-logs-error（错误日志）
- app-logs-access（访问日志）

消费组：logstash-consumer
```

**3. 日志处理（Logstash/Flink）：**
```
1. 日志解析（JSON、Grok）
2. 字段提取
3. 数据转换
4. 异常检测
5. 聚合统计
```

**4. 存储查询（ES）：**
```
Index设计：
- 按日期分索引（app-logs-2025.01.01）
- 按天/周/月滚动
- 7天热数据，7天以上归档
```

**5. 可视化（Kibana）：**
```
1. 日志搜索
2. 仪表盘
3. 告警规则
4. 时序分析
```

---

## 8. 分库分表后如何查询分页？

**题目：**
分库分表后如何查询分页？

**答案：**
**分页查询方案：**

**1. 业务限制：**
```
只允许查询前1000条
不支持跨页跳转
```

**2. 多次查询：**
```java
// 并行查询所有分片
List<List<Article>> results = new ArrayList<>();
for (ShardingContext context : shardingContexts) {
    List<Article> shardResults = 
        queryFromShard(context, page, size);
    results.add(shardResults);
}

// 内存排序
List<Article> finalResults = results.stream()
    .flatMap(List::stream)
    .sorted(Comparator.comparing(Article::getCreatedAt))
    .skip((page - 1) * size)
    .limit(size)
    .collect(Collectors.toList());
```

**3. 二次查询：**
```
1. 查询所有分片获取ID
2. 内存排序取前N个ID
3. 根据ID查询详细信息
```

**4. ES辅助查询：**
```
1. 写入数据到ES
2. ES负责分页查询
3. MySQL存储原始数据
```

**5. 游标分页：**
```
使用lastId代替页码
每次查询比lastId大的数据
只支持顺序翻页
```

---

## 9. 如何保证缓存与数据库一致性？

**题目：**
如何保证缓存与数据库一致性？

**答案：**
**缓存策略：**

**1. Cache Aside（常用）：**
```
读取：
1. 先查缓存
2. 缓存没有查DB
3. 写入缓存

更新：
1. 先删缓存
2. 再更新DB

问题：并发时可能不一致
解决：延迟双删
```

**2. 延迟双删：**
```java
public void updateUser(User user) {
    // 1. 删除缓存
    redisTemplate.delete("user:" + user.getId());
    
    // 2. 更新DB
    userMapper.update(user);
    
    // 3. 延迟删除（500ms）
    try {
        Thread.sleep(500);
    } catch (InterruptedException e) {
        Thread.currentThread().interrupt();
    }
    redisTemplate.delete("user:" + user.getId());
}
```

**3. Write Through：**
```
写入时同时写缓存和DB
保证强一致
性能较低
```

**4. Read Through：**
```
读取时自动加载缓存
对业务透明
需要Cache Provider支持
```

**数据一致性保障：**
```
1. 合理设置过期时间
2. 监控缓存命中率
3. 异常时降级处理
4. 定期数据修复
```

---

## 10. 如何设计高并发架构？

**题目：**
如何设计高并发架构？

**答案：**
**高并发架构原则：**

**1. 横向扩展：**
```
增加机器节点
负载均衡分发
```

**2. 异步解耦：**
```
消息队列削峰
异步处理非核心流程
```

**3. 缓存为王：**
```
多级缓存架构
热点数据预加载
```

**4. 限流降级：**
```
保护系统不被压垮
优雅降级非核心功能
```

**架构示例：**
```
用户请求
    ↓
CDN（静态资源）
    ↓
Nginx集群（负载均衡、限流）
    ↓
Gateway（路由、认证、限流）
    ↓
服务集群（多实例）
    ↓
┌──────────┬──────────┬──────────┐
│ 缓存集群  │ 消息队列  │ 存储集群  │
│ Redis    │ Kafka    │ MySQL    │
│ 主从+分片│ 多副本    │ 主从+分片│
└──────────┴──────────┴──────────┘
    ↓
ES（搜索、日志）
```

**核心组件：**
```
1. 负载均衡：Nginx、LVS
2. 限流：Sentinel、Redis+Lua
3. 缓存：Redis Cluster
4. 消息：Kafka、RocketMQ
5. 存储：MySQL主从、ES
6. 监控：Prometheus+Grafana
7. 链路追踪：SkyWalking
```

---

*更多系统设计面试题答案*

---

## P8 级系统设计题

### 短链接系统设计

**题目：**
请设计一个支持每秒 100 万 QPS 的短链接生成系统，要求：
- 短链接长度为 6-8 位
- 支持高并发写入和读取
- 保证 99.99% 的可用性
- 支持缓存预热和热点数据处理
- 数据持久化和灾备方案

**答案：**

**整体架构：**
```
用户请求 → CDN → 负载均衡 → API 网关 → 业务服务集群 → Redis 集群 + MySQL 分库分表
```

**核心设计要点：**

1. **短链接生成算法**
   - 方案一：分布式 ID 生成器（雪花算法 + 62 进制编码）
   - 方案二：预生成号段 + 本地缓存
   - 容量：6 位 = 62^6 ≈ 568 亿，8 位 = 218 万亿

2. **高并发读取优化**
   - 多级缓存：本地缓存（Caffeine/Guava）→ Redis 集群 → MySQL
   - Redis 集群：采用 CRC16 分片，支持 1000 万 QPS
   - 数据预热：热点数据提前加载到缓存
   - 布隆过滤器：过滤不存在的短链接，减少 Redis 请求

3. **高并发写入优化**
   - 异步写入：先写 Redis → 批量同步到 MySQL
   - 消息队列：Kafka 处理写入请求，削峰填谷
   - 号段模式：每个节点预分配号段，减少锁竞争

4. **数据分片**
   - MySQL 分库分表：按短链接 hash 分片
   - 路由层：一致性哈希或范围分片
   - 读写分离：主库写入，从库读取

5. **高可用设计**
   - 多机房部署：主备机房
   - 容灾：数据多副本（3 副本）
   - 熔断降级：Hystrix/Sentinel
   - 健康检查：心跳检测，自动剔除故障节点

---

### 分布式 ID 生成器

**题目：**
设计一个高性能、高可用的分布式 ID 生成器，支持每秒生成 100 万个 ID，要求：
- 全局唯一
- 趋势递增（方便索引）
- 可反解（包含时间戳、机器号等信息）
- 支持水平扩展

**答案：**

**雪花算法（Snowflake）：**
```
64 位二进制结构：
| 符号位(1) | 时间戳(41) | 机器 ID(10) | 序列号(12) |
|-----------|-----------|-------------|------------|
| 0         | 41 位     | 10 位       | 12 位      |
```

**优点：**
- 高性能：单机每秒可生成约 400 万个 ID
- 趋势递增
- 可反解（时间戳、机器 ID、序列号）

**问题与解决：**
- **时钟回拨**：使用历史最大时间戳
- **机器 ID 分配**：ZooKeeper / etcd / 数据库分配

**号段模式：**
- 每个节点预分配号段
- 简单可靠，适合大数据量场景

---

### 百万用户 IM 系统设计

**题目：**
设计一个支持百万级用户的即时通讯系统（IM），要求：
- 实时性：消息延迟 < 100ms
- 高可用：99.99%
- 支持单聊、群聊
- 消息必达

**答案：**

**整体架构：**
```
Client → Gateway Server → Message Server → Redis（在线状态） + MQ + DB
```

**单聊消息流程：**
1. A → Gateway1
2. Gateway1 → Message Server
3. Message Server → 检查 B 在线状态（Redis）
4. 在线：推送到 B 连接的 Gateway
5. 离线：存储到离线消息库
6. B 上线后拉取离线消息

**核心要点：**
- 在线状态管理（Redis Hash/Set）
- 群聊消息推送
- 心跳保活
- 消息可靠性（ACK、去重）
- 水平扩展方案

---

### 高并发秒杀系统设计

**题目：**
设计一个秒杀系统，要求：
- 高并发：10 万 QPS
- 库存超卖率为 0
- 99.99% 可用性
- 防刷防爬

**答案：**

**核心架构：**
```
用户 → CDN → 负载均衡 → 秒杀服务集群 → Redis 集群 + MQ + MySQL
```

**关键技术：**
1. **流量削峰**：令牌桶、请求队列、验证码
2. **库存扣减**：Redis 原子扣减，防止超卖
3. **异步下单**：MQ 异步处理，提升性能
4. **防刷策略**：单用户限流、IP 限流、设备指纹
5. **高可用**：多机房部署、熔断降级

**Redis 原子扣减脚本：**
```lua
local stock = redis.call('GET', KEYS[1])
if stock and tonumber(stock) > 0 then
    redis.call('DECR', KEYS[1])
    return 1
else
    return 0
end
```
