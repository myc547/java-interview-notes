# JVM面试题

## 1. JVM内存模型？

**题目：**
请描述JVM的内存模型？

**答案：**
**JVM内存结构：**
```
┌─────────────────────────────────────────────────────────────┐
│                        JVM Memory                            │
├─────────────────────────────────────────────────────────────┤
│  ┌─────────────────────────────────────────────────────────┐│
│  │                    Heap Memory                          ││
│  │  ┌─────────────────┐  ┌─────────────────────────────┐  ││
│  │  │   Young Gen     │  │        Old Gen              │  ││
│  │  │  ┌────┐ ┌────┐ │  │                             │  ││
│  │  │  │Eden│ │S0/S1│ │  │                             │  ││
│  │  │  └────┘ └────┘ │  │                             │  ││
│  │  └─────────────────┘  └─────────────────────────────┘  ││
│  └─────────────────────────────────────────────────────────┘│
│                                                             │
│  ┌─────────────────────────────────────────────────────────┐│
│  │                   Non-Heap Memory                       ││
│  │  ┌─────────────┐ ┌─────────────┐ ┌─────────────────┐   ││
│  │  │ Metaspace   │ │   Code Cache │ │  Thread Stacks  │   ││
│  │  │ (类元数据)   │ │ (JIT编译)    │ │  (每个线程栈)   │   ││
│  │  └─────────────┘ └─────────────┘ └─────────────────┘   ││
│  └─────────────────────────────────────────────────────────┘│
└─────────────────────────────────────────────────────────────┘
```

**各区域说明：**
- **堆（Heap）**：对象分配，GC主要区域
  - Young Gen：Eden + Survivor(S0/S1)
  - Old Gen：老年代对象
- **方法区（Metaspace）**：类信息、常量、静态变量
- **虚拟机栈（VM Stack）**：线程栈，存储局部变量
- **本地方法栈（Native Stack）**：Native方法调用
- **程序计数器（PC Register）**：当前线程执行地址
- **直接内存（Direct Memory）**：NIO使用的堆外内存

---

## 2. 类加载过程？

**题目：**
类的加载过程是什么？每一步做了什么？

**答案：**
**类加载5个阶段：**
```
加载 → 验证 → 准备 → 解析 → 初始化
```

**1. 加载（Loading）**
- 通过类的全限定名获取类的二进制字节流
- 将字节流转化为方法区的运行时数据结构
- 在堆中生成java.lang.Class对象

**2. 验证（Verification）**
- 文件格式验证（魔数、版本号等）
- 元数据验证（语义检查）
- 字节码验证（数据流、控制流分析）
- 符号引用验证

**3. 准备（Preparation）**
- 为类变量分配内存
- 设置初始值（零值）
- 不包含实例变量

**4. 解析（Resolution）**
- 将符号引用转换为直接引用
- 类或接口解析
- 字段解析
- 方法解析

**5. 初始化（Initialization）**
- 执行<clinit>方法
- 静态变量赋值
- 静态代码块执行
- 线程安全（只执行一次）

---

## 3. 双亲委派模型？

**题目：**
什么是双亲委派模型？

**答案：**
**定义：**
类加载器收到加载请求时，优先委派给父加载器处理。

**类加载器层次：**
```
 Bootstrap ClassLoader（C++实现）
        ↑
  Extension ClassLoader
        ↑
 Application ClassLoader
        ↑
   Custom ClassLoader（用户自定义）
```

**加载流程：**
```
1. Application → Extension → Bootstrap
2. Bootstrap找不到，Extension去找
3. Extension找不到，Application去找
4. 都找不到，自己加载
```

**好处：**
- 保证类加载的安全性
- 防止重复加载（如java.lang.Object）
- 保证JDK核心类的唯一性

**打破双亲委派：**
- JDBC DriverManager
- Spring破坏（热部署）
- 自定义类加载器重写loadClass()

---

## 4. 常见GC算法？

**题目：**
常见的垃圾回收算法有哪些？

**答案：**
**1. 标记-清除（Mark-Sweep）**
```
步骤：标记所有存活对象 → 清除死亡对象
缺点：产生碎片
```

**2. 标记-整理（Mark-Compact）**
```
步骤：标记 → 整理（移动存活对象） → 清除
优点：无碎片
缺点：需要移动对象，开销大
```

**3. 复制（Copying）**
```
步骤：将内存分为两块，只用一块
      GC时复制存活对象到另一块
优点：无碎片，简单高效
缺点：可用内存减半
```

**4. 分代收集（Generational Collection）**
```
Young Gen：复制算法（对象存活率低）
Old Gen：标记-整理/标记-清除
```

**各算法对比：**
| 算法 | 优点 | 缺点 |
|------|------|------|
| 标记-清除 | 不移动对象 | 产生碎片 |
| 标记-整理 | 无碎片 | 需要移动 |
| 复制 | 高效无碎片 | 内存减半 |

---

## 5. CMS和G1的区别？

**题目：**
CMS和G1垃圾回收器有什么区别？

**答案：**
**CMS（Concurrent Mark Sweep）**
- 目标：最短回收停顿时间
- 适合：互联网应用
- 基于标记-清除算法

**G1（Garbage First）**
- 目标：可控停顿时间+高吞吐
- 适合：大内存、多核
- 基于Region的复制算法

**对比：**
| 特性 | CMS | G1 |
|------|-----|-----|
| **算法** | 标记-清除 | 复制（Region） |
| **停顿时间** | STW较长 | 可预测 |
| **碎片问题** | 有碎片 | 无碎片 |
| **内存布局** | 连续 | Region划分 |
| **适用场景** | 中小堆 | 大堆(>6GB) |

**CMS回收过程：**
```
1. 初始标记（STW）→ GC Roots直接引用
2. 并发标记 → 并发遍历对象图
3. 重新标记（STW）→ 修正变动
4. 并发清除 → 并发清除死亡对象
```

**G1回收过程：**
```
1. Young GC → 收集年轻代Region
2. 并发标记周期 → 标记所有Region
3. 混合回收 → 收集年轻代+部分老年代
4. Full GC → 兜底（串行/并行）
```

---

## 6. 对象分配与引用计数？

**题目：**
对象是如何分配的？引用计数法是什么？

**答案：**
**对象分配流程：**
```
1. 检查eden区是否有足够空间
   ├─ 有：分配对象
   └─ 没有：触发Minor GC
   
2. Minor GC后
   ├─ 对象进入Survivor区
   ├─ 对象年龄+1
   └─ 年龄达到阈值（默认15）→ 进入老年代
   
3. 大对象直接进入老年代
```

**引用计数法：**
```java
// 每个对象有一个引用计数器
// 引用+1，引用失效-1
// 计数器为0时回收

Object obj = new Object();  // 计数=1
obj = null;                  // 计数=0，回收
```

**引用计数优缺点：**
- ✅ 简单高效
- ❌ 无法处理循环引用
- ❌ 维护计数有开销

**可达性分析（根搜索）：**
```
GC Roots包括：
- 虚拟机栈引用对象
- 方法区静态引用对象
- 方法区常量引用对象
- Native方法引用对象
- 活跃线程引用对象

从GC Roots向下搜索，不可达的对象回收
```

---

## 7. JVM调优参数？

**题目：**
常用的JVM调优参数有哪些？

**答案：**
**堆内存配置：**
```bash
-Xms2g                  # 初始堆大小
-Xmx2g                  # 最大堆大小
-Xmn512m                # 年轻代大小
-XX:NewRatio=2          # 老年代/年轻代比例
-XX:SurvivorRatio=8     # Eden/Survivor比例
```

**元空间配置：**
```bash
-XX:MetaspaceSize=256m  # 初始元空间
-XX:MaxMetaspaceSize=512m  # 最大元空间
```

**GC配置：**
```bash
-XX:+UseG1GC            # 使用G1垃圾回收器
-XX:MaxGCPauseMillis=200  # 最大GC停顿时间
-XX:G1HeapRegionSize=16m  # G1 Region大小
```

**日志配置：**
```bash
-XX:+PrintGCDetails     # 打印详细GC日志
-XX:+PrintGCDateStamps  # 打印GC时间戳
-Xlog:gc*:file=gc.log:time  # 日志输出到文件
```

**OOM配置：**
```bash
-XX:+HeapDumpOnOutOfMemoryError
-XX:HeapDumpPath=/tmp/heapdump.hprof
```

---

## 8. 线上问题排查流程？

**题目：**
线上JVM问题如何排查？

**答案：**
**1. 查看进程状态**
```bash
jps -l                        # 列出Java进程
top -H -p <pid>              # 查看线程CPU占用
```

**2. 导出线程堆栈**
```bash
jstack <pid> > thread.log    # 线程堆栈
jstack <pid> | grep -A 10 "deadlock"  # 检查死锁
```

**3. 导出堆转储**
```bash
jmap -dump:format=b,file=heap.hprof <pid>
```

**4. 分析堆内存**
```bash
jmap -heap <pid>             # 堆内存使用情况
jmap -histo <pid>            # 对象统计
```

**5. 分析GC日志**
```bash
grep -E "GC|Full GC" gc.log  # 查看GC频率
```

**6. 常用分析工具**
- **jconsole**：JMX可视化工具
- **jvisualvm**：监控和分析工具
- **MAT**：堆转储分析
- **GCViewer**：GC日志分析

---

## 9. OOM有几种类型？

**题目：**
JVM OOM有哪几种类型？分别是什么原因？

**答案：**
**1. Java heap space**
```
原因：对象过多、内存泄漏、堆设置过小
解决：增加堆大小、检查对象泄漏
```

**2. Metaspace**
```
原因：类加载过多、类加载器泄漏
解决：增加Metaspace、检查动态代理
```

**3. GC overhead limit exceeded**
```
原因：频繁GC但回收很少
解决：优化代码、调整GC参数
```

**4. Unable to create new native thread**
```
原因：线程数过多
解决：减少线程数、增大栈大小
```

**5. Direct buffer memory**
```
原因：NIO直接内存溢出
解决：减少DirectMemory大小
```

---

## 10. 对象头包含什么？

**题目：**
Java对象头包含哪些内容？

**答案：**
**32位JVM对象头：**
```
┌─────────────────────────────────────┐
│       Mark Word (32 bits)           │
├─────────────────────────────────────┤
│  锁状态标志 | 哈希码 | 分代年龄      │
└─────────────────────────────────────┘
```

**64位JVM对象头：**
```
┌──────────────────────────────────────────────────────────────────┐
│                     Mark Word (64 bits)                          │
├──────────────────────────────────────────────────────────────────┤
│ 锁状态(25位) | 哈希码(31位) | 分代年龄(4位) | 偏向锁标识(1位) | 锁标志(2位) │
└──────────────────────────────────────────────────────────────────┘
```

**对象头包含：**
- **Mark Word**：锁状态、GC年龄、哈希码
- **Klass Pointer**：指向类元数据的指针
- **数组长度**：如果是数组对象

**对齐填充：**
- 对象大小对齐到8字节
- 填充字节不存储数据

---

*更多JVM面试题请查看答案文件*
