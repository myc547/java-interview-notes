# JVM 高级面试题

## 1. G1 垃圾收集器原理？

**题目：**
请详细说明 G1 垃圾收集器的原理和特点。

**答案：**
**G1 概述：**
G1（Garbage First）是 JDK 9+ 默认垃圾收集器，面向服务端应用，停顿时间可控。

**Region 内存布局：**
堆内存被划分为多个 1MB~32MB 的 Region：
- Eden Region：新对象分配区域
- Survivor Region：存活对象复制区域
- Old Region：老年代对象
- Humongous Region：大对象区域（> 50% Region）
- Free Region：空闲区域

**G1 收集过程：**
1. **Young GC**：复制 Eden → Survivor，晋升 Survivor → Old
2. **Mixed GC**：收集所有年轻代 Region + 部分老年代 Region
3. **Full GC**：串行/并行 Full GC（当 Mixed GC 跟不上时）

**Card Table 和 RSet：**
- Card Table：每个 Card 512KB，记录跨 Region 引用
- Remembered Set (RSet)：每个 Region 维护一个 RSet，记录其他 Region 对当前 Region 的引用，用于快速定位跨代引用

**G1 回收流程：**
1. **初始标记**：标记 GC Roots 直接引用的对象（STW）
2. **并发标记**：遍历对象图，标记所有存活对象（并发）
3. **重新标记**：修正并发标记期间的变更（STW）
4. **筛选回收**：计算每个 Region 的回收价值，优先回收价值高的
5. **回收**：并行复制存活对象到新 Region（STW）

**G1 参数调优：**
```bash
-XX:MaxGCPauseMillis=200  # 停顿时间目标
-XX:G1HeapRegionSize=16m  # Region 大小
-XX:InitiatingHeapOccupancyPercent=45  # 触发 Mixed GC 阈值
```

---

## 2. ZGC 垃圾收集器原理？

**题目：**
请详细说明 ZGC 的原理和特点。

**答案：**
**ZGC 概述：**
ZGC（JDK 11+）是低延迟垃圾收集器，停顿时间 < 10ms，支持 TB 级堆内存。

**着色指针（Colored Pointers）：**
64 位指针使用 42 位寻址，包含：
- **Marked0 / Marked1**：标记位（标记对象是否存活）
- **Remapped**：重定位位（对象是否已被移动）
- **Finalizable**：终结位（对象是否需要终结处理）

**ZGC 阶段：**
1. **Pause Mark Start**：初始标记，标记 GC Roots（STW）
2. **Concurrent Mark**：并发标记，遍历对象图（并发）
3. **Pause Mark End**：重新标记，修正变更（STW）
4. **Concurrent Process Non-Strong References**：并发处理弱引用
5. **Concurrent Relocate**：并发重定位，移动存活对象
6. **Concurrent Uncommit**：回收重定位集，释放空 Region

**读屏障（Load Barrier）：**
每次读取对象时检查指针颜色，开销约 3-5%，但极大减少了 STW 时间。

**ZGC vs G1：**
| 指标 | G1 | ZGC |
|------|-----|-----|
| 适用场景 | 中小堆（<64GB） | 大堆（>64GB） |
| 停顿时间 | 100-500ms | < 10ms |
| 吞吐量 | 高 | 较高 |
| 读屏障 | 无 | 有 |

---

## 3. JVM 逃逸分析？

**题目：**
请详细说明 JVM 的逃逸分析及其优化效果。

**答案：**
**逃逸分析概述：**
逃逸分析是 JIT 编译器的优化技术，分析对象的动态作用域，判断是否会逃逸出当前线程。

**逃逸类型：**
- **方法逃逸**：对象在方法外部可见
- **线程逃逸**：对象在多个线程间共享

**优化效果：**

1. **栈上分配**：对象分配在栈上，方法结束自动回收，无需 GC
2. **标量替换**：将对象拆解为其成员变量，直接使用标量
3. **锁消除**：消除不必要的同步锁

**示例：**
```java
// 栈上分配（不逃逸）
void test() {
    Point p = new Point(1, 2);  // JIT 优化后在栈上分配
    return p.x + p.y;
}

// 标量替换
Point p = new Point(1, 2);
return p.x + p.y;
// 替换为：return 1 + 2;
```

**参数：**
```bash
-XX:+DoEscapeAnalysis      # 开启逃逸分析（默认开启）
-XX:+EliminateAllocations  # 开启标量替换（默认开启）
-XX:+EliminateLocks        # 开启锁消除（默认开启）
```

---

## 4. JVM 锁升级过程？

**题目：**
请详细说明 JVM 锁的升级过程（偏向锁→轻量级锁→重量级锁）。

**答案：**
**锁状态：**
| 锁状态 | 偏向标志位 | 锁标志位 |
|--------|------------|----------|
| 无锁 | 1 | 01 |
| 偏向锁 | 1 | 01 |
| 轻量级锁 | 0 | 00 |
| 重量级锁 | 0 | 10 |

**锁升级过程：**
```
无锁 → 偏向锁 → 轻量级锁 → 重量级锁（单向）
```

**偏向锁：**
- 第一次获取锁时，将线程 ID 记录到对象头
- 后续同一线程获取锁，无需任何同步操作
- 撤销需要等待安全点，代价较高

**轻量级锁：**
- 在线程栈中创建锁记录（Lock Record）
- CAS 将对象头替换为锁记录地址
- 自旋重试获取锁，避免线程阻塞

**重量级锁：**
- 使用 Monitor（监视器锁）
- 线程阻塞/唤醒，由操作系统调度
- 适用于锁竞争激烈的场景

**触发升级：**
- 偏向锁 → 轻量级锁：其他线程竞争偏向锁
- 轻量级锁 → 重量级锁：自旋次数过多或时间过长

---

## 5. ClassLoader 类加载机制？

**题目：**
请详细说明 JVM 的类加载机制和双亲委派模型。

**答案：**
**类加载过程：**
1. **加载**：获取类的二进制字节流，生成 Class 对象
2. **验证**：文件格式、元数据、字节码、符号引用验证
3. **准备**：为类变量分配内存，设置默认值
4. **解析**：将符号引用转换为直接引用
5. **初始化**：执行 <clinit> 方法，静态变量赋值

**类加载器分类：**
- **Bootstrap ClassLoader**：C++ 实现，加载核心类库
- **Extension ClassLoader**：Java 实现，加载扩展类
- **Application ClassLoader**：Java 实现，加载 classpath 类
- **自定义 ClassLoader**：继承 ClassLoader

**双亲委派模型：**
类加载器委派父加载器尝试加载，只有父加载器无法加载时才由自身加载。

**加载流程：**
```
CustomClassLoader.loadClass()
    → 检查是否已加载
    → 委派给父加载器（Application → Extension → Bootstrap）
    → 父加载器尝试加载
    → 父加载器找不到，子加载器自身加载
```

**破坏双亲委派场景：**
- **JDBC 驱动加载**：使用 SPI 机制，需要线程上下文类加载器
- **Tomcat 类加载器**：隔离不同应用，打破双亲委派
- **OSGi 类加载器**：每个 Bundle 独立类加载器

**类加载器命名空间：**
同一个类被不同类加载器加载，是完全不同的类（类加载器是类身份的一部分）。
