# ElasticSearch 面试题

## 1. ElasticSearch 是什么？有什么特点？

**题目：**
ElasticSearch 是什么？它有什么特点？

**答案：**
ElasticSearch 是一个基于 Lucene 的分布式搜索引擎，主要特点：

**核心特点：**
- **分布式架构**：支持水平扩展，可处理 PB 级数据
- **近实时搜索**：数据写入后秒级可搜索
- **高可用**：支持集群、数据分片和副本
- **RESTful API**：提供简洁的 HTTP 接口
- **全文检索**：支持分词、相关性排序
- **Schema Free**：无需预先定义 Schema

**使用场景：**
- 站内搜索
- 日志分析（ELK Stack）
- 数据可视化（Kibana）
- 商业智能分析

**基本概念：**
```bash
# 集群（Cluster）：一组节点的集合
# 节点（Node）：集群中的单个服务器
# 索引（Index）：文档的集合（相当于数据库）
# 类型（Type）：7.x 已废弃
# 文档（Document）：JSON 格式的数据（相当于行）
# 分片（Shard）：索引的拆分，可分布在不同节点
# 副本（Replica）：分片的备份，提高可用性
```

---

## 2. ElasticSearch 集群架构和数据存储原理？

**题目：**
请说明 ElasticSearch 的集群架构和数据存储原理。

**答案：**
**集群架构：**
```
┌─────────────────────────────────────────────────────────────────┐
│                    ElasticSearch 集群架构                          │
│                                                              │
│  ┌─────────┐  ┌─────────┐  ┌─────────┐  ┌─────────┐       │
│  │  Node1  │  │  Node2  │  │  Node3  │  │  Node4  │       │
│  │(Master) │  │ (Data)  │  │ (Data)  │  │ (Data)  │       │
│  └───┬─────┘  └────┬────┘  └────┬────┘  └────┬────┘       │
│      │              │              │              │            │
│      └──────────────┼──────────────┼──────────────┘            │
│                     │                                     │
│                     ▼                                     │
│              ┌─────────────────────────────────┐            │
│              │         集群状态管理              │            │
│              │  - 节点发现                      │            │
│              │  - 分片分配                      │            │
│              │  - 故障检测                      │            │
│              └─────────────────────────────────┘            │
└─────────────────────────────────────────────────────────────────┘
```

**数据分片存储：**
```bash
# 创建索引时指定分片数
PUT /my_index
{
  "settings": {
    "number_of_shards": 3,      # 主分片数
    "number_of_replicas": 1     # 副本数
  }
}

# 分片分布示例：
# Node1: my_index-0 (primary), my_index-2 (replica)
# Node2: my_index-1 (primary), my_index-0 (replica)
# Node3: my_index-2 (primary), my_index-1 (replica)
```

**数据写入流程：**
```
1. 客户端发送请求到任意节点（协调节点）
      │
      ▼
2. 协调节点计算文档 ID 的哈希值，确定目标分片
      │
      ▼
3. 请求转发到主分片所在节点
      │
      ▼
4. 主分片执行写入，更新内存缓冲区
      │
      ▼
5. 主分片并行将请求转发到所有副本分片
      │
      ▼
6. 副本分片写入成功后，返回确认
      │
      ▼
7. 主分片收到所有副本确认，返回客户端成功
```

**数据读取流程：**
```bash
# 读取文档
GET /my_index/_doc/1

# 流程：
# 1. 协调节点接收请求
# 2. 计算分片 ID（hash(doc_id) % num_shards）
# 3. 从主分片或副本分片读取（负载均衡）
# 4. 返回结果给客户端
```

---

## 3. ElasticSearch 倒排索引原理？

**题目：**
请详细说明 ElasticSearch 倒排索引的原理。

**答案：**
**倒排索引结构：**
```
┌─────────────────────────────────────────────────────────────────┐
│                    倒排索引结构                                    │
│                                                              │
│  正排索引（文档 → 词）：                                        │
│  ┌─────────────────────────────────────────────────────┐     │
│  │ 文档ID    │  内容                                      │     │
│  ├─────────────────────────────────────────────────────┤     │
│  │  doc1    │  elasticsearch is great                    │     │
│  │  doc2    │  elasticsearch is powerful                 │     │
│  │  doc3    │  elasticsearch is fast                    │     │
│  └─────────────────────────────────────────────────────┘     │
│                                                              │
│  倒排索引（词 → 文档）：                                        │
│  ┌─────────────────────────────────────────────────────┐     │
│  │  词汇    │  文档列表    │  位置信息                  │     │
│  ├─────────────────────────────────────────────────────┤     │
│  │ elasticsearch │ doc1,doc2,doc3 │ (0),(0),(0)        │     │
│  │ is       │ doc1,doc2,doc3 │ (1),(1),(1)            │     │
│  │ great    │ doc1           │ (2)                     │     │
│  │ powerful │ doc2           │ (2)                     │     │
│  │ fast     │ doc3           │ (2)                     │     │
│  └─────────────────────────────────────────────────────┘     │
└─────────────────────────────────────────────────────────────────┘
```

**倒排索引组成部分：**
```java
// 1. Term Dictionary（词典）
//    按字母排序的所有词条

// 2. Term Index（词条索引）
//    快速定位词典的索引结构（B+Tree 或 FST）

// 3. Posting List（倒排表）
//    包含：
//    - 文档 ID 列表
//    - 词频（TF）：词在文档中出现次数
//    - 位置信息：词在文档中的位置
//    - 偏移量：词的字符偏移

// 示例：搜索 "elasticsearch fast"
//    - elasticsearch: [doc1, doc2, doc3]
//    - fast: [doc3]
//    - 取交集：[doc3]
//    - 相关性评分：doc3 最高
```

**分词器（Analyzer）：**
```bash
# 分词器组成
POST _analyze
{
  "analyzer": "standard",
  "text": "ElasticSearch is powerful"
}

# 输出：
# Token(elasticsearch, 0-13, 0)
# Token(is, 14-16, 1)
# Token(powerful, 17-25, 2)

# 分词器组成：
# 1. Character Filter：字符过滤（HTML 标签、特殊字符）
# 2. Tokenizer：分词（按空格、标点分词）
# 3. Token Filter：词过滤（小写化、词干提取、停用词）
```

**自定义分词器：**
```bash
PUT /my_index
{
  "settings": {
    "analysis": {
      "analyzer": {
        "my_analyzer": {
          "type": "custom",
          "tokenizer": "standard",
          "filter": ["lowercase", "stop", "snowball"]
        }
      },
      "filter": {
        "stop": {
          "type": "stop",
          "stopwords": "_english_"
        }
      }
    }
  },
  "mappings": {
    "properties": {
      "title": {
        "type": "text",
        "analyzer": "my_analyzer"
      }
    }
  }
}
```

---

## 4. ElasticSearch 查询类型有哪些？

**题目：**
ElasticSearch 有哪些常用的查询类型？

**答案：**
**查询分类：**
```
┌─────────────────────────────────────────────────────────────────┐
│                    ES 查询类型                                    │
├─────────────────────────────────────────────────────────────────┤
│                                                              │
│  ┌──────────────────┐  ┌──────────────────┐                │
│  │  全文查询        │  │  精确查询        │                │
│  │  - match         │  │  - term         │                │
│  │  - match_phrase  │  │  - terms        │                │
│  │  - multi_match   │  │  - range        │                │
│  │  - query_string  │  │  - exists       │                │
│  └──────────────────┘  └──────────────────┘                │
│                                                              │
│  ┌──────────────────┐  ┌──────────────────┐                │
│  │  复合查询       │  │  嵌套查询        │                │
│  │  - bool         │  │  - nested       │                │
│  │  - function     │  │  - parent_child │                │
│  │  - dis_max      │  │  - has_parent  │                │
│  │  - constant_score│ │  - has_child   │                │
│  └──────────────────┘  └──────────────────┘                │
│                                                              │
└─────────────────────────────────────────────────────────────────┘
```

**常用查询示例：**
```bash
# 1. match 查询（全文检索）
GET /my_index/_search
{
  "query": {
    "match": {
      "content": "elasticsearch powerful"
    }
  }
}

# 2. match_phrase 查询（短语匹配）
GET /my_index/_search
{
  "query": {
    "match_phrase": {
      "content": {
        "query": "elasticsearch powerful",
        "slop": 1  # 允许词之间间隔
      }
    }
  }
}

# 3. term 查询（精确匹配）
GET /my_index/_search
{
  "query": {
    "term": {
      "status": "published"
    }
  }
}

# 4. terms 查询（多值精确匹配）
GET /my_index/_search
{
  "query": {
    "terms": {
      "tags": ["java", "elasticsearch"]
    }
  }
}

# 5. range 查询（范围查询）
GET /my_index/_search
{
  "query": {
    "range": {
      "age": {
        "gte": 18,
        "lte": 30
      }
    }
  }
}

# 6. bool 查询（复合查询）
GET /my_index/_search
{
  "query": {
    "bool": {
      "must": [
        { "match": { "title": "elasticsearch" }}
      ],
      "should": [
        { "match": { "content": "tutorial" }},
        { "match": { "content": "guide" }}
      ],
      "must_not": [
        { "term": { "status": "draft" }}
      ],
      "filter": [
        { "range": { "date": { "gte": "2023-01-01" }}}
      ]
    }
  }
}

# 7. nested 查询（嵌套文档查询）
GET /my_index/_search
{
  "query": {
    "nested": {
      "path": "comments",
      "query": {
        "bool": {
          "must": [
            { "match": { "comments.content": "great" }}
          ]
        }
      }
    }
  }
}
```

**相关性评分：**
```bash
# 使用 function_score 自定义评分
GET /my_index/_search
{
  "query": {
    "function_score": {
      "query": {
        "match": { "content": "elasticsearch" }
      },
      "functions": [
        {
          "field_value_factor": {
            "field": "views",
            "factor": 1.2,
            "modifier": "log1p",
            "missing": 1
          },
          "weight": 1
        }
      ],
      "boost_mode": "multiply"
    }
  }
}
```

---

## 5. ElasticSearch 数据同步策略？

**题目：**
ElasticSearch 与数据库的数据同步有哪些策略？

**答案：**
**同步策略：**
```
┌─────────────────────────────────────────────────────────────────┐
│                    数据同步策略                                    │
├─────────────────────────────────────────────────────────────────┤
│                                                              │
│  1. 双写（Dual Write）                                         │
│     应用同时写 ES 和数据库                                       │
│     优点：简单                                                 │
│     缺点：数据一致性问题                                       │
│                                                              │
│  2. 异步写入（Async Write）                                    │
│     先写数据库，消息队列异步同步到 ES                            │
│     优点：解耦、可靠                                           │
│     缺点：延迟                                                 │
│                                                              │
│  3. 增量同步（Canal / Debezium）                               │
│     监听 Binlog 增量同步到 ES                                   │
│     优点：低延迟、可靠                                         │
│     缺点：复杂                                                 │
│                                                              │
│  4. 全量 + 增量同步                                           │
│     先全量导入，再增量同步                                      │
│     优点：数据完整                                             │
│     缺点：维护复杂                                             │
│                                                              │
└─────────────────────────────────────────────────────────────────┘
```

**Logstash 同步：**
```ruby
# logstash/pipeline/mysql.conf
input {
  jdbc {
    jdbc_driver_library => "/path/mysql-connector-java.jar"
    jdbc_driver_class => "com.mysql.cj.jdbc.Driver"
    jdbc_connection_string => "jdbc:mysql://localhost:3306/mydb"
    jdbc_user => "root"
    jdbc_password => "password"
    
    # 全量还是增量
    tracking_column => "updated_at"
    use_column_value => true
    
    # SQL 语句
    statement => "SELECT * FROM users WHERE updated_at > :sql_last_value"
    
    # 调度
    schedule => "* * * * *"  # 每分钟执行
  }
}

output {
  elasticsearch {
    hosts => ["localhost:9200"]
    index => "users"
    document_id => "%{id}"
  }
}
```

**Canal 同步：**
```java
// Canal 监听 MySQL Binlog
CanalConnector connector = CanalConnectors.newSingleConnector(
    new InetSocketAddress("127.0.0.1", 11111),
    "example",
    "",
    ""
);

connector.connect();
connector.subscribe(".*\\..*");
connector.rollback();

while (running) {
    Message message = connector.get(100);
    for (Entry entry : message.getEntries()) {
        // 解析 Binlog
        RowChange rowChage = CanalEntryParser.parse(
            entry.getStoreValue());
        
        for (CanalEntry.RowData rowData : rowChage.getRowDatasList()) {
            // 获取变更数据
            Column[] beforeColumns = rowData.getBeforeColumnsList().toArray();
            Column[] afterColumns = rowData.getAfterColumnsList().toArray();
            
            // 同步到 ES
            syncToElasticsearch(beforeColumns, afterColumns);
        }
    }
}
```

**数据同步注意事项：**
```bash
# 1. 索引别名管理
POST /_aliases
{
  "actions": [
    { "add": { "index": "users_v1", "alias": "users_write" }},
    { "add": { "index": "users_v1", "alias": "users_read" }}
  ]
}

# 2. 零停机索引切换
# 全量数据导入到新索引
# 切换别名到新索引
# 删除旧索引

# 3. 数据一致性校验
# 定期对比 ES 和数据库的数据量
# 定时任务：CHECKSUM 校验
```

---

## 6. ElasticSearch 性能优化策略？

**题目：**
ElasticSearch 有哪些性能优化策略？

**答案：**
**索引优化：**
```bash
# 1. 合理的分片数
# 原则：每个分片 20-50GB
PUT /my_index
{
  "settings": {
    "number_of_shards": 3,
    "number_of_replicas": 1,
    "refresh_interval": "30s"  # 降低刷新频率
  }
}

# 2. 字段映射优化
PUT /my_index
{
  "mappings": {
    "properties": {
      "id": { "type": "keyword" },  # 精确匹配用 keyword
      "title": { 
        "type": "text",
        "fields": {
          "keyword": { "type": "keyword" }  # 同时支持精确匹配
        }
      },
      "views": { "type": "long" },
      "date": { "type": "date" }
    }
  }
}

# 3. 禁用不需要的功能
PUT /my_index
{
  "settings": {
    "number_of_replicas": 1,
    "refresh_interval": "30s"
  },
  "mappings": {
    "properties": {
      "content": {
        "type": "text",
        "norms": false,      # 禁用评分因子
        "index_options": "positions"  # 只保留位置信息
      }
    }
  }
}
```

**查询优化：**
```bash
# 1. 使用 filter 缓存
GET /my_index/_search
{
  "query": {
    "bool": {
      "must": [
        { "match": { "title": "elasticsearch" }}
      ],
      "filter": [
        { "term": { "status": "published" }},
        { "range": { "date": { "gte": "2023-01-01" }}}
      ]
    }
  }
}

# 2. 限制返回字段
GET /my_index/_search
{
  "_source": ["id", "title", "date"],
  "query": { "match": { "content": "elasticsearch" }}
}

# 3. 分页优化（深度分页问题）
# 禁止使用 from/size 深分页
# 使用 search_after 或 scroll

# search_after 方式
GET /my_index/_search
{
  "query": { "match_all": {} },
  "sort": [{"_id": "asc"}],
  "size": 10,
  "search_after": [ "doc_id_10" ]
}

# 4. 使用预聚合
GET /my_index/_search
{
  "size": 0,
  "aggs": {
    "status_counts": {
      "terms": { "field": "status" }
    },
    "avg_views": {
      "avg": { "field": "views" }
    }
  }
}
```

**集群配置优化：**
```bash
# elasticsearch.yml

# 1. 堆内存设置
# -Xms4g
# -Xmx4g
# 不要超过 32GB，建议不超过物理内存 50%

# 2. 禁用 Swap
bootstrap.memory_lock: true

# 3. 调整线程池
thread_pool:
  write:
    size: 16
    queue_size: 1000

# 4. 调整缓冲区
indices.memory.index_buffer_size: 20%

# 5. GC 配置
-XX:+UseG1GC
-XX:MaxGCPauseMillis: 200
```

**监控和诊断：**
```bash
# 查看集群健康
GET _cluster/health

# 查看索引状态
GET _cat/indices?v

# 查看分片分布
GET _cat/shards?v

# 查看慢查询
GET _search
{
  "profile": true  # 开启查询分析
}
```

---

## 7. ElasticSearch 分布式一致性原理？

**题目：**
ElasticSearch 如何保证分布式数据一致性？

**答案：**
**数据一致性级别：**
```bash
# consistency 参数（写入时）
PUT /my_index/_doc/1?consistency=all
{
  "title": "elasticsearch"
}

# 参数值：
# - one：只写入主分片
# - all：写入所有分片副本
# - quorum：写入大多数分片（默认）

# timeout 参数
# 等待超时时间
PUT /my_index/_doc/1?timeout=30s
{
  "title": "elasticsearch"
}
```

**写一致性保证：**
```
┌─────────────────────────────────────────────────────────────────┐
│                    ES 写入一致性流程                               │
│                                                              │
│  1. 客户端发送写入请求到协调节点                                  │
│           │                                                    │
│           ▼                                                    │
│  2. 协调节点计算分片，将请求发送到主分片                          │
│           │                                                    │
│           ▼                                                    │
│  3. 主分片写入成功后，并行发送到所有副本分片                       │
│           │                                                    │
│           ▼                                                    │
│  4. 等待副本分片响应（根据 consistency 参数）                     │
│           │                                                    │
│           ▼                                                    │
│  5. 达到要求后返回成功，否则返回失败                             │
└─────────────────────────────────────────────────────────────────┘
```

**集群状态：**
```bash
# 查看集群状态
GET _cluster/health

# 状态说明：
# green：所有分片都正常
# yellow：主分片正常，副本分片不可用
# red：主分片不可用

# 集群状态信息
{
  "cluster_name": "elasticsearch",
  "status": "green",
  "timed_out": false,
  "number_of_nodes": 3,
  "active_shards": 12,
  "relocating_shards": 0,
  "initializing_shards": 0,
  "unassigned_shards": 0
}
```

**故障恢复：**
```bash
# 分片故障检测
# 1. 主分片失联，标记为 unassigned
# 2. 副本分片提升为主分片
# 3. 分配新的副本

# 手动分配分片
POST /_cluster/reroute
{
  "commands": [
    {
      "allocate_stale_primary": {
        "index": "my_index",
        "shard": 0,
        "node": "node_name",
        "accept_data_loss": true
      }
    }
  ]
}
```

**乐观并发控制：**
```bash
# 使用 _seq_no 和 _primary_term 进行乐观锁控制

# 1. 获取当前版本
GET /my_index/_doc/1
{
  "_seq_no": 10,
  "_primary_term": 1
}

# 2. 使用版本更新
PUT /my_index/_doc/1?if_seq_no=10&if_primary_term=1
{
  "title": "updated title"
}

# 响应：
# - 成功：返回新版本
# - 失败：返回 version_conflict_engine_exception
```

---

## 8. ElasticSearch 集群脑裂问题？

**题目：**
什么是 ElasticSearch 集群脑裂问题？如何解决？

**答案：**
**脑裂问题：**
```
┌─────────────────────────────────────────────────────────────────┐
│                    脑裂问题示意                                   │
│                                                              │
│  正常状态：                                                     │
│  ┌─────────┐                                                   │
│  │ Master  │  ← 选举产生                                         │
│  └────┬────┘                                                   │
│       │                                                        │
│  ┌────┴────┬────────────────────┐                            │
│  ▼         ▼                        ▼                        │
│  Node1     Node2                  Node3                       │
│                                                              │
│  脑裂状态：                                                     │
│  ┌─────────┐          ┌─────────┐                          │
│  │ Master1 │          │ Master2 │  ← 网络分区后各自选举       │
│  └────┬────┘          └────┬────┘                             │
│       │                     │                                  │
│  ┌────┴────┐          ┌────┴────┐                          │
│  ▼         ▼          ▼         ▼                          │
│  Node1     Node2      Node3     Node4                       │
│                                                              │
│  问题：两个主节点，集群数据不一致                                │
└─────────────────────────────────────────────────────────────────┘
```

**解决策略：**
```bash
# 1. discovery.zen.minimum_master_nodes
# 设置最少主节点数，防止脑裂
# 计算公式：(master_eligible_nodes / 2) + 1
# 例如：3 个节点，设置为 2

# elasticsearch.yml
discovery.zen.minimum_master_nodes: 2

# 2. 控制角色分离
# node.master: true/false
# node.data: true/false
# node.ingest: true/false

# 3. 使用专用主节点
# 3 个专用主节点
# 多个数据节点

# 4. 节点角色配置
# 专用主节点（不存储数据）
node.master: true
node.data: false
node.ingest: false

# 数据节点
node.master: false
node.data: true
node.ingest: true

# 协调节点
node.master: false
node.data: false
node.ingest: false
```

**选举原理：**
```java
// Master 选举算法：Zen Discovery
// 1. 节点发现
// 2. Ping 探测
// 3. 选举投票

// 选举条件：
// 1. 节点有资格成为主节点
// 2. 收到的投票数 >= minimum_master_nodes
// 3. 获得最高配置版本号

// 防止脑裂：
// 1. minimum_master_nodes 设置正确
// 2. 网络分区检测
// 3. 主节点故障快速发现
```

---

## 9. ElasticSearch 与关系型数据库对比？

**题目：**
ElasticSearch 与关系型数据库有什么区别？

**答案：**
**对比表：**
```
┌──────────────────┬─────────────────────┬─────────────────────┐
│       特性       │   ElasticSearch     │   MySQL             │
├──────────────────┼─────────────────────┼─────────────────────┤
│  数据模型       │   文档（JSON）      │   表/行             │
│  查询能力       │   全文检索          │   SQL 查询          │
│  性能           │   读性能好          │   读写均衡          │
│  数据一致性     │   最终一致          │   强一致            │
│  扩展性         │   水平扩展          │   垂直扩展          │
│  Schema        │   Schema Free       │   固定 Schema       │
│  事务           │   弱支持            │   ACID              │
│  聚合分析       │   实时聚合          │   预聚合            │
│  适用场景       │   搜索、日志        │   业务数据          │
└──────────────────┴─────────────────────┴─────────────────────┘
```

**数据映射：**
```
MySQL → ElasticSearch

数据库（Database）  →  索引（Index）
表（Table）          →  索引（Index）
行（Row）            →  文档（Document）
列（Column）         →  字段（Field）
索引（Index）        →  倒排索引
JOIN                 →  Nested / Parent-Child
```

**使用建议：**
```bash
# 1. 适合 ES 的场景
- 全文检索
- 日志分析
- 复杂聚合分析
- 实时监控

# 2. 适合 MySQL 的场景
- 事务操作
- 强一致性要求
- 复杂 JOIN
- 统计数据

# 3. 架构建议：MySQL + ES 双写
- MySQL：存储主数据
- ES：搜索和查询
- 业务层同步：Canal / Logstash
```

---

## 10. ElasticSearch 版本升级注意事项？

**题目：**
ElasticSearch 版本升级有哪些注意事项？

**答案：**
**升级策略：**
```
┌─────────────────────────────────────────────────────────────────┐
│                    升级策略                                        │
├─────────────────────────────────────────────────────────────────┤
│                                                              │
│  1. 小版本升级（同一主版本内）                                   │
│     - 滚动升级，不停机                                           │
│     - 逐个节点升级                                              │
│     - 保持集群健康                                              │
│                                                              │
│  2. 大版本升级                                                 │
│     - 需要完整升级                                              │
│     - 可能需要重索引                                            │
│     - 建议先在测试环境验证                                       │
│                                                              │
│  3. 注意事项                                                   │
│     - 备份数据                                                  │
│     - 检查兼容性                                                │
│     - 测试查询语法                                              │
│                                                              │
└─────────────────────────────────────────────────────────────────┘
```

**滚动升级步骤：**
```bash
# 1. 禁用分片分配
PUT /_cluster/settings
{
  "persistent": {
    "cluster.routing.allocation.enable": "primaries"
  }
}

# 2. 停止非必要写入
# 业务层暂停写入

# 3. 同步刷新
POST /_flush/synced

# 4. 停止一个节点，升级 ES
systemctl stop elasticsearch
# 升级软件包
systemctl start elasticsearch

# 5. 等待节点加入集群
GET _cat/health

# 6. 恢复分片分配
PUT /_cluster/settings
{
  "persistent": {
    "cluster.routing.allocation.enable": null
  }
}

# 7. 重复步骤 4-6，升级所有节点

# 8. 恢复写入
```

**兼容性检查：**
```bash
# 1. 检查索引兼容性
GET /_cat/indices?v&h=index,pri,rep,docs.count,store.size

# 2. 检查集群升级助手
# ES 7.x+ 提供 upgrade_check API
GET /_upgrade_checker

# 3. 常用兼容性变更
# ES 5.x: doc values 默认必需
# ES 6.x: 一个索引只能有一个 type（_doc）
# ES 7.x: 默认弃用 type
# ES 8.x: 默认不再支持 XContentBuilder
```

**数据迁移：**
```bash
# 使用 reindex API 迁移数据
POST /_reindex
{
  "source": {
    "index": "old_index"
  },
  "dest": {
    "index": "new_index",
    "op_type": "create"
  }
}

# 跨集群迁移
POST /_reindex
{
  "source": {
    "remote": {
      "host": "http://old-cluster:9200"
    },
    "index": "old_index"
  },
  "dest": {
    "index": "new_index"
  }
}
```
