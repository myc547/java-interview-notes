# 设计模式面试题答案

## 1. 单例模式？

**题目：**
请实现单例模式？

**答案：**
**饿汉式（线程安全）：**
```java
public class Singleton {
    private static final Singleton INSTANCE = new Singleton();
    
    private Singleton() {}
    
    public static Singleton getInstance() {
        return INSTANCE;
    }
}
```

**懒汉式（双重检查）：**
```java
public class Singleton {
    private static volatile Singleton instance;
    
    private Singleton() {}
    
    public static Singleton getInstance() {
        if (instance == null) {
            synchronized (Singleton.class) {
                if (instance == null) {
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
```

**静态内部类：**
```java
public class Singleton {
    private Singleton() {}
    
    private static class Holder {
        static final Singleton INSTANCE = new Singleton();
    }
    
    public static Singleton getInstance() {
        return Holder.INSTANCE;
    }
}
```

**枚举：**
```java
public enum Singleton {
    INSTANCE;
    
    public void doSomething() {}
}
```

---

## 2. 工厂模式？

**题目：**
什么是工厂模式？如何实现？

**答案：**
**简单工厂：**
```java
interface Product {}
class ProductA implements Product {}
class ProductB implements Product {}

class SimpleFactory {
    public static Product create(String type) {
        switch (type) {
            case "A": return new ProductA();
            case "B": return new ProductB();
            default: throw new IllegalArgumentException();
        }
    }
}
```

**工厂方法：**
```java
interface Product {}
interface Factory {
    Product create();
}

class ProductA implements Product {}
class ProductAFactory implements Factory {
    public Product create() { return new ProductA(); }
}

class ProductB implements Product {}
class ProductBFactory implements Factory {
    public Product create() { return new ProductB(); }
}
```

**抽象工厂：**
```java
interface ProductA {}
interface ProductB {}

interface Factory {
    ProductA createA();
    ProductB createB();
}

class Factory1 implements Factory {
    public ProductA createA() { return new ProductA1(); }
    public ProductB createB() { return new ProductB1(); }
}
```

---

## 3. 建造者模式？

**题目：**
建造者模式有什么用？如何实现？

**答案：**
**建造者模式：**
- 分离复杂对象的构建和表示
- 支持链式调用

**实现：**
```java
class User {
    private String name;
    private int age;
    private String address;
    
    private User(Builder builder) {
        this.name = builder.name;
        this.age = builder.age;
        this.address = builder.address;
    }
    
    public static class Builder {
        private String name;
        private int age;
        private String address;
        
        public Builder name(String name) {
            this.name = name;
            return this;
        }
        
        public Builder age(int age) {
            this.age = age;
            return this;
        }
        
        public Builder address(String address) {
            this.address = address;
            return this;
        }
        
        public User build() {
            return new User(this);
        }
    }
}

// 使用
User user = new User.Builder()
    .name("张三")
    .age(20)
    .address("北京")
    .build();
```

---

## 4. 策略模式？

**题目：**
策略模式是什么？如何使用？

**答案：**
**策略模式：**
- 定义算法家族
- 运行时切换算法

**实现：**
```java
// 策略接口
interface Strategy {
    int calculate(int a, int b);
}

// 具体策略
class AddStrategy implements Strategy {
    public int calculate(int a, int b) { return a + b; }
}

class SubtractStrategy implements Strategy {
    public int calculate(int a, int b) { return a - b; }
}

class MultiplyStrategy implements Strategy {
    public int calculate(int a, int b) { return a * b; }
}

// 上下文
class Context {
    private Strategy strategy;
    
    public Context(Strategy strategy) {
        this.strategy = strategy;
    }
    
    public void setStrategy(Strategy strategy) {
        this.strategy = strategy;
    }
    
    public int execute(int a, int b) {
        return strategy.calculate(a, b);
    }
}

// 使用
Context context = new Context(new AddStrategy());
context.execute(1, 2);  // 3
context.setStrategy(new MultiplyStrategy());
context.execute(1, 2);  // 2
```

---

## 5. 观察者模式？

**题目：**
观察者模式是什么？如何实现？

**答案：**
**观察者模式：**
- 一对多依赖
- 当一个对象变化，通知所有依赖者

**实现：**
```java
// 主题接口
interface Subject {
    void register(Observer observer);
    void remove(Observer observer);
    void notifyAll();
}

// 观察者接口
interface Observer {
    void update(String message);
}

// 具体主题
class NewsSubject implements Subject {
    private List<Observer> observers = new ArrayList<>();
    private String message;
    
    public void setMessage(String message) {
        this.message = message;
        notifyAll();
    }
    
    public void register(Observer observer) {
        observers.add(observer);
    }
    
    public void remove(Observer observer) {
        observers.remove(observer);
    }
    
    public void notifyAll() {
        for (Observer observer : observers) {
            observer.update(message);
        }
    }
}

// 具体观察者
class User implements Observer {
    private String name;
    
    public User(String name) {
        this.name = name;
    }
    
    public void update(String message) {
        System.out.println(name + " 收到: " + message);
    }
}

// 使用
NewsSubject subject = new NewsSubject();
subject.register(new User("张三"));
subject.register(new User("李四"));
subject.setMessage("有新消息！");
```

**Java内置支持：**
```java
// Observable（已废弃）
// Observer接口（已废弃）

// 使用PropertyChangeSupport
class Subject {
    private PropertyChangeSupport support = new PropertyChangeSupport(this);
    
    public void addListener(PropertyChangeListener listener) {
        support.addPropertyChangeListener(listener);
    }
    
    public void setValue(String newValue) {
        support.firePropertyChange("value", oldValue, newValue);
    }
}
```

---

## 6. 装饰器模式？

**题目：**
装饰器模式是什么？如何实现？

**答案：**
**装饰器模式：**
- 动态添加功能
- 比继承更灵活

**实现：**
```java
// 组件接口
interface Component {
    void operation();
}

// 具体组件
class ConcreteComponent implements Component {
    public void operation() {
        System.out.println("基础功能");
    }
}

// 装饰器
abstract class Decorator implements Component {
    protected Component component;
    
    public Decorator(Component component) {
        this.component = component;
    }
    
    public void operation() {
        component.operation();
    }
}

// 具体装饰器
class ConcreteDecoratorA extends Decorator {
    public ConcreteDecoratorA(Component component) {
        super(component);
    }
    
    public void operation() {
        super.operation();
        System.out.println("装饰功能A");
    }
}

class ConcreteDecoratorB extends Decorator {
    public ConcreteDecoratorB(Component component) {
        super(component);
    }
    
    public void operation() {
        super.operation();
        System.out.println("装饰功能B");
    }
}

// 使用
Component component = new ConcreteComponent();
component = new ConcreteDecoratorA(component);
component = new ConcreteDecoratorB(component);
component.operation();
```

**Java IO中的应用：**
```java
InputStream in = new FileInputStream("file.txt");
InputStream buffer = new BufferedInputStream(in);
InputStream reader = new InputStreamReader(buffer);
```

---

## 7. 适配器模式？

**题目：**
适配器模式是什么？如何实现？

**答案：**
**适配器模式：**
- 转换接口
- 使不兼容的接口可以合作

**类适配器：**
```java
// 目标接口
interface Target {
    void request();
}

// 源类
class Adaptee {
    public void specificRequest() {
        System.out.println("特殊请求");
    }
}

// 适配器
class Adapter extends Adaptee implements Target {
    public void request() {
        specificRequest();
    }
}
```

**对象适配器：**
```java
class Adapter implements Target {
    private Adaptee adaptee;
    
    public Adapter(Adaptee adaptee) {
        this.adaptee = adaptee;
    }
    
    public void request() {
        adaptee.specificRequest();
    }
}
```

**使用场景：**
- 旧代码适配新接口
- 第三方库集成
- 接口版本兼容

---

## 8. 代理模式？

**题目：**
代理模式是什么？如何实现？

**答案：**
**代理模式：**
- 控制访问
- 添加额外逻辑

**静态代理：**
```java
interface Subject {
    void request();
}

class RealSubject implements Subject {
    public void request() {
        System.out.println("真实请求");
    }
}

class ProxySubject implements Subject {
    private RealSubject realSubject;
    
    public ProxySubject(RealSubject realSubject) {
        this.realSubject = realSubject;
    }
    
    public void request() {
        System.out.println("代理前置");
        realSubject.request();
        System.out.println("代理后置");
    }
}
```

**动态代理：**
```java
class DynamicProxy implements InvocationHandler {
    private Object target;
    
    public DynamicProxy(Object target) {
        this.target = target;
    }
    
    public Object invoke(Object proxy, Method method, Object[] args) {
        System.out.println("前置处理");
        Object result = method.invoke(target, args);
        System.out.println("后置处理");
        return result;
    }
}

// 使用
Subject subject = (Subject) Proxy.newProxyInstance(
    Subject.class.getClassLoader(),
    new Class<?>[] { Subject.class },
    new DynamicProxy(new RealSubject())
);
subject.request();
```

**CGLIB代理：**
```java
class CglibProxy implements MethodInterceptor {
    public Object intercept(Object obj, Method method, 
                           Object[] args, MethodProxy proxy) {
        System.out.println("前置");
        Object result = proxy.invokeSuper(obj, args);
        System.out.println("后置");
        return result;
    }
}
```

---

## 9. 模板方法模式？

**题目：**
模板方法模式是什么？

**答案：**
**模板方法模式：**
- 定义算法骨架
- 具体步骤延迟到子类

**实现：**
```java
abstract class AbstractClass {
    // 模板方法
    public final void templateMethod() {
        method1();
        method2();
        method3();
    }
    
    protected void method1() {
        System.out.println("步骤1");
    }
    
    protected abstract void method2();
    
    protected void method3() {
        System.out.println("步骤3");
    }
}

class ConcreteClass extends AbstractClass {
    protected void method2() {
        System.out.println("具体实现步骤2");
    }
}

// 使用
AbstractClass obj = new ConcreteClass();
obj.templateMethod();
```

**使用场景：**
- JDBC模板（JdbcTemplate）
- Servlet的service()方法
- 流程处理框架

---

## 10. 责任链模式？

**题目：**
责任链模式是什么？如何实现？

**答案：**
**责任链模式：**
- 多个对象依次处理请求
- 链式传递

**实现：**
```java
// 处理者
abstract class Handler {
    private Handler next;
    
    public Handler setNext(Handler next) {
        this.next = next;
        return next;
    }
    
    public void handle(Request request) {
        if (doHandle(request) && next != null) {
            next.handle(request);
        }
    }
    
    protected abstract boolean doHandle(Request request);
}

// 具体处理者
class HandlerA extends Handler {
    protected boolean doHandle(Request request) {
        if (request.getLevel() == 1) {
            System.out.println("HandlerA处理");
            return false;
        }
        return true;
    }
}

class HandlerB extends Handler {
    protected boolean doHandle(Request request) {
        if (request.getLevel() == 2) {
            System.out.println("HandlerB处理");
            return false;
        }
        return true;
    }
}

// 使用
Handler handler = new HandlerA();
handler.setNext(new HandlerB());
handler.handle(new Request(2));
```

**使用场景：**
- Filter链
- 审批流程
- 异常处理链

---

*更多设计模式面试题答案*
